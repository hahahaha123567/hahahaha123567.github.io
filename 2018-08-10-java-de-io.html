<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/snowman-32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/snowman-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/snowman-16.ico">
  <link rel="mask-icon" href="/images/snowman-32.ico" color="#222">
  <meta name="google-site-verification" content="nIwDujusms8FJRDa0EoTbcjQopAILXWLI9fbAYxm7LE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hahahaha123567.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java 的 I&#x2F;O 库介绍，其中重点介绍了 NIO 部分在 server 端的应用">
<meta property="og:type" content="article">
<meta property="og:title" content="Java的IO">
<meta property="og:url" content="https://hahahaha123567.github.io/2018-08-10-java-de-io.html">
<meta property="og:site_name" content="hahahaha123567&#39;s Blog">
<meta property="og:description" content="Java 的 I&#x2F;O 库介绍，其中重点介绍了 NIO 部分在 server 端的应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image015.jpg">
<meta property="og:image" content="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image019.jpg">
<meta property="og:image" content="http://www.jasongj.com/img/java/reactor/classic_reactor.png">
<meta property="og:image" content="http://www.jasongj.com/img/java/reactor/multithread_reactor.png">
<meta property="og:image" content="http://www.jasongj.com/img/java/reactor/multi_reactor.png">
<meta property="article:published_time" content="2018-08-10T12:41:02.000Z">
<meta property="article:modified_time" content="2018-08-13T12:44:12.000Z">
<meta property="article:author" content="hahahaha123567">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image015.jpg">

<link rel="canonical" href="https://hahahaha123567.github.io/2018-08-10-java-de-io.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java的IO | hahahaha123567's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hahahaha123567's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2018-08-10-java-de-io.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/nicoumi.jpg">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java的IO
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-10 20:41:02" itemprop="dateCreated datePublished" datetime="2018-08-10T20:41:02+08:00">2018-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-08-13 20:44:12" itemprop="dateModified" datetime="2018-08-13T20:44:12+08:00">2018-08-13</time>
              </span>

          
            <div class="post-description">Java 的 I/O 库介绍，其中重点介绍了 NIO 部分在 server 端的应用</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java-I-O-类库概况"><a href="#Java-I-O-类库概况" class="headerlink" title="Java I/O 类库概况"></a>Java I/O 类库概况</h1><p>Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是： </p>
<ol>
<li>基于字节操作的 I/O 接口：InputStream 和 OutputStream</li>
<li>基于字符操作的 I/O 接口：Writer 和 Reader</li>
<li>基于磁盘操作的 I/O 接口：File</li>
<li>基于网络操作的 I/O 接口：Socket</li>
</ol>
<h1 id="字节与字符的转化接口"><a href="#字节与字符的转化接口" class="headerlink" title="字节与字符的转化接口"></a>字节与字符的转化接口</h1><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>InputStreamReader 类是字节到字符的转化桥梁，InputStream 到 Reader 的过程要指定编码字符集，否则将采用操作系统默认字符集</p>
<p>StreamDecoder 正是完成字节到字符的解码的实现类</p>
<h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>OutputStreamWriter 类完成，字符到字节的编码过程，由 StreamEncoder 完成编码过程 </p>
<h1 id="磁盘-I-O-工作机制"><a href="#磁盘-I-O-工作机制" class="headerlink" title="磁盘 I/O 工作机制"></a>磁盘 I/O 工作机制</h1><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image015.jpg" alt="磁盘 I/O"> </p>
<h1 id="Java-Socket-的工作机制"><a href="#Java-Socket-的工作机制" class="headerlink" title="Java Socket 的工作机制"></a>Java Socket 的工作机制</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能</p>
<p>打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭；交通工具有多种，每种交通工具也有相应的交通规则</p>
<p>Socket 也一样，也有多种：大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议</p>
<h3 id="建立通信链路-client"><a href="#建立通信链路-client" class="headerlink" title="建立通信链路 - client"></a>建立通信链路 - client</h3><p>当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭</p>
<p>在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误 </p>
<h3 id="建立通信链路-server"><a href="#建立通信链路-server" class="headerlink" title="建立通信链路 - server"></a>建立通信链路 - server</h3><p>与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址</p>
<p>之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口</p>
<p>这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中</p>
<p>所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接 </p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据</p>
<p>当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的</p>
<p>写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中 </p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image019.jpg" alt="NIO"> </p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>通道是对原 I/O 包中的流的模拟，到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象 </p>
<p>拿 NIO 与原来的 I/O 做个比较，通道就像是流。通道与流的不同之处在于通道是双向的，而流只是在一个方向上移动（一个流必须是 <code>InputStream</code> 或者 <code>OutputStream</code> 的子类）， 而  <code>通道 </code> 可以用于读、写或者同时用于读写 </p>
<p>正如前面提到的，所有数据都通过 <code>Buffer</code> 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节</p>
<h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出战还是在路上等等，也就是它可以轮询每个 Channel 的状态 </p>
<h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p><code>Buffer</code> 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 <code>Buffer</code> 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 <code>Stream</code> 对象中。</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的：在读取数据时，它是直接读到缓冲区中的；在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 <em>仅仅</em>  是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io 与 nio 比较</span></span><br><span class="line">FileInputStream fis;</span><br><span class="line"><span class="comment">// io</span></span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;in&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> temp = fis.read();</span><br><span class="line"><span class="keyword">while</span> (temp != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%c&quot;</span>, temp);</span><br><span class="line">    temp = fis.read();</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line"><span class="comment">// nio</span></span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;in&quot;</span>);</span><br><span class="line">FileChannel fc = fis.getChannel();</span><br><span class="line">ByteBuffer bb = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">fc.read(bb);</span><br><span class="line"><span class="keyword">byte</span>[] array = bb.array();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> b : array) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%c&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy file</span></span><br><span class="line">FileInputStream inStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>);</span><br><span class="line">FileOutputStream outStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">FileChannel inChannel = inStream.getChannel();</span><br><span class="line">FileChannel outChannel = outStream.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = inChannel.read(buffer);</span><br><span class="line">    <span class="keyword">if</span> (flag == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    outChannel.write(buffer);</span><br><span class="line">    buffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIO 引入了 Channel、Buffer 和 Selector 就是想把这些信息具体化，让程序员有机会控制它们，如：当我们调用 write() 往 SendQ 写数据时，当一次写的数据超过 SendQ 长度时需要按照 SendQ 的长度进行分割，这个过程中需要有将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的；而在 Buffer 中我们可以控制 Buffer 的 capacity，并且是否扩容以及如何扩容都可以控制 </p>
<h3 id="buffer-的状态变量"><a href="#buffer-的状态变量" class="headerlink" title="buffer 的状态变量"></a>buffer 的状态变量</h3><p>可以用三个值指定缓冲区在任意时刻的状态，这三个变量一起可以跟踪缓冲区的状态和它所包含的数据：</p>
<ul>
<li><code>position</code></li>
<li><code>limit</code></li>
<li><code>capacity</code></li>
</ul>
<p>相关详细：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">NIO 入门</a></p>
<h3 id="buffer-的访问方法"><a href="#buffer-的访问方法" class="headerlink" title="buffer 的访问方法"></a>buffer 的访问方法</h3><h5 id="缓存区分配和包装"><a href="#缓存区分配和包装" class="headerlink" title="缓存区分配和包装"></a>缓存区分配和包装</h5><ul>
<li>ByteBuffer.allocate( 1024 ) : ByteBuffer</li>
<li>ByteBuffer.wrap( new byte[1024] ) : ByteBuffer</li>
</ul>
<h5 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h5><p>您可能需要将用户数据保存到磁盘。在这种情况下，您必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘</p>
<p>或者，您可能想要从磁盘读取用户数据。在这种情况下，您要将数据从通道读到缓冲区中，然后检查缓冲区中的数据</p>
<ul>
<li>get()</li>
<li>put()</li>
</ul>
<h5 id="缓存区分片"><a href="#缓存区分片" class="headerlink" title="缓存区分片"></a>缓存区分片</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">3</span> );</span><br><span class="line">buffer.limit( <span class="number">7</span> );</span><br><span class="line">ByteBuffer slice = buffer.slice();</span><br></pre></td></tr></table></figure>

<h5 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h5><ul>
<li>byteByffer.asReadOnlyBuffer() </li>
</ul>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>Java NIO 中提供的 FileChannel 拥有 transferTo() 和 transferFrom() 两个方法，可直接把 FileChannel() 中的数据拷贝到另外一个 Channel，或者直接把另外一个 Channel 中的数据拷贝到 FileChannel </p>
<p>该接口常被用于高效的网络/文件的数据传输和大文件拷贝：在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于Java IO中提供的方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>);</span><br><span class="line">        socketChannel.connect(address);</span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(</span><br><span class="line">                NIOClient.class.getClassLoader().getResource(<span class="string">&quot;test.txt&quot;</span>).getFile(), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = file.getChannel();</span><br><span class="line">        channel.transferTo(<span class="number">0</span>, channel.size(), socketChannel);</span><br><span class="line">        channel.close();</span><br><span class="line">        file.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h1><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列：要么成功都成功，失败都失败，两个任务的状态可以保持一致</p>
<p>而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列</p>
<p>我们可以用打电话和发短信来很好的比喻同步与异步操作</p>
<p>在设计到 IO 处理时通常都会遇到一个是同步还是异步的处理方式的选择问题。因为同步与异步的 I/O 处理方式对调用者的影响很大，在数据库产品中都会遇到这个问题。因为 I/O 操作通常是一个非常耗时的操作，在一个任务序列中 I/O 通常都是性能瓶颈。但是同步与异步的处理方式对程序的可靠性影响非常大，同步能够保证程序的可靠性，而异步可以提升程序的性能，必须在可靠性和性能之间做个平衡，没有完美的解决办法。</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事</p>
<p>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作</p>
<p>虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加：增加的 CPU 使用时间能不能补偿系统的切换成本需要好好评估</p>
<h3 id="两种的方式的组合"><a href="#两种的方式的组合" class="headerlink" title="两种的方式的组合"></a>两种的方式的组合</h3><table>
<thead>
<tr>
<th><strong>组合方式</strong></th>
<th><strong>性能分析</strong></th>
</tr>
</thead>
<tbody><tr>
<td>同步阻塞</td>
<td>最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。</td>
</tr>
<tr>
<td>异步阻塞</td>
<td>这种方式在分布式数据库中经常用到，例如在往一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。 异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。</td>
</tr>
<tr>
<td>异步非阻塞</td>
<td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。 它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高。</td>
</tr>
</tbody></table>
<h1 id="server和异步IO"><a href="#server和异步IO" class="headerlink" title="server和异步IO"></a>server和异步IO</h1><h3 id="server-实现"><a href="#server-实现" class="headerlink" title="server 实现"></a>server 实现</h3><ul>
<li>Java I/O，单线程：循环处理请求——同一时间只能处理一个请求，等待I/O的过程浪费大量CPU资源，同时无法充分使用多CPU的优势 </li>
<li>Java I/O，多线程：为每个请求创建一个线程；为了防止连接请求过多，导致服务器创建的线程数过多，造成过多线程上下文切换的开销，可以通过线程池来限制创建的线程数 </li>
<li>Java NIO，单线程：经典 Reactor 模式——所有读/写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势，同时读/写操作也会阻塞对新连接请求的处理 </li>
<li>Java NIO，多线程：多工作线程 Reactor 模式</li>
<li>Java NIO，多线程：多 Reactor 模式</li>
</ul>
<h3 id="经典-Reactor-模式"><a href="#经典-Reactor-模式" class="headerlink" title="经典 Reactor 模式"></a>经典 Reactor 模式</h3><p>在Reactor模式中，包含如下角色</p>
<ul>
<li><strong>Reactor</strong> 将I/O事件发派给对应的Handler</li>
<li><strong>Acceptor</strong> 处理客户端连接请求</li>
<li><strong>Handlers</strong> 执行非阻塞读/写</li>
</ul>
<p><img src="http://www.jasongj.com/img/java/reactor/classic_reactor.png" alt="经典 Reactor 模式"> </p>
<p>调用 Selector 的静态工厂创建一个选择器，创建一个服务端的 Channel 绑定到一个 Socket 对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式</p>
<p>然后就可以调用 Selector 的 selectedKeys 方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 SelectionKey，通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据，而这里读取的数据是 Buffer，这个 Buffer 是我们可以控制的缓冲器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">          SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">&quot;Accept request from &#123;&#125;&quot;</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">          ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">          <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">          <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">            key.cancel();</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Received invalide data, close the connection&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          LOGGER.info(<span class="string">&quot;Received message &#123;&#125;&quot;</span>, <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">        &#125;</span><br><span class="line">        keys.remove(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上示代码中可以看到，多个Channel可以注册到同一个Selector对象上，实现了一个线程同时监控多个请求状态(channel)</p>
<p>同时注册时需要指定它所关注的事件，例如上示代码中 <em>socketServerChannel</em> 对象只注册了 <em>OP_ACCEPT</em> 事件，而 <em>socketChannel</em> 对象只注册了 <em>OP_READ</em> 事件</p>
<p><code>selector.select()</code> 是阻塞的，当有至少一个通道可用时该方法返回可用通道个数。同时该方法只捕获Channel注册时指定的所关注的事件 </p>
<h3 id="多工作线程Reactor模式"><a href="#多工作线程Reactor模式" class="headerlink" title="多工作线程Reactor模式"></a>多工作线程Reactor模式</h3><p>经典Reactor模式中，尽管一个线程可同时监控多个请求(channel)，但是所有读/写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势，同时读/写操作也会阻塞对新连接请求的处理；因此可以引入多线程，并行处理多个读/写操作 </p>
<p><img src="http://www.jasongj.com/img/java/reactor/multithread_reactor.png" alt="多工作线程Reactor模式"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(selector.selectNow() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">          SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">&quot;Accept request from &#123;&#125;&quot;</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          SelectionKey readKey = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          readKey.attach(<span class="keyword">new</span> Processor());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          Processor processor = (Processor) key.attachment();</span><br><span class="line">          processor.process(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上示代码中可以看到，注册完 SocketChannel 的 <em>OP_READ</em> 事件后，可以对相应的 SelectionKey attach 一个对象（本例中 attach 了一个 Processor 对象，该对象处理读请求），并且在获取到可读事件后，可以取出该对象</p>
<p>注：attach对象及取出该对象是 NIO 提供的一种操作，但该操作并非 Reactor 模式的必要操作，本文使用它，只是为了方便演示NIO的接口</p>
<p>具体的读请求处理在如下所示的 Processor 类中。该类中设置了一个静态的线程池处理所有请求。而 <em>process</em> 方法并不直接处理 I/O 请求，而是把该 I/O 操作提交给上述线程池去处理，这样就充分利用了多线程的优势，同时将对新连接的处理和读/写操作的处理放在了不同的线程中，读/写操作不再阻塞对新连接请求的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Processor.class);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">      <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        selectionKey.cancel();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125;\t Read ended&quot;</span>, socketChannel);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LOGGER.info(<span class="string">&quot;&#123;&#125;\t Read message &#123;&#125;&quot;</span>, socketChannel, <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多Reactor"><a href="#多Reactor" class="headerlink" title="多Reactor"></a>多Reactor</h3><p>Netty中使用的Reactor模式，引入了多Reactor，也即一个主Reactor负责监控所有的连接请求，多个子Reactor负责监控并处理读/写请求，减轻了主Reactor的压力，降低了主Reactor压力太大而造成的延迟</p>
<p>并且每个子Reactor分别属于一个独立的线程，每个成功连接后的Channel的所有操作由同一个线程处理，这样保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换，同时也方便了监控请求响应状态 </p>
<p><img src="http://www.jasongj.com/img/java/reactor/multi_reactor.png" alt="多Reactor"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> coreNum = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    Processor[] processors = <span class="keyword">new</span> Processor[coreNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; processors.length; i++) &#123;</span><br><span class="line">      processors[i] = <span class="keyword">new</span> Processor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      <span class="keyword">for</span> (SelectionKey key : keys) &#123;</span><br><span class="line">        keys.remove(key);</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">          SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">&quot;Accept request from &#123;&#125;&quot;</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          Processor processor = processors[(<span class="keyword">int</span>) ((index++) % coreNum)];</span><br><span class="line">          processor.addChannel(socketChannel);</span><br><span class="line">          processor.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，本文设置的子 Reactor 个数是当前机器可用核数的两倍（与 Netty 默认的子 Reactor 个数一致）</p>
<p>对于每个成功连接的 SocketChannel，通过 round robin 的方式交给不同的子 Reactor </p>
<p>子 Reactor 对 SocketChannel 的处理如下所示 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Processor.class);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService service =</span><br><span class="line">      Executors.newFixedThreadPool(<span class="number">2</span> * Runtime.getRuntime().availableProcessors());</span><br><span class="line">  <span class="keyword">private</span> Selector selector;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Processor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = SelectorProvider.provider().openSelector();</span><br><span class="line">    start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</span><br><span class="line">    socketChannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selector.select(<span class="number">500</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          SelectionKey key = iterator.next();</span><br><span class="line">          iterator.remove();</span><br><span class="line">          <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              socketChannel.close();</span><br><span class="line">              key.cancel();</span><br><span class="line">              LOGGER.info(<span class="string">&quot;&#123;&#125;\t Read ended&quot;</span>, socketChannel);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">              LOGGER.info(<span class="string">&quot;&#123;&#125;\t Message size is 0&quot;</span>, socketChannel);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              LOGGER.info(<span class="string">&quot;&#123;&#125;\t Read message &#123;&#125;&quot;</span>, socketChannel, <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Processor中，同样创建了一个静态的线程池，且线程池的大小为机器核数的两倍</p>
<p>每个Processor实例均包含一个Selector实例，同时每次获取Processor实例时均提交一个任务到该线程池，并且该任务正常情况下一直循环处理，不会停止</p>
<p>而提交给该Processor的SocketChannel通过在其Selector注册事件，加入到相应的任务中，由此实现了每个子Reactor包含一个Selector对象，并由一个独立的线程处理 </p>
<h1 id="I-O-调优"><a href="#I-O-调优" class="headerlink" title="I/O 调优"></a>I/O 调优</h1><h3 id="磁盘-I-O-优化"><a href="#磁盘-I-O-优化" class="headerlink" title="磁盘 I/O 优化"></a>磁盘 I/O 优化</h3><p>提升磁盘 I/O 性能通常的方法有：</p>
<ol>
<li>增加缓存，减少磁盘访问次数</li>
<li>优化磁盘的管理系统，设计最优的磁盘访问策略，以及磁盘的寻址策略，这里是在底层操作系统层面考虑的。</li>
<li>设计合理的磁盘存储数据块，以及访问这些数据块的策略，这里是在应用层面考虑的。如我们可以给存放的数据设计索引，通过寻址索引来加快和减少磁盘的访问，还有可以采用异步和非阻塞的方式加快磁盘的访问效率。</li>
<li>应用合理的 RAID 策略提升磁盘 IO，每种 RAID 的区别我们可以用下表所示：</li>
</ol>
<table>
<thead>
<tr>
<th><strong>磁盘阵列</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RAID 0</td>
<td>数据被平均写到多个磁盘阵列中，写数据和读数据都是并行的，所以磁盘的 IOPS 可以提高一倍。</td>
</tr>
<tr>
<td>RAID 1</td>
<td>RAID 1 的主要作用是能够提高数据的安全性，它将一份数据分别复制到多个磁盘阵列中。并不能提升 IOPS 但是相同的数据有多个备份。通常用于对数据安全性较高的场合中。</td>
</tr>
<tr>
<td>RAID 5</td>
<td>这中设计方式是前两种的折中方式，它将数据平均写到所有磁盘阵列总数减一的磁盘中，往另外一个磁盘中写入这份数据的奇偶校验信息。如果其中一个磁盘损坏，可以通过其它磁盘的数据和这个数据的奇偶校验信息来恢复这份数据。</td>
</tr>
<tr>
<td>RAID 0+1</td>
<td>如名字一样，就是根据数据的备份情况进行分组，一份数据同时写到多个备份磁盘分组中，同时多个分组也会并行读写。</td>
</tr>
</tbody></table>
<h3 id="网络-I-O-优化"><a href="#网络-I-O-优化" class="headerlink" title="网络 I/O 优化"></a>网络 I/O 优化</h3><p>网络 I/O 优化通常有一些基本处理原则：</p>
<ol>
<li>一个是减少网络交互的次数：要减少网络交互的次数通常我们在需要网络交互的两端会设置缓存，比如 Oracle 的 JDBC 驱动程序，就提供了对查询的 SQL 结果的缓存，在客户端和数据库端都有，可以有效的减少对数据库的访问</li>
<li>除了设置缓存还有一个办法是，合并访问请求：如在查询数据库时，我们要查 10 个 id，我可以每次查一个 id，也可以一次查 10 个 id。再比如在访问一个页面时通过会有多个 js 或 css 的文件，我们可以将多个 js 文件合并在一个 HTTP 链接中，每个文件用逗号隔开，然后发送到后端 Web 服务器根据这个 URL 链接，再拆分出各个文件，然后打包再一并发回给前端浏览器。这些都是常用的减少网络 I/O 的办法</li>
<li>减少网络传输数据量的大小：减少网络数据量的办法通常是将数据压缩后再传输，如 HTTP 请求中，通常 Web 服务器将请求的 Web 页面 gzip 压缩后在传输给浏览器。还有就是通过设计简单的协议，尽量通过读取协议头来获取有用的价值信息。比如在代理程序设计时，有 4 层代理和 7 层代理都是来尽量避免要读取整个通信数据来取得需要的信息。</li>
<li>尽量减少编码：通常在网络 I/O 中数据传输都是以字节形式的，也就是通常要序列化。但是我们发送要传输的数据都是字符形式的，从字符到字节必须编码。但是这个编码过程是比较耗时的，所以在要经过网络 I/O 传输时，尽量直接以字节形式发送。也就是尽量提前将字符转化为字节，或者减少字符到字节的转化过程</li>
<li>根据应用场景设计合适的交互方式：主要包括同步与异步阻塞与非阻塞方式</li>
</ol>
<hr>
<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html">深入分析 Java I/O 的工作机制</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">NIO 入门</a> </p>
<p><a target="_blank" rel="noopener" href="http://www.jasongj.com/java/nio_reactor">NIO Reactor I/O模型 | 技术世界</a> </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018-08-13-java-util-concurrent.html" rel="prev" title="java.util.concurrent">
      <i class="fa fa-chevron-left"></i> java.util.concurrent
    </a></div>
      <div class="post-nav-item">
    <a href="/2018-08-08-san-chong-bei-bao-wen-ti.html" rel="next" title="三种背包问题">
      三种背包问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-I-O-%E7%B1%BB%E5%BA%93%E6%A6%82%E5%86%B5"><span class="nav-number">1.</span> <span class="nav-text">Java I&#x2F;O 类库概况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BD%AC%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">字节与字符的转化接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InputStreamReader"><span class="nav-number">2.0.1.</span> <span class="nav-text">InputStreamReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutputStreamWriter"><span class="nav-number">2.0.2.</span> <span class="nav-text">OutputStreamWriter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A3%81%E7%9B%98-I-O-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">磁盘 I&#x2F;O 工作机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Socket-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">Java Socket 的工作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">4.0.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF-client"><span class="nav-number">4.0.2.</span> <span class="nav-text">建立通信链路 - client</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF-server"><span class="nav-number">4.0.3.</span> <span class="nav-text">建立通信链路 - server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">4.0.4.</span> <span class="nav-text">数据传输</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO"><span class="nav-number">5.</span> <span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#channel"><span class="nav-number">5.0.1.</span> <span class="nav-text">channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selector"><span class="nav-number">5.0.2.</span> <span class="nav-text">selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buffer"><span class="nav-number">5.0.3.</span> <span class="nav-text">buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buffer-%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">5.0.4.</span> <span class="nav-text">buffer 的状态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buffer-%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="nav-number">5.0.5.</span> <span class="nav-text">buffer 的访问方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%8C%BA%E5%88%86%E9%85%8D%E5%92%8C%E5%8C%85%E8%A3%85"><span class="nav-number">5.0.5.0.1.</span> <span class="nav-text">缓存区分配和包装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99"><span class="nav-number">5.0.5.0.2.</span> <span class="nav-text">读写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%8C%BA%E5%88%86%E7%89%87"><span class="nav-number">5.0.5.0.3.</span> <span class="nav-text">缓存区分片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">5.0.5.0.4.</span> <span class="nav-text">只读缓冲区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">5.0.6.</span> <span class="nav-text">零拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">6.</span> <span class="nav-text">同步、异步、阻塞、非阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="nav-number">6.0.1.</span> <span class="nav-text">同步与异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">6.0.2.</span> <span class="nav-text">阻塞与非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-number">6.0.3.</span> <span class="nav-text">两种的方式的组合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#server%E5%92%8C%E5%BC%82%E6%AD%A5IO"><span class="nav-number">7.</span> <span class="nav-text">server和异步IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#server-%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.0.1.</span> <span class="nav-text">server 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8-Reactor-%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.0.2.</span> <span class="nav-text">经典 Reactor 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.0.3.</span> <span class="nav-text">多工作线程Reactor模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9AReactor"><span class="nav-number">7.0.4.</span> <span class="nav-text">多Reactor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O-%E8%B0%83%E4%BC%98"><span class="nav-number">8.</span> <span class="nav-text">I&#x2F;O 调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98-I-O-%E4%BC%98%E5%8C%96"><span class="nav-number">8.0.1.</span> <span class="nav-text">磁盘 I&#x2F;O 优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C-I-O-%E4%BC%98%E5%8C%96"><span class="nav-number">8.0.2.</span> <span class="nav-text">网络 I&#x2F;O 优化</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hahahaha123567"
      src="/images/nicoumi.jpg">
  <p class="site-author-name" itemprop="name">hahahaha123567</p>
  <div class="site-description" itemprop="description">niconiconi</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hahahaha123567" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hahahaha123567" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/hahahaha1235678" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;hahahaha1235678" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://bangumi.tv/user/hahahaha123567" title="Bangumi → http:&#x2F;&#x2F;bangumi.tv&#x2F;user&#x2F;hahahaha123567" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bangumi</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/hahahaha123567" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hahahaha123567" rel="noopener" target="_blank"><i class=" fa-fw"></i>Zhihu</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://lovelive.ws/" title="https:&#x2F;&#x2F;lovelive.ws&#x2F;" rel="noopener" target="_blank">μ's</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hahahaha123567</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
