<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hahahaha123567.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="周志明的关于构建一个大规模但依然可靠的软件系统的架构讨论与代码实践">
<meta property="og:type" content="article">
<meta property="og:title" content="《凤凰架构》读书摘要">
<meta property="og:url" content="https://hahahaha123567.github.io/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="hahahaha123567">
<meta property="og:description" content="周志明的关于构建一个大规模但依然可靠的软件系统的架构讨论与代码实践">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-13T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-13T02:46:06.618Z">
<meta property="article:author" content="hahahaha123567">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hahahaha123567.github.io/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hahahaha123567.github.io/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html","path":"2022-01-14-《凤凰架构》读书笔记.html","title":"《凤凰架构》读书摘要"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《凤凰架构》读书摘要 | hahahaha123567</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="hahahaha123567" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">hahahaha123567</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-收藏"><a href="/favorite/" rel="section"><i class="fa fa-star fa-fw"></i>收藏</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8F%B2"><span class="nav-number">1.</span> <span class="nav-text">服务架构演进史</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E4%BB%A3"><span class="nav-number">1.1.</span> <span class="nav-text">原始分布式时代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F%E6%97%B6%E4%BB%A3"><span class="nav-number">1.2.</span> <span class="nav-text">单体系统时代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SOA%E6%97%B6%E4%BB%A3"><span class="nav-number">1.3.</span> <span class="nav-text">SOA时代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3"><span class="nav-number">1.4.</span> <span class="nav-text">微服务时代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3"><span class="nav-number">1.5.</span> <span class="nav-text">后微服务时代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3"><span class="nav-number">1.6.</span> <span class="nav-text">无服务时代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E8%A7%86%E8%A7%92"><span class="nav-number">2.</span> <span class="nav-text">架构师的视角</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.1.</span> <span class="nav-text">访问远程服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">远程服务调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">调用本地方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%9A%84%E5%85%AB%E5%AE%97%E7%BD%AA"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">分布式计算的八宗罪</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">RPC的三个基本问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">RPC的发展方向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#REST-%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC"><span class="nav-number">2.1.2.</span> <span class="nav-text">REST 设计风格</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#REST%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">REST六大原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#REST%E5%A5%BD%E5%A4%84"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">REST好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#REST%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">REST缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">事务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.2.1.</span> <span class="nav-text">本地事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">实现原子性和隔离性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">实现隔离性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVVC"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">MVVC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.2.2.</span> <span class="nav-text">全局事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2PC"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">2PC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3PC"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">3PC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.2.3.</span> <span class="nav-text">分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAP"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">CAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97-BASE"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">可靠事件队列 BASE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCC-%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">TCC 事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SAGA-%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">SAGA 事务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%8F%E6%98%8E%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.3.</span> <span class="nav-text">透明多级分流系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">2.4.</span> <span class="nav-text">架构安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81"><span class="nav-number">2.4.1.</span> <span class="nav-text">认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%88%E6%9D%83"><span class="nav-number">2.4.2.</span> <span class="nav-text">授权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%AD%E8%AF%81"><span class="nav-number">2.4.3.</span> <span class="nav-text">凭证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AF%86"><span class="nav-number">2.4.4.</span> <span class="nav-text">保密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93"><span class="nav-number">2.4.5.</span> <span class="nav-text">传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">2.4.6.</span> <span class="nav-text">验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="nav-number">3.</span> <span class="nav-text">分布式的基石</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">分布式共识算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Paxos"><span class="nav-number">3.1.1.</span> <span class="nav-text">Paxos</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multi-Paxos"><span class="nav-number">3.1.2.</span> <span class="nav-text">Multi Paxos</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gossip-%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.3.</span> <span class="nav-text">Gossip 协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E7%B1%BB%E5%BA%93%E5%88%B0%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.2.</span> <span class="nav-text">从类库到服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">服务发现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1"><span class="nav-number">3.2.2.</span> <span class="nav-text">网关路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">网络IO模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">3.2.3.</span> <span class="nav-text">客户端负载均衡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%B2%BB%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">流量治理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99"><span class="nav-number">3.3.1.</span> <span class="nav-text">服务容错</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">容错策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">容错设计模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">3.3.2.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E9%80%9A%E8%AE%AF"><span class="nav-number">3.3.3.</span> <span class="nav-text">可靠通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">可观测性</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="nav-number">4.</span> <span class="nav-text">不可变基础设施</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%B9%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">虚拟化容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes"><span class="nav-number">4.2.</span> <span class="nav-text">Kubernetes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%97%B4%E7%BD%91%E7%BB%9C"><span class="nav-number">4.3.</span> <span class="nav-text">容器间网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">4.3.1.</span> <span class="nav-text">Linux网络虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">网络通信模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B2%E9%A2%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">干预网络通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">虚拟化网络设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">4.3.1.4.</span> <span class="nav-text">容器间通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%94%9F%E6%80%81"><span class="nav-number">4.3.2.</span> <span class="nav-text">容器网络与生态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CNM-%E4%B8%8E-CNI"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">CNM 与 CNI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E7%94%9F%E6%80%81"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">网络插件生态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8"><span class="nav-number">4.4.</span> <span class="nav-text">持久化存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes-%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.4.1.</span> <span class="nav-text">Kubernetes 存储设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Mount-%E5%92%8C-Volume"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">Mount 和 Volume</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">静态存储分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="nav-number">4.4.1.3.</span> <span class="nav-text">动态存储分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E4%B8%8E%E7%94%9F%E6%80%81"><span class="nav-number">4.4.2.</span> <span class="nav-text">容器存储与生态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes-%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">Kubernetes 存储架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FlexVolume-%E4%B8%8E-CSI"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">FlexVolume 与 CSI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E-In-Tree-%E5%88%B0-Out-of-Tree"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">从 In-Tree 到 Out-of-Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%8F%92%E4%BB%B6%E7%94%9F%E6%80%81"><span class="nav-number">4.4.2.4.</span> <span class="nav-text">容器插件生态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E4%B8%8E%E8%B0%83%E5%BA%A6"><span class="nav-number">4.5.</span> <span class="nav-text">资源与调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.5.1.</span> <span class="nav-text">资源模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">4.5.2.</span> <span class="nav-text">服务质量与优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E9%80%90%E6%9C%BA%E5%88%B6"><span class="nav-number">4.5.3.</span> <span class="nav-text">驱逐机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">4.5.4.</span> <span class="nav-text">默认调度器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC"><span class="nav-number">4.6.</span> <span class="nav-text">服务网格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%8F%E6%98%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E6%B6%85%E6%A7%83"><span class="nav-number">4.6.1.</span> <span class="nav-text">透明通信的涅槃</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E7%9A%84%E6%88%90%E6%9C%AC"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">通信的成本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="nav-number">4.6.1.2.</span> <span class="nav-text">数据平面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="nav-number">4.6.1.3.</span> <span class="nav-text">控制平面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E4%B8%8E%E7%94%9F%E6%80%81"><span class="nav-number">4.6.2.</span> <span class="nav-text">服务网格与生态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.6.2.1.</span> <span class="nav-text">服务网格接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2-API"><span class="nav-number">4.6.2.2.</span> <span class="nav-text">通用数据平面 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E7%94%9F%E6%80%81"><span class="nav-number">4.6.2.3.</span> <span class="nav-text">服务网格生态</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E6%96%B9%E6%B3%95%E8%AE%BA"><span class="nav-number">5.</span> <span class="nav-text">技术方法论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="nav-number">5.1.</span> <span class="nav-text">微服务</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hahahaha123567</p>
  <div class="site-description" itemprop="description">niconiconi</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hahahaha123567" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hahahaha123567" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://bangumi.tv/user/hahahaha123567" title="Bangumi → http:&#x2F;&#x2F;bangumi.tv&#x2F;user&#x2F;hahahaha123567" rel="noopener me" target="_blank">Bangumi</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://lovelive.ws/" title="https:&#x2F;&#x2F;lovelive.ws&#x2F;" rel="noopener" target="_blank">μ's</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《凤凰架构》读书摘要 | hahahaha123567">
      <meta itemprop="description" content="周志明的关于构建一个大规模但依然可靠的软件系统的架构讨论与代码实践">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《凤凰架构》读书摘要
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-14T00:00:00+08:00">2022-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-13 10:46:06" itemprop="dateModified" datetime="2022-05-13T10:46:06+08:00">2022-05-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

            <div class="post-description">周志明的关于构建一个大规模但依然可靠的软件系统的架构讨论与代码实践</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="http://icyfenix.cn/summary/">原文链接</a></p>
<h1 id="服务架构演进史"><a href="#服务架构演进史" class="headerlink" title="服务架构演进史"></a>服务架构演进史</h1><h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><blockquote>
<p>UNIX 的分布式设计哲学 保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要</p>
</blockquote>
<p>在 20 世纪 70 年代末期到 80 年代初，计算机科学刚经历了从以大型机为主向以微型机为主的蜕变，当时计算机硬件局促的运算处理能力，已直接妨碍到了在单台计算机上信息系统软件能够达到的最大规模</p>
<p>某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果</p>
<p>20 世纪 80 年代正是摩尔定律开始稳定发挥作用的黄金时期，信息系统进入了以单台或少量几台计算机即可作为服务器来支撑大型信息系统运作的单体时代</p>
<h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><blockquote>
<p>单体架构（Monolithic） “单体”只是表明系统中主要的过程调用都是进程内调用，不会发生进程间通信，仅此而已</p>
</blockquote>
<p>对于小型系统——即由单台机器就足以支撑其良好运行的系统，单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信（Inter-Process Communication，IPC），因此也是运行效率最高的一种架构风格</p>
<p><strong>优点</strong></p>
<ul>
<li><p>易于开发、易于测试、易于部署</p>
</li>
<li><p>由于所有代码都运行在同一个进程空间之内，所有模块、方法的调用都无须考虑网络分区、对象复制这些麻烦的事和性能损失</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>如果任何一部分代码出现了缺陷，过度消耗了进程空间内的资源，所造成的影响也是全局性的、难以隔离的。譬如内存泄漏、线程爆炸、阻塞、死循环等问题，都将会影响整个程序，而不仅仅是影响某一个功能、模块本身的正常运作。如果消耗的是某些更高层次的公共资源，譬如端口号或者数据库连接池泄漏，影响还将会波及整台机器，甚至是集群中其他单体副本的正常工作</p>
</li>
<li><p>由于所有代码都共享着同一个进程空间，不能隔离，也就无法（其实还是有办法的，譬如使用 OSGi 这种运行时模块化框架，但是很别扭、很复杂）做到单独停止、更新、升级某一部分代码，所以从可维护性来说，单体系统也是不占优势的</p>
</li>
<li><p>难以技术异构，每个模块的代码都通常需要使用一样的程序语言，乃至一样的编程框架去开发。单体系统的技术栈异构并非一定做不到，譬如 JNI 就可以让 Java 混用 C 或 C++，但这通常是迫不得已的，并不是优雅的选择</p>
</li>
<li><p>单体系统很难兼容“Phoenix”的特性。这种架构风格潜在的观念是希望系统的每一个部件，每一处代码都尽量可靠，靠不出或少出缺陷来构建可靠系统。然而战术层面再优秀，也很难弥补战略层面的不足，单体靠高质量来保证高可靠性的思路，在小规模软件上还能运作良好，但系统规模越大，交付一个可靠的单体系统就变得越来越具有挑战性</p>
</li>
</ul>
<h2 id="SOA时代"><a href="#SOA时代" class="headerlink" title="SOA时代"></a>SOA时代</h2><blockquote>
<p>SOA 架构（Service-Oriented Architecture） 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式</p>
</blockquote>
<ol>
<li>烟囱式架构, 完全不与其他相关信息系统进行互操作或者协调工作的设计模式</li>
<li>微内核架构（Microkernel Architecture）：也被称为插件式架构（Plug-in Architecture）将主数据，连同其他可能被各子系统使用到的公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心（Kernel），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样可提供可扩展的、灵活的、天然隔离的功能特性</li>
<li>事件驱动架构（Event-Driven Architecture）：在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去，如此，每一个消息的处理者都是独立的，高度解耦的，但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动</li>
</ol>
<ul>
<li>领导制定技术标准的组织 Open CSA</li>
<li>明确了采用 SOAP 作为远程调用的协议，依靠 SOAP 协议族（WSDL、UDDI 和一大票 WS-*协议）来完成服务的发布、发现和治理</li>
<li>利用一个被称为企业服务总线（的消息管道来实现各个子系统之间的通信交互</li>
<li>使用服务数据对象来访问和表示数据</li>
<li>使用服务组件架构来定义服务封装的形式和服务运行的容器</li>
</ul>
<p><strong>缺点</strong></p>
<p>过于严格的规范定义带来过度的复杂性。而构建在 SOAP 基础之上的 ESB、BPM、SCA、SDO 等诸多上层建筑，进一步加剧了这种复杂性</p>
<h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><blockquote>
<p>微服务架构（Microservices）<br>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</p>
</blockquote>
<p>微服务追求的是更加自由的架构风格，摒弃了几乎所有 SOA 里可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”</p>
<h2 id="后微服务时代"><a href="#后微服务时代" class="headerlink" title="后微服务时代"></a>后微服务时代</h2><blockquote>
<p>后微服务时代（Cloud Native）<br>从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”</p>
</blockquote>
<p>以 Docker Swarm、Apache Mesos 与 Kubernetes 为主要竞争者的“容器编排战争”终于有了明确的结果，Kubernetes 登基加冕是容器发展中一个时代的终章，也将是软件架构发展下一个纪元的开端</p>
<p>传统 Spring Cloud 与 Kubernetes 提供的解决方案对比</p>
<table>
<thead>
<tr>
<th>Kubernetes</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>弹性伸缩</td>
<td>Autoscaling N&#x2F;A</td>
</tr>
<tr>
<td>服务发现</td>
<td>KubeDNS, CoreDNS Spring Cloud Eureka</td>
</tr>
<tr>
<td>配置中心</td>
<td>ConfigMap, Secret Spring Cloud Config</td>
</tr>
<tr>
<td>服务网关</td>
<td>Ingress Controller Spring Cloud Zuul</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Load Balancer Spring Cloud Ribbon</td>
</tr>
<tr>
<td>服务安全</td>
<td>RBAC API Spring Cloud Security</td>
</tr>
<tr>
<td>跟踪监控</td>
<td>Metrics API, Dashboard Spring Cloud Turbine</td>
</tr>
<tr>
<td>降级熔断</td>
<td>N&#x2F;A Spring Cloud Hystrix</td>
</tr>
</tbody></table>
<p>仅从功能上看，单纯的 Kubernetes 反而不如之前的 Spring Cloud 方案。这是因为有一些问题处于应用系统与基础设施的边缘，使得完全在基础设施层面中确实很难精细化地处理。通过 Spring Cloud 这类应用代码实现的微服务中并不难处理，既然是使用程序代码来解决问题，只要合乎逻辑，想要实现什么功能，只受限于开发人员的想象力与技术能力，但基础设施是针对整个容器来管理的，粒度相对粗旷，只能到容器层面，对单个远程服务就很难有效管控</p>
<p>为了解决这一类问题，虚拟化的基础设施很快完成了第二次进化，引入了今天被称为“服务网格”（Service Mesh）的“边车代理模式”（Sidecar Proxy）</p>
<p>由系统自动在服务容器（通常是指 Kubernetes 的 Pod）中注入一个通信代理服务器，以类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理</p>
<h2 id="无服务时代"><a href="#无服务时代" class="headerlink" title="无服务时代"></a>无服务时代</h2><blockquote>
<p>无服务架构（Serverless）如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布式”的云端系统这条路的起点</p>
</blockquote>
<p>只涉及两块内容：后端设施（Backend）和函数（Function）</p>
<ul>
<li>后端设施是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，无服务中称其为“后端即服务”（Backend as a Service，BaaS）</li>
<li>函数是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，不必考虑容量规划（从技术角度可以不考虑，从计费的角度你的钱包够不够用还是要掂量一下的），无服务中称其为“函数即服务”（Function as a Service，FaaS）</li>
</ul>
<p>无服务架构对一些适合的应用确实能够降低开发和运维环节的成本，譬如不需要交互的离线大规模计算，又譬如多数 Web 资讯类网站、小程序、公共 API 服务、移动应用服务端等都契合于无服务架构所擅长的短链接、无状态、适合事件驱动的交互形式；但另一方面，对于那些信息管理系统、网络游戏等应用，又或者说所有具有业务逻辑复杂，依赖服务端状态，响应速度要求较高，需要长链接等这些特征的应用，至少目前是相对并不适合的</p>
<p>顺序上笔者将“无服务”安排到了“微服务”和“云原生”时代之后，但它们两者并没有继承替代关系，笔者相信软件开发的未来不会只存在某一种“最先进的”架构风格，多种具针对性的架构风格同时并存，是软件产业更有生命力的形态</p>
<h1 id="架构师的视角"><a href="#架构师的视角" class="headerlink" title="架构师的视角"></a>架构师的视角</h1><h2 id="访问远程服务"><a href="#访问远程服务" class="headerlink" title="访问远程服务"></a>访问远程服务</h2><h3 id="远程服务调用"><a href="#远程服务调用" class="headerlink" title="远程服务调用"></a>远程服务调用</h3><h4 id="调用本地方法"><a href="#调用本地方法" class="headerlink" title="调用本地方法"></a>调用本地方法</h4><ol>
<li>传递方法参数</li>
<li>确定方法版本</li>
<li>执行被调方法</li>
<li>返回执行结果</li>
</ol>
<p>1&#x2F;4依赖栈内存, 2依赖程序语言定义</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ol>
<li>管道, 在进程间传递少量的字符流或字节流</li>
<li>信号, 通知目标进程有某种事件发生, kill即shell向进程发送信号</li>
<li>信号量, wait() notify()</li>
<li>共享内存</li>
<li>Socket, 支持远程</li>
</ol>
<h4 id="分布式计算的八宗罪"><a href="#分布式计算的八宗罪" class="headerlink" title="分布式计算的八宗罪"></a>分布式计算的八宗罪</h4><ol>
<li>The network is reliable —— 网络是可靠的</li>
<li>Latency is zero —— 延迟是不存在的</li>
<li>Bandwidth is infinite —— 带宽是无限的</li>
<li>The network is secure —— 网络是安全的</li>
<li>Topology doesn’t change —— 拓扑结构是一成不变的</li>
<li>There is one administrator —— 总会有一个管理员</li>
<li>Transport cost is zero —— 不必考虑传输成本</li>
<li>The network is homogeneous —— 网络是同质化的</li>
</ol>
<h4 id="RPC的三个基本问题"><a href="#RPC的三个基本问题" class="headerlink" title="RPC的三个基本问题"></a>RPC的三个基本问题</h4><ol>
<li>如何表示数据, 各种协议</li>
<li>如何传递数据, 除了传输层的UDP&#x2F;TCP, 还包括应用层的wire protocal, 异常、超时、安全、认证、授权、事务等</li>
<li>如何确定方法</li>
</ol>
<h4 id="RPC的发展方向"><a href="#RPC的发展方向" class="headerlink" title="RPC的发展方向"></a>RPC的发展方向</h4><ol>
<li>面向对象, 不满足于 RPC 将面向过程的编码方式带到分布式，希望在分布式系统中也能够进行跨进程的面向对象编程，代表为 RMI、.NET Remoting</li>
<li>性能, 代表为 gRPC 和 Thrift, 决定 RPC 性能的主要就两个因素：序列化效率和信息密度。序列化效率很好理解，序列化输出结果的容量越小，速度越快，效率自然越高；信息密度则取决于协议中有效荷载（Payload）所占总传输数据的比例大小，使用传输协议的层次越高，信息密度就越低，SOAP 使用 XML 拙劣的性能表现就是前车之鉴。gRPC 和 Thrift 都有自己优秀的专有序列化器，而传输协议方面，gRPC 是基于 HTTP&#x2F;2 的，支持多路复用和 Header 压缩，Thrift 则直接基于传输层的 TCP 协议来实现，省去了额外应用层协议的开销</li>
<li>简化, 代表为 JSON-RPC</li>
</ol>
<h3 id="REST-设计风格"><a href="#REST-设计风格" class="headerlink" title="REST 设计风格"></a>REST 设计风格</h3><p>表征状态转移</p>
<ul>
<li>面向过程编程时，为什么要以算法和处理过程为中心，输入数据，输出结果？是为了符合计算机世界中主流的交互方式</li>
<li>面向对象编程时，为什么要将数据和行为统一起来、封装成对象？是为了符合现实世界的主流的交互方式</li>
<li>面向资源编程时，为什么要将数据（资源）作为抽象的主体，把行为看作是统一的接口？是为了符合网络世界的主流的交互方式</li>
</ul>
<h4 id="REST六大原则"><a href="#REST六大原则" class="headerlink" title="REST六大原则"></a>REST六大原则</h4><ul>
<li>服务端与客户端分离</li>
<li>无状态</li>
<li>可缓存</li>
<li>分层系统</li>
<li>统一接口</li>
<li>按需代码</li>
</ul>
<h4 id="REST好处"><a href="#REST好处" class="headerlink" title="REST好处"></a>REST好处</h4><ol>
<li>降低的服务接口的学习成本</li>
<li>资源天然具有集合与层次结构</li>
<li>REST 绑定于 HTTP 协议</li>
</ol>
<h4 id="REST缺点"><a href="#REST缺点" class="headerlink" title="REST缺点"></a>REST缺点</h4><ol>
<li>REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中</li>
<li>REST 没有传输可靠性支持</li>
<li>REST 缺乏对资源进行“部分”和“批量”的处理能力</li>
</ol>
<p>一种理论上较优秀的可以解决以上这几类问题的方案是GraphQL，这是由 Facebook 提出并开源的一种面向资源 API 的数据查询语言。比起依赖 HTTP 无协议的 REST，GraphQL 可以说是另一种“有协议”的、更彻底地面向资源的服务方式。然而凡事都有两面，离开了 HTTP，它又面临着几乎所有 RPC 框架所遇到的那个如何推广交互接口的问题。</p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul>
<li>一致性（Consistency）系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾</li>
<li>原子性（Atomic）在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销</li>
<li>隔离性（Isolation）在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响</li>
<li>持久性（Durability）事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据</li>
</ul>
<p>A、I、D 是手段，C 是目的</p>
<p>当一个服务只使用一个数据源时，通过 A、I、D 来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为__内部一致性__</p>
<p>当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，问题就变得相对困难了许多。此时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为__外部一致性__</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>直接依赖于数据源本身提供的事务能力来工作的，在程序代码层面，最多只能对事务接口做一层标准化的包装（如 JDBC 接口），与后续介绍的 XA、TCC、SAGA 等主要靠应用程序代码来实现的事务有着十分明显的区别</p>
<h4 id="实现原子性和隔离性"><a href="#实现原子性和隔离性" class="headerlink" title="实现原子性和隔离性"></a>实现原子性和隔离性</h4><p>写入中间状态与崩溃都不可能消除，所以如果不做额外保障措施的话，将内存中的数据写入磁盘，并不能保证原子性与持久性</p>
<p>使用 <strong>Commit Logging</strong> 实现</p>
<p>Commit Logging基于ARIES理论</p>
<p>将修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等，以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化</p>
<p>Write-Ahead Logging, 当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除</p>
<h4 id="实现隔离性"><a href="#实现隔离性" class="headerlink" title="实现隔离性"></a>实现隔离性</h4><p>现代数据库均提供了以下三种锁</p>
<ul>
<li>写锁（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）</li>
<li>读锁（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）</li>
<li>范围锁（Range Lock）, 在MySQL中实现为gap lock</li>
</ul>
<p>四个隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>使用的锁</th>
<th>存在问题</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交(Read Uncommitted)</td>
<td>写锁持续至事务结束,无读锁</td>
<td>脏读:在事务执行过程中,一个事务读取到了另一个事务未提交的数据(读数据不需要加读锁,写锁就限制不了读操作了)</td>
</tr>
<tr>
<td>读已提交(Read Committed)</td>
<td>写锁持续至事务结束,读锁在操作完成后马上释放</td>
<td>不可重复读:在事务执行过程中,对同一行数据的两次查询得到了不同的结果,即读到了另一个事务已提交的数据(写锁释放太早,限制不到其他事务加读锁)</td>
</tr>
<tr>
<td>可重复读(Repeatable Read)</td>
<td>写锁、读锁持续至事务结束</td>
<td>幻读:在事务执行过程中,两个完全相同的范围查询得到了不同的结果集,没有范围锁来禁止在该范围内插入新的数据</td>
</tr>
<tr>
<td>可串行化(Serializable)</td>
<td>写锁、读锁、范围所持续至事务结束</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h4><p>幻读、不可重复读、脏读等问题都是由于一个事务在读数据过程中，受另外一个写数据的事务影响而破坏了隔离性，针对这种“一个事务读+另一个事务写”的隔离问题，近年来有一种名为“多版本并发控制”（Multi-Version Concurrency Control，MVCC）的无锁优化方案被主流的商业数据库广泛采用。MVCC 是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的</p>
<h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><p>单个服务使用多个数据源场景</p>
<p>X&#x2F;Open组织（后来并入了The Open Group）提出了一套名为X&#x2F;Open XA（XA 是 eXtended Architecture 的缩写）的处理事务架构，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口</p>
<p>Java 中专门定义了JSR 907 Java Transaction API，基于 XA 模式在 Java 语言中的实现了全局事务处理的标准，这也就是我们现在所熟知的 JTA。JTA 最主要的两个接口是：</p>
<ol>
<li>事务管理器的接口：javax.transaction.TransactionManager。这套接口是给 Java EE 服务器提供容器事务（由容器自动负责事务管理）使用的，还提供了另外一套javax.transaction.UserTransaction接口，用于通过程序代码手动开启、提交和回滚事务。</li>
<li>满足 XA 规范的资源定义接口：javax.transaction.xa.XAResource，任何资源（JDBC、JMS 等等）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可</li>
</ol>
<h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>XA 将事务提交拆分成为两阶段过程，“两段式提交”（2 Phase Commit，2PC）协议，协调者、参与者都是可以由数据库自己来扮演的，不需要应用程序介入。协调者一般是在参与者之间选举产生的，而应用程序相对于数据库来说只扮演客户端的角色</p>
<ol>
<li><p>准备阶段：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态</p>
</li>
<li><p>提交阶段：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作</p>
</li>
</ol>
<p>2PC的前提条件: </p>
<ol>
<li><p>必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息</p>
</li>
<li><p>必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态，当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，并向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作</p>
</li>
</ol>
<p>2PC的缺点:</p>
<ol>
<li><p>单点问题：协调者</p>
</li>
<li><p>性能问题：要经过两次远程服务调用，三次数据持久化</p>
</li>
<li><p>一致性风险：需要前提条件</p>
</li>
</ol>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ol>
<li>canCommit，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成</li>
<li>preCommit</li>
<li>doCommit，未收到协调者返回，参与者默认的操作策略将是提交事务</li>
</ol>
<p>将2PC的prepare阶段分成两部分，增加了评估阶段，在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的，但在事务能够正常提交的场景中，两者的性能都依然很差，甚至三段式因为多了一次询问，还要稍微更差一些</p>
<p>缺点：单点问题、性能问题优于2PC，一致性风险大于2PC</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>多个服务同时访问多个数据源</p>
<h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>一个分布式的系统中，涉及共享数据问题时，以下三个特性最多只能同时满足其中两个：</p>
<ol>
<li><p>一致性（Consistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的</p>
</li>
<li><p>可用性（Availability）：代表系统不间断地提供服务的能力，可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A&#x3D;MTBF&#x2F;（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999%可用，即代表平均年故障修复时间为 32 秒</p>
</li>
<li><p>分区容忍性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力</p>
</li>
</ol>
<p>CAP舍弃其中一个:</p>
<ol>
<li><p>CA，不追求分区容忍性即认为节点之间通信永远可靠，不是分布式系统</p>
</li>
<li><p>CP，网络分区后服务不可用，退化为全局事务，使用2PC&#x2F;3PC，用于对数据要求很高的系统，HBase</p>
</li>
<li><p>AP，网络分区后服务可用但不同实例返回的数据可能不同，大部分nosql系统和分布式缓存</p>
</li>
</ol>
<h4 id="可靠事件队列-BASE"><a href="#可靠事件队列-BASE" class="headerlink" title="可靠事件队列 BASE"></a>可靠事件队列 BASE</h4><h4 id="TCC-事务"><a href="#TCC-事务" class="headerlink" title="TCC 事务"></a>TCC 事务</h4><h4 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h4><h2 id="透明多级分流系统"><a href="#透明多级分流系统" class="headerlink" title="透明多级分流系统"></a>透明多级分流系统</h2><p>系统中不同的组件:</p>
<ul>
<li>有一些部件位于客户端或网络的边缘，能够迅速响应用户的请求，避免给后方的 I&#x2F;O 与 CPU 带来压力，典型如本地缓存、内容分发网络、反向代理等。</li>
<li>有一些部件的处理能力能够线性拓展，易于伸缩，可以使用较小的代价堆叠机器来获得与用户数量相匹配的并发性能，应尽量作为业务逻辑的主要载体，典型如集群中能够自动扩缩的服务节点。</li>
<li>有一些部件稳定服务对系统运行有全局性的影响，要时刻保持着容错备份，维护着高可用性，典型如服务注册中心、配置中心。</li>
<li>有一些设施是天生的单点部件，只能依靠升级机器本身的网络、存储和运算性能来提升处理能力，如位于系统入口的路由、网关或者负载均衡器（它们都可以做集群，但一次网络请求中无可避免至少有一个是单点的部件）、位于请求调用链末端的传统关系数据库等</li>
</ul>
<p>两条原则:</p>
<ol>
<li><p>尽可能减少单点部件</p>
</li>
<li><p>奥卡姆剃刀原则</p>
</li>
</ol>
<p>几种优化:</p>
<ul>
<li>客户端缓存</li>
<li>域名解析</li>
<li>传输链路</li>
<li>内容分发网络</li>
<li>负载均衡</li>
<li><a target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cache-middleware.html">服务端缓存</a>, 介绍了传统意义上缓存的各个方面</li>
</ul>
<h2 id="架构安全性"><a href="#架构安全性" class="headerlink" title="架构安全性"></a>架构安全性</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><ul>
<li>RBAC, user&#x2F;role&#x2F;authority&#x2F;permission&#x2F;resource</li>
<li>OAuth2, 解决第三方应用的认证授权协议</li>
</ul>
<h3 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h3><ul>
<li>Cookie-Session, 受制于CAP理论</li>
<li>JWT, header+payload+sign</li>
</ul>
<h3 id="保密"><a href="#保密" class="headerlink" title="保密"></a>保密</h3><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h1 id="分布式的基石"><a href="#分布式的基石" class="headerlink" title="分布式的基石"></a>分布式的基石</h1><h2 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>Multi Paxos 对 Basic Paxos 的核心改进是增加了“选主”的过程</p>
<p>Raft 算法: 分布式系统中如何对某个值达成一致</p>
<ol>
<li>如何选主（Leader Election）</li>
<li>如何把数据复制到各个节点上（Entity Replication）</li>
<li>如何保证过程是安全的（Safety）</li>
</ol>
<p>Raft 是 Etcd、LogCabin、Consul 等重要分布式程序的实现基础, ZooKeeper 的 ZAB 算法与 Raft 的思路也非常类似，这些算法都被认为是 Multi Paxos 的等价派生实现。</p>
<h3 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h3><ul>
<li>强一致性, 尽管系统内部节点可以存在不一致的状态，但从系统外部看来不一致的情况并不会被观察到，所以整体上看系统是强一致性的, Paxos、Raft、ZAB</li>
<li>最终一致性, 系统中不一致的状态有可能会在一定时间内被外部直接观察到, DNS, Gossip</li>
</ul>
<h2 id="从类库到服务"><a href="#从类库到服务" class="headerlink" title="从类库到服务"></a>从类库到服务</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>实现</p>
<ol>
<li>全限定名(定位到主机)</li>
<li>端口号(tcp&#x2F;udp服务)</li>
<li>服务标识(具体接口)</li>
</ol>
<p>功能</p>
<ol>
<li>服务注册</li>
<li>服务维护</li>
<li>服务发现</li>
</ol>
<p>服务注册中心一旦崩溃，整个系统都不再可用，因此必须尽最大努力保证服务发现的可用性</p>
<p>CAP矛盾</p>
<ul>
<li>Eureka，AP，客户端拿到了已经发生变动的错误地址依赖故障转移（Failover）或者快速失败（Failfast）</li>
<li>Consul，CP</li>
</ul>
<p>选择AP&#x2F;CP</p>
<blockquote>
<p>假设系统形成了 A、B 两个网络分区后，A 区的服务只能从区域内的服务发现节点获取到 A 区的服务坐标，B 区的服务只能取到在 B 区的服务坐标，这对你的系统会有什么影响？</p>
</blockquote>
<ul>
<li>没有影响，AP</li>
<li>影响非常之大，甚至可能带来比整个系统宕机更坏的结果，CP</li>
</ul>
<p>实现方式</p>
<ul>
<li>在分布式 K&#x2F;V 存储框架上自己开发, ZooKeeper(CP), Etcd(CP), Redis(AP)</li>
<li>以基础设施（主要是指 DNS 服务器）来实现服务发现, SkyDNS、CoreDNS, AP&#x2F;CP取决于怎样实现</li>
<li>专门用于服务发现的框架和工具, Eureka(AP)、Consul(CP) 和 Nacos(AP&#x2F;CP)</li>
</ul>
<h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><p>网关 &#x3D; 路由器（基础职能） + 过滤器（可选职能）</p>
<p>网关是网络访问中的单点, 地址具有唯一性不能像服务中心一样做集群</p>
<h4 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h4><p>[以买饭为例]</p>
<ul>
<li>同步IO(Synchronous I&#x2F;O)<ul>
<li>阻塞IO(Blocking I&#x2F;O), 节省 CPU 资源(Java传统IO模型)</li>
<li>非阻塞IO(Non-Blocking I&#x2F;O), 浪费 CPU 资源(Java的NIO)</li>
<li>多路复用IO(Multiplexing I&#x2F;O), 主流(通过NIO实现的Reactor模式)</li>
<li>信号驱动IO(Signal-Driven I&#x2F;O), 需要自己从缓冲区获取数据</li>
</ul>
</li>
<li>异步IO(Asynchronous I&#x2F;O)(通过AIO实现的Proactor模式)</li>
</ul>
<h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p>请求的完整路径</p>
<ol>
<li>服务发现</li>
<li>网关路由</li>
<li>负载均衡</li>
<li>服务容错</li>
</ol>
<p>客户端指集群内部发起服务的进程</p>
<ul>
<li>Java, Netflix Ribbon, Spring Cloud Load Balancer</li>
<li>其他, 代理均衡器</li>
</ul>
<h2 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h2><p>服务降级</p>
<ul>
<li>出错后弥补</li>
<li>主动降级</li>
</ul>
<h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><p>失败如何弥补</p>
<ul>
<li>故障转移, 重试, 服务具备幂等性, 如果调用的服务器出现故障, 自动切换到其他副本</li>
<li>快速失败, 非幂等的服务, 拒绝重试, 抛出异常</li>
<li>安全失败, 不影响核心业务的旁路逻辑失败的话返回默认值</li>
<li>沉默失败, 当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响</li>
<li>故障恢复, 异步的故障转移<br>调用之前尽量获得最大的成功概率</li>
<li>并行调用, 同时调用多个副本, 返回一个成功即可</li>
<li>广播调用, 同时调用多个副本, 必须全部返回成功, 刷新分布式缓存</li>
</ul>
<table>
<thead>
<tr>
<th>容错策略</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>故障转移</td>
<td>系统自动处理，调用者对失败的信息不可见</td>
<td>增加调用时间，额外的资源开销</td>
<td>调用幂等服务, 对调用时间不敏感的场景</td>
</tr>
<tr>
<td>快速失败</td>
<td>调用者有对失败的处理完全控制权, 不依赖服务的幂等性</td>
<td>调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩</td>
<td>调用非幂等的服务, 超时阈值较低的场景</td>
</tr>
<tr>
<td>安全失败</td>
<td>不影响主路逻辑</td>
<td>只适用于旁路调用</td>
<td>调用链中的旁路服务</td>
</tr>
<tr>
<td>静默失败</td>
<td>控制错误不影响全局</td>
<td>出错的地方将在一段时间内不可用</td>
<td>频繁超时的服务</td>
</tr>
<tr>
<td>故障恢复</td>
<td>调用失败后自动重试，也不影响主路逻辑</td>
<td>重试任务可能产生堆积，重试仍然可能失败</td>
<td>调用链中的旁路服务, 对实时性要求不高的主路逻辑也可以使用</td>
</tr>
<tr>
<td>并行调用</td>
<td>尽可能在最短时间内获得最高的成功率</td>
<td>额外消耗机器资源，大部分调用可能都是无用功</td>
<td>资源充足且对失败容忍度低的场景</td>
</tr>
<tr>
<td>广播调用</td>
<td>支持同时对批量的服务提供者发起调用</td>
<td>资源消耗大，失败概率高</td>
<td>只适用于批量操作的场景</td>
</tr>
</tbody></table>
<h4 id="容错设计模式"><a href="#容错设计模式" class="headerlink" title="容错设计模式"></a>容错设计模式</h4><ul>
<li>断路器模式, 快速失败</li>
<li>舱壁隔离模式, 静默失败<ul>
<li>局部的线程池来控制服务, 缺点增加了 CPU 的开销, 增加请求延时</li>
<li>信号量机制, 为每个远程服务维护一个线程安全的计数器</li>
</ul>
</li>
<li>重试模式, 故障转移, 故障恢复<ul>
<li>仅在主路逻辑的关键服务上进行同步的重试, 尤其不该进行同步重试</li>
<li>仅对由瞬时故障导致的失败进行重试, 例如用http状态码来判断</li>
<li>仅对具备幂等性的服务进行重试</li>
<li>重试必须有明确的终止条件<ul>
<li>超时</li>
<li>次数限制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量统计指标</p>
<ul>
<li>TPS</li>
<li>HPS</li>
<li>QPS</li>
<li>流量, 登录用户数等</li>
</ul>
<p>限流设计模式</p>
<ul>
<li>流量计数器, 针对时间点进行离散的统计</li>
<li>滑动时间窗, 只适用于否决式限流，超过阈值的流量就必须强制失败或降级，很难进行阻塞等待处理</li>
<li>漏桶, 首先在缓冲区中暂存，然后再在控制算法的调节下均匀地发送这些被缓冲的报文, 不支持支持变动请求处理速率</li>
<li>令牌桶, 请求获取令牌</li>
</ul>
<p>分布式限流</p>
<ul>
<li>单机限流模式+各主机共享信息, 网络开销大</li>
<li>单机限流模式+本地缓存部分信息, 网络开销小, 不准确</li>
</ul>
<h3 id="可靠通讯"><a href="#可靠通讯" class="headerlink" title="可靠通讯"></a>可靠通讯</h3><p>基于边界的安全模型: 把网络划分为不同的区域，不同的区域对应于不同风险级别和允许访问的网络资源权限，将安全防护措施集中部署在各个区域的边界之上，重点关注跨区域的网络流量<br>零信任安全模型: 除非明确得到了能代表请求来源的身份凭证，否则一律不会有默认的信任关系</p>
<h4 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h4><ul>
<li>日志, Elasticsearch, Logstash(Fluentd), Kibana</li>
<li>追踪</li>
<li>度量, Java的JMX(单机), Kubernetes的Prometheus, Zabbix</li>
</ul>
<h1 id="不可变基础设施"><a href="#不可变基础设施" class="headerlink" title="不可变基础设施"></a>不可变基础设施</h1><p>云原生: 微服务, 容器网格, 不可变基础设施, 声明式API</p>
<p>软件兼容性</p>
<ul>
<li>ISA兼容: 机器指令集, x86&#x2F;ARM</li>
<li>ABI兼容: 操作系统或二进制库, Windows&#x2F;Linux, DirectX9&#x2F;DirectX12</li>
<li>环境兼容: 配置文件等</li>
</ul>
<p>虚拟化技术</p>
<ul>
<li>指令集虚拟化, 软件模拟指令集</li>
<li>硬件抽象层虚拟化, 以软件或者直接通过硬件来模拟处理器、芯片组、内存、磁盘控制器、显卡等设备, 虚拟机, VMware ESXi和Hyper-V</li>
<li>操作系统层虚拟化, 容器化, 只能提供操作系统内核以上的部分 ABI 兼容性与完整的环境兼容性</li>
<li>运行库虚拟化, 以一个独立进程来代替操作系统内核来提供目标软件运行所需的全部能力, WINE, WSL1</li>
<li>语言层虚拟化, 由虚拟机将高级语言生成的中间代码转换为目标机器可以直接执行的指令，Java 的 JVM 和.NET 的 CLR</li>
</ul>
<h2 id="虚拟化容器"><a href="#虚拟化容器" class="headerlink" title="虚拟化容器"></a>虚拟化容器</h2><p>容器的最初目的: 隔离资源</p>
<ul>
<li>隔离文件: chroot, 当某个进程经过chroot操作之后，它或者它的子进程将不能再访问和操作该目录之外的其他文件</li>
<li>隔离访问：namespaces, 由内核直接提供的全局资源封装，是内核针对进程设计的访问隔离机制, 不仅文件系统是独立的，还有着独立的 PID 编号、UID&#x2F;GID 编号、网络</li>
<li>隔离资源：cgroups, 由内核提供的功能，用于隔离或者说分配并限制某个进程组能够使用的资源配额，包括处理器时间、内存大小、磁盘 I&#x2F;O 速度等</li>
<li>封装系统：LXC, LXC封装系统, Docker封装应用</li>
<li>封装应用：Docker</li>
<li>封装集群：Kubernetes, Docker Engine 经历从不可或缺、默认依赖、可选择、直到淘汰是大概率事件</li>
</ul>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Docker 提倡单个容器封装单进程应用, 因为 Docker 只能通过监视 PID 为 1 的进程（即由 ENTRYPOINT 启动的进程）的运行状态来判断容器的工作状态是否正常</p>
<p>Docker Compose 可以设置不同的容器共享volume, 共享 IPC 名称空间</p>
<p>容器的本质是对 cgroups 和 namespaces 所提供的隔离能力的一种封装，然而 Linux 的 cgroups 和 namespaces 原本都是针对进程组而不仅仅是单个进程来设计的，同一个进程组中的多个进程天然就可以共享着相同的访问权限与资源配额, Kubernetes 里的 Pod</p>
<p>容器协作</p>
<ul>
<li>普通非亲密的容器, 以网络交互方式（其他譬如共享分布式存储来交换信息也算跨网络）</li>
<li>亲密协作的容器，被调度到同一个集群节点上，可以通过共享本地磁盘等方式协作</li>
<li>超亲密的协作, 特指多个容器位于同一个 Pod, 共享: UTS 名称空间, 网络名称空间, IPC 名称空间, 时间名称空间</li>
</ul>
<p>Kubernetes 将一切皆视为资源，不同资源之间依靠层级关系相互组合协作</p>
<ul>
<li>container, 延续了自 Docker 以来一个容器封装一个应用进程的理念，是镜像管理的最小单位</li>
<li>Pod, 补充了容器化后缺失的与进程组对应的“容器组”的概念，是资源调度的最小单位</li>
<li>Node, 对应于集群中的单台机器，这里的机器即可以是生产环境中的物理机，也可以是云计算环境中的虚拟节点，节点是处理器和内存等资源的资源池，是硬件单元的最小单位</li>
<li>Cluster, 当你要部署应用的时候，只需要通过声明式 API 将你的意图写成一份元数据, 是处理元数据的最小单位</li>
</ul>
<p>资源附加上了期望状态与实际状态两项属性，用户要想使用这些资源来实现某种需求，并不提倡像平常编程那样去调用某个或某一组方法来达成目的，而是通过描述清楚这些资源的期望状态，由 Kubernetes 中对应监视这些资源的控制器来驱动资源的实际状态逐渐向期望状态靠拢，这种交互风格被称为是 Kubernetes 的声明式 API</p>
<p>以应用(集群)为中心的封装</p>
<ul>
<li>Kustomize, 根据环境来生成不同的部署配置</li>
<li>Helm, Chart, 应用商店与包管理工具, 无法很好地管理这种有状态的依赖关系</li>
<li>Operator, CRD, 要求开发者自己实现一个专门针对该自定义资源的控制器，在控制器中维护自定义资源的期望状态</li>
<li>开放应用模型</li>
</ul>
<h2 id="容器间网络"><a href="#容器间网络" class="headerlink" title="容器间网络"></a>容器间网络</h2><h3 id="Linux网络虚拟化"><a href="#Linux网络虚拟化" class="headerlink" title="Linux网络虚拟化"></a>Linux网络虚拟化</h3><h4 id="网络通信模型"><a href="#网络通信模型" class="headerlink" title="网络通信模型"></a>网络通信模型</h4><h4 id="干预网络通信"><a href="#干预网络通信" class="headerlink" title="干预网络通信"></a>干预网络通信</h4><h4 id="虚拟化网络设备"><a href="#虚拟化网络设备" class="headerlink" title="虚拟化网络设备"></a>虚拟化网络设备</h4><h4 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h4><h3 id="容器网络与生态"><a href="#容器网络与生态" class="headerlink" title="容器网络与生态"></a>容器网络与生态</h3><h4 id="CNM-与-CNI"><a href="#CNM-与-CNI" class="headerlink" title="CNM 与 CNI"></a>CNM 与 CNI</h4><h4 id="网络插件生态"><a href="#网络插件生态" class="headerlink" title="网络插件生态"></a>网络插件生态</h4><h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><h3 id="Kubernetes-存储设计"><a href="#Kubernetes-存储设计" class="headerlink" title="Kubernetes 存储设计"></a>Kubernetes 存储设计</h3><h4 id="Mount-和-Volume"><a href="#Mount-和-Volume" class="headerlink" title="Mount 和 Volume"></a>Mount 和 Volume</h4><h4 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h4><h4 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h4><h3 id="容器存储与生态"><a href="#容器存储与生态" class="headerlink" title="容器存储与生态"></a>容器存储与生态</h3><h4 id="Kubernetes-存储架构"><a href="#Kubernetes-存储架构" class="headerlink" title="Kubernetes 存储架构"></a>Kubernetes 存储架构</h4><h4 id="FlexVolume-与-CSI"><a href="#FlexVolume-与-CSI" class="headerlink" title="FlexVolume 与 CSI"></a>FlexVolume 与 CSI</h4><h4 id="从-In-Tree-到-Out-of-Tree"><a href="#从-In-Tree-到-Out-of-Tree" class="headerlink" title="从 In-Tree 到 Out-of-Tree"></a>从 In-Tree 到 Out-of-Tree</h4><h4 id="容器插件生态"><a href="#容器插件生态" class="headerlink" title="容器插件生态"></a>容器插件生态</h4><h2 id="资源与调度"><a href="#资源与调度" class="headerlink" title="资源与调度"></a>资源与调度</h2><h3 id="资源模型"><a href="#资源模型" class="headerlink" title="资源模型"></a>资源模型</h3><h3 id="服务质量与优先级"><a href="#服务质量与优先级" class="headerlink" title="服务质量与优先级"></a>服务质量与优先级</h3><h3 id="驱逐机制"><a href="#驱逐机制" class="headerlink" title="驱逐机制"></a>驱逐机制</h3><h3 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h3><h2 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h2><h3 id="透明通信的涅槃"><a href="#透明通信的涅槃" class="headerlink" title="透明通信的涅槃"></a>透明通信的涅槃</h3><h4 id="通信的成本"><a href="#通信的成本" class="headerlink" title="通信的成本"></a>通信的成本</h4><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><h4 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h4><h3 id="服务网格与生态"><a href="#服务网格与生态" class="headerlink" title="服务网格与生态"></a>服务网格与生态</h3><h4 id="服务网格接口"><a href="#服务网格接口" class="headerlink" title="服务网格接口"></a>服务网格接口</h4><h4 id="通用数据平面-API"><a href="#通用数据平面-API" class="headerlink" title="通用数据平面 API"></a>通用数据平面 API</h4><h4 id="服务网格生态"><a href="#服务网格生态" class="headerlink" title="服务网格生态"></a>服务网格生态</h4><h1 id="技术方法论"><a href="#技术方法论" class="headerlink" title="技术方法论"></a>技术方法论</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的目的是有效的拆分应用，实现敏捷开发和部署</p>
<p>前提条件</p>
<ol>
<li>决策者与执行者都能意识到康威定律在软件设计中的关键作用(系统的架构趋同于组织的沟通结构)</li>
<li>组织中具备一些对微服务有充分理解、有一定实践经验的技术专家</li>
<li>系统应具有以自治为目标的自动化与监控度量能力</li>
<li>复杂性已经成为制约生产力的主要矛盾</li>
</ol>
<p>微服务的粒度: 领域驱动设计, DDD</p>
<ul>
<li>能够独立发布、独立部署、独立运行与独立测试</li>
<li>强相关的功能与数据在同一个服务中处理</li>
<li>一个服务包含至少一项业务实体与对应的完整操作</li>
<li>一个 2 Pizza Team (6-12) 能够在一个研发周期内完成的全部需求范围</li>
</ul>
<p>系统复杂性来源</p>
<ul>
<li>认知负担, 微服务&gt;单体服务</li>
<li>合作成本, 随人数的上升而上升, 单体服务上升比例远大于微服务</li>
</ul>
<p>架构腐化</p>
<blockquote>
<p>项目在开始的时候，团队会花很多时间去决策该选择用什么技术体系、哪种架构、怎样的平台框架、甚至具体到开发、测试和持续集成工具。此时就像小孩子们在选择自己所钟爱的玩具，笔者相信无论决策的结果如何，团队都会欣然选择他们所选择的，并且坚信他们的选择是正确的。事实也确实如此，团队选择的解决方案通常能够解决技术选型时就能预料到的那部分困难。但真正困难的地方在于，随着时间的流逝，团队对该项目质量的持续保持能力会逐渐下降，一方面是高级技术专家不可能持续参与软件稳定之后的迭代过程，反过来，如果持续绑定在同一个达到稳定之后的项目上，也很难培养出技术专家。老人的退出新人的加入使得团队总是需要理解旧代码的同时完成新功能，技术专家偶尔来评审一下或救一救火，充其量只能算临时抱佛脚；另一方面是代码会逐渐失控，时间长了一定会有某些并不适合放进最初设计中的需求出现，工期紧任务重业务复杂代码不熟悉都会成为欠下一笔技术债的妥协理由，原则底线每一次被细微地突破，都可能被破窗效应撕裂放大成触目惊心的血痕，最终累积到每个新人到来就马上能嗅出老朽腐臭味道的程度。</p>
</blockquote>
<p>架构腐化是软件动态发展中出现的问题，任何静态的治理方案都只能延缓，不能根治，唯一有效的办法是演进式的设计</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022-01-07-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97a%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E6%AC%A1%E5%B9%82.html" rel="prev" title="位运算计算大于等于给定数字a的最小二次幂">
                  <i class="fa fa-angle-left"></i> 位运算计算大于等于给定数字a的最小二次幂
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022-05-13-HTTP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%B6%85%E9%99%90%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9EHTTP-body.html" rel="next" title="处理HTTP接口上传文件大小超限异常">
                  处理HTTP接口上传文件大小超限异常 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">hahahaha123567</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">197k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:59</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  






  





</body>
</html>
