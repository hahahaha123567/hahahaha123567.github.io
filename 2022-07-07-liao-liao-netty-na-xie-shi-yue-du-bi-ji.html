<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/snowman-32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/snowman-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/snowman-16.ico">
  <link rel="mask-icon" href="/images/snowman-32.ico" color="#222">
  <meta name="google-site-verification" content="nIwDujusms8FJRDa0EoTbcjQopAILXWLI9fbAYxm7LE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hahahaha123567.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="《聊聊Netty那些事》bin的技术小屋">
<meta property="og:type" content="article">
<meta property="og:title" content="《聊聊Netty那些事》阅读笔记">
<meta property="og:url" content="https://hahahaha123567.github.io/2022-07-07-liao-liao-netty-na-xie-shi-yue-du-bi-ji.html">
<meta property="og:site_name" content="hahahaha123567&#39;s Blog">
<meta property="og:description" content="《聊聊Netty那些事》bin的技术小屋">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hahahaha123567.github.io/image/netty1.png">
<meta property="og:image" content="https://hahahaha123567.github.io/image/netty2.png">
<meta property="og:image" content="https://hahahaha123567.github.io/image/netty3.png">
<meta property="og:image" content="https://hahahaha123567.github.io/image/netty4.png">
<meta property="og:image" content="https://hahahaha123567.github.io/image/netty5.png">
<meta property="og:image" content="https://hahahaha123567.github.io/netty6.png">
<meta property="og:image" content="https://hahahaha123567.github.io/netty7.png">
<meta property="og:image" content="https://hahahaha123567.github.io/netty8.png">
<meta property="og:image" content="https://hahahaha123567.github.io/netty9.png">
<meta property="og:image" content="https://hahahaha123567.github.io/netty10.png">
<meta property="article:published_time" content="2022-07-06T16:00:00.000Z">
<meta property="article:modified_time" content="2022-07-19T07:12:24.782Z">
<meta property="article:author" content="hahahaha123567">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hahahaha123567.github.io/image/netty1.png">

<link rel="canonical" href="https://hahahaha123567.github.io/2022-07-07-liao-liao-netty-na-xie-shi-yue-du-bi-ji.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《聊聊Netty那些事》阅读笔记 | hahahaha123567's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hahahaha123567's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2022-07-07-liao-liao-netty-na-xie-shi-yue-du-bi-ji.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/nicoumi.jpg">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《聊聊Netty那些事》阅读笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-07T00:00:00+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-19 15:12:24" itemprop="dateModified" datetime="2022-07-19T15:12:24+08:00">2022-07-19</time>
              </span>

          
            <div class="post-description">《聊聊Netty那些事》bin的技术小屋</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="从内核角度看IO模型"><a href="#从内核角度看IO模型" class="headerlink" title="从内核角度看IO模型"></a>从内核角度看IO模型</h1><h2 id="接收网络数据包的详细开销"><a href="#接收网络数据包的详细开销" class="headerlink" title="接收网络数据包的详细开销"></a>接收网络数据包的详细开销</h2><ul>
<li>应用程序通过系统调用从<code>用户态</code>转为<code>内核态</code>的开销, 系统调用返回时从<code>内核态</code>转为<code>用户态</code>的开销</li>
<li>内核线程ksoftirqd响应<code>软中断</code>的开销</li>
<li>CPU响应<code>硬中断</code>的开销</li>
<li>DMA从<code>网卡</code>拷贝网络数据包到<code>内存</code>中的开销</li>
<li>网络数据从<code>内存</code>的<code>内核空间</code>通过CPU拷贝到<code>用户空间</code>的开销</li>
</ul>
<h2 id="接收网络数据包的2个流程"><a href="#接收网络数据包的2个流程" class="headerlink" title="接收网络数据包的2个流程"></a>接收网络数据包的2个流程</h2><ul>
<li>数据准备阶段:  在这个阶段, 网络数据包到达<code>网卡</code>, 通过<code>DMA</code>的方式将数据包拷贝到<code>内存</code>中, 然后经过<code>硬中断</code>, <code>软中断</code>, 接着通过内核线程ksoftirqd经过内核协议栈的处理, 最终将数据发送到<code>内核Socket的接收缓冲区</code>中</li>
<li>数据拷贝阶段:  当数据到达内核Socket的接收缓冲区中时, 此时数据存在于<code>内核空间</code>中, 需要将数据拷贝到<code>用户空间</code>中, 才能够被应用程序读取</li>
</ul>
<h2 id="同步与异步-阻塞与非阻塞"><a href="#同步与异步-阻塞与非阻塞" class="headerlink" title="同步与异步, 阻塞与非阻塞"></a>同步与异步, 阻塞与非阻塞</h2><p>参考<a href="https://hahahaha123567.github.io/2022-01-14-feng-huang-jia-gou-du-shu-bi-ji-copy.html">《凤凰架构》读书摘要 </a>的[网络 IO 模型]一节 <a target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/connect/service-routing.html">网关路由 | 凤凰架构</a></p>
<ul>
<li>同步IO(Synchronous I/O)<ul>
<li>阻塞IO(Blocking I/O), 节省 CPU 资源(Java传统IO模型)</li>
<li>非阻塞IO(Non-Blocking I/O), 浪费 CPU 资源(Java的NIO)</li>
<li>多路复用IO(Multiplexing I/O), 主流(通过NIO实现的Reactor模式)</li>
<li>信号驱动IO(Signal-Driven I/O), 需要自己从缓冲区获取数据</li>
</ul>
</li>
<li>异步IO(Asynchronous I/O)(通过AIO实现的Proactor模式)</li>
</ul>
<p>阻塞与非阻塞的区别主要发生在第一阶段: 数据准备阶段</p>
<ul>
<li>阻塞模式, 当Socket的接收缓冲区中没有数据的时候, 应用线程会一直等待</li>
<li>非阻塞模式, 应用线程不会等待, 系统调用直接返回错误标志EWOULDBLOCK</li>
</ul>
<p>同步与异步主要的区别发生在第二阶段: 数据拷贝阶段</p>
<ul>
<li>同步模式在数据准备好后, 是由用户线程的内核态来执行第二阶段, 所以应用程序会在第二阶段发生阻塞, 直到数据从内核空间拷贝到用户空间, 系统调用才会返回</li>
<li>异步模式下是由内核来执行第二阶段的数据拷贝操作, 当内核执行完第二阶段, 会通知用户线程IO操作已经完成, 并将数据回调给用户线程</li>
</ul>
<h2 id="TODO-跳过了select-poll-epoll的执行流程"><a href="#TODO-跳过了select-poll-epoll的执行流程" class="headerlink" title="TODO 跳过了select/poll/epoll的执行流程"></a>TODO 跳过了select/poll/epoll的执行流程</h2><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><ul>
<li>单Reactor单线程<ul>
<li>单Reactor意味着只有一个epoll对象, 用来监听所有的事件, 比如连接事件, 读写事件, </li>
<li>单线程意味着只有一个线程来执行epoll_wait获取IO就绪的Socket, 然后对这些就绪的Socket执行读写, 以及后边的业务处理也依然是这个线程</li>
</ul>
</li>
<li>单Reactor多线程<ul>
<li>只有一个epoll对象来监听所有的IO事件, 一个线程来调用epoll_wait获取IO就绪的Socket, </li>
<li>但是当IO就绪事件产生时, 这些IO事件对应处理的业务Handler, 我们是通过线程池来执行, 这样相比单Reactor单线程模型提高了执行效率, 充分发挥了多核CPU的优势</li>
</ul>
</li>
<li>主从Reactor多线程<ul>
<li><code>主Reactor</code>用来做优先级最高的事情, 也就是处理连接事件</li>
<li>当创建好连接, 建立好对应的socket后, 在acceptor中将要监听的read事件注册到<code>从Reactor</code>中, 由<code>从Reactor</code>来监听socket上的读写事件</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置单Reactor单线程</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap(); </span><br><span class="line">serverBootstrap.group(eventGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置多Reactor线程</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap(); </span><br><span class="line">serverBootstrap.group(eventGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置主从Reactor多线程</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>); </span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap(); </span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>

<h2 id="Netty对Reactor模型的实现"><a href="#Netty对Reactor模型的实现" class="headerlink" title="Netty对Reactor模型的实现"></a>Netty对Reactor模型的实现</h2><p><img src="../../../../image/netty1.png" alt="Netty中的reactor"></p>
<p>Reactor在netty中是以group的形式出现的, netty中将Reactor分为两组, 一组是MainReactorGroup也就是我们在编码中常常看到的<code>EventLoopGroup bossGroup</code>, 另一组是SubReactorGroup也就是我们在编码中常常看到的<code>EventLoopGroup workerGroup</code></p>
<h3 id="MainReactorGroup"><a href="#MainReactorGroup" class="headerlink" title="MainReactorGroup"></a>MainReactorGroup</h3><p><code>MainReactorGroup</code>中通常只有一个Reactor, 专门负责做最重要的事情, 也就是 <strong>监听连接accept事件</strong>, 当有连接事件产生时, 在对应的处理handler acceptor中创建初始化相应的NioSocketChannel(代表一个Socket连接), 然后以负载均衡的方式在<code>SubReactorGroup</code>中选取一个Reactor, 注册上去 <strong>监听Read事件</strong>, ServerBootstrapAcceptor</p>
<p>MainReactorGroup中只有一个Reactor的原因是, 通常我们服务端程序只会绑定监听一个端口, 如果要绑定监听多个端口, 就会配置多个Reactor</p>
<h3 id="SubReactorGroup"><a href="#SubReactorGroup" class="headerlink" title="SubReactorGroup"></a>SubReactorGroup</h3><p>SubReactorGroup中有多个Reactor, 具体Reactor的个数可以由系统参数指定, 默认的Reactor的个数为CPU核数 * 2, SubReactorGroup中的Reactor主要负责监听读写事件, 每一个Reactor负责监听一组socket连接</p>
<p>一个Reactor分配一个IO线程, 这个IO线程负责从Reactor中获取IO就绪事件, 执行IO调用获取IO数据, 执行PipeLine</p>
<p>Socket连接在创建后就被固定的分配给一个Reactor, 所以一个Socket连接也只会被一个固定的IO线程执行, 这种无锁串行化的设计的目的是为了防止多线程并发执行同一个socket连接上的IO逻辑处理, 防止出现线程安全问题</p>
<ol>
<li>轮询IO就绪事件</li>
<li>处理IO事件</li>
<li>执行异步任务</li>
</ol>
<p>由于每个Reactor中只有一个IO线程, 这个IO线程既要执行IO活跃Socket连接对应的PipeLine中的ChannelHandler, 又要从Reactor中获取IO就绪事件, 执行IO调用, 所以PipeLine中ChannelHandler中执行的逻辑不能耗时太长, 尽量将耗时的业务逻辑处理放入单独的业务线程池中处理, 否则会影响其他连接的IO读写, 从而近一步影响整个服务程序的IO吞吐</p>
<h1 id="Reactor在Netty中的实现-创建篇"><a href="#Reactor在Netty中的实现-创建篇" class="headerlink" title="Reactor在Netty中的实现(创建篇)"></a>Reactor在Netty中的实现(创建篇)</h1><h2 id="Netty服务端代码模板"><a href="#Netty服务端代码模板" class="headerlink" title="Netty服务端代码模板"></a>Netty服务端代码模板</h2><p>创建主从Reactor Group，在Netty中EventLoopGroup就是Reactor Group的实现类, EventLoop就是Reactor的实现类</p>
<p>Socket</p>
<ul>
<li>NioServerSocketChannel, 监听Socket, 负责listen和bind, 使用ServerBootstrapAcceptor创建客户端连接socket</li>
<li>NioSocketChannel, 客户端连接socket, 负责与客户端之间的网络通信</li>
</ul>
<p>serverBootstrap.handler设置的是服务端NioServerSocketChannel PipeLine中的ChannelHandler, ServerBootstrap启动类方法带有child前缀的均是设置客户端NioSocketChannel属性的</p>
<h2 id="创建用于启动Reactor线程的executor"><a href="#创建用于启动Reactor线程的executor" class="headerlink" title="创建用于启动Reactor线程的executor"></a>创建用于启动Reactor线程的executor</h2><p>ThreadPerTaskExecutor来一个任务就创建一个线程执行, Reactor线程的核心就是一个死循环不停的轮询IO就绪事件，处理IO事件，执行异步任务</p>
<h2 id="创建Reactor"><a href="#创建Reactor" class="headerlink" title="创建Reactor"></a>创建Reactor</h2><p><img src="../../../../image/netty2.png" alt="Reactor结构"></p>
<p>Reactor线程组NioEventLoopGroup包含多个Reactor，存放于<code>private final EventExecutor[] children</code>中</p>
<p>Reactor的核心是采用的IO多路复用模型来对客户端连接上的IO事件进行监听，所以最重要的事情是创建Selector</p>
<p>openSelector是NioEventLoop类中用于创建IO多路复用的Selector，并对创建出来的JDK NIO 原生的Selector进行性能优化: </p>
<ol>
<li>将<code>SelectorImpl</code>中存放可用socket的<code>HashSet</code>使用反射修改为<code>SelectedSelectionKeySet</code>, 底层实现从<code>HashMap</code>变为<code>数组</code>, 优化遍历、插入性能, 利用cpu cache</li>
<li>使用代理模式, 用<code>SelectedSelectionKeySetSelector</code>代理selector的真实实现类, 在每次遍历结束后清空SelectedSelectionKeySet的内容</li>
</ol>
<p>Reactor内的异步任务队列的类型为MpscQueue,它是由JCTools提供的一个高性能无锁队列，从命名前缀Mpsc可以看出，它适用于多生产者单消费者的场景</p>
<p>Reactor负责执行的异步任务分为三类: </p>
<ul>
<li>普通任务: 这是Netty最主要执行的异步任务，存放在普通任务队列taskQueue中, 在NioEventLoop构造函数中创建</li>
<li>定时任务:  存放在优先级队列中, </li>
<li>尾部任务:  存放于尾部任务队列tailTasks中，尾部任务一般不常用，在普通任务执行完后 Reactor线程会执行尾部任务, 比如对Netty 的运行状态做一些统计数据，例如任务循环的耗时、占用物理内存的大小等等都可以向尾部队列添加一个收尾任务完成统计数据的实时更新</li>
</ul>
<h2 id="创建Channel到Reactor的绑定策略"><a href="#创建Channel到Reactor的绑定策略" class="headerlink" title="创建Channel到Reactor的绑定策略"></a>创建Channel到Reactor的绑定策略</h2><p>无论是Netty服务端NioServerSocketChannel关注的<code>OP_ACCEPT</code>事件也好，还是Netty客户端NioSocketChannel关注的<code>OP_READ</code>和<code>OP_WRITE</code>事件也好，都需要先注册到Reactor上，Reactor才能监听Channel上关注的IO事件实现IO多路复用</p>
<p>MultithreadEventExecutorGroup类的构造器参数EventExecutorChooserFactory负责创建Channel到Reactor的绑定策略, 默认为round-robin轮询, 如果reactor数量为2的次幂可以用移位快速计算</p>
<h1 id="Netty-Reactor启动全流程"><a href="#Netty-Reactor启动全流程" class="headerlink" title="Netty Reactor启动全流程"></a>Netty Reactor启动全流程</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>不管是服务端用到的NioServerSocketChannel还是客户端用到的NioSocketChannel，每个Channel实例都会有一个Pipeline，Pipeline中有多个ChannelHandler用于编排处理对应Channel上感兴趣的IO事件</p>
<p>向NioServerSocketChannel中的Pipeline添加ChannelHandler分为两种方式</p>
<ol>
<li>显式添加: 用户通过ServerBootstrap#handler添加, 如果需要添加多个ChannelHandler，则可以通过ChannelInitializer向pipeline中进行添加</li>
<li>隐式添加: 隐式添加主要添加的就是主ReactorGroup的核心组件, 也就是图中的acceptor，Netty中的实现为ServerBootstrapAcceptor，本质上也是一种ChannelHandler，主要负责在客户端连接建立好后，初始化客户端NioSocketChannel，在从Reactor线程组中选取一个Sub Reactor，将客户端NioSocketChannel 注册到Sub Reactor中的selector上</li>
</ol>
<p><img src="../../../../image/netty3.png" alt="ReactorGroup结构"></p>
<p>由于在Netty的IO线程模型中，是由单个Sub Reactor线程负责执行客户端NioSocketChannel中的Pipeline，一个Sub Reactor线程负责处理多个NioSocketChannel上的IO事件，如果Pipeline中的ChannelHandler添加的太多，就会影响Sub Reactor线程执行其他NioSocketChannel上的Pipeline，从而降低IO处理效率，降低吞吐量</p>
<p>所以Pipeline中的ChannelHandler不易添加过多，并且不能再ChannelHandler中执行耗时的业务处理任务</p>
<h2 id="Netty服务端的启动"><a href="#Netty服务端的启动" class="headerlink" title="Netty服务端的启动"></a>Netty服务端的启动</h2><p><img src="../../../../image/netty4.png" alt="Reactor启动后的结构"></p>
<p>Netty服务端的启动流程总体如下: </p>
<ol>
<li>创建服务端NioServerSocketChannel并初始化</li>
<li>将服务端NioServerSocketChannel注册到主Reactor线程组中</li>
<li>注册成功后，开始初始化NioServerSocketChannel中的pipeline，然后在pipeline中触发channelRegister事件</li>
<li>随后由NioServerSocketChannel绑定端口地址</li>
<li>绑定端口地址成功后，向NioServerSocketChannel对应的Pipeline中触发传播ChannelActive事件，在ChannelActive事件回调中向Main Reactor注册OP_ACCEPT事件，开始等待客户端连接, 服务端启动完成</li>
</ol>
<p>代码执行流程:</p>
<ol>
<li>创建NioServerSocketChannel</li>
<li>初始化NioServerSocketChannel</li>
<li>向Main Reactor注册NioServerSocketChannel<ol>
<li>主Reactor线程组中选取一个Main Reactor进行注册</li>
<li>向绑定后的Main Reactor进行注册</li>
<li>Reactor线程的启动</li>
<li>startThread</li>
<li>register0, 封装为异步任务</li>
<li>doRegister(), 添加Acceptor封装为异步任务</li>
<li>HandlerAdded事件回调中初始化ChannelPipeline</li>
<li>回调regFuture的ChannelFutureListener</li>
</ol>
</li>
<li>doBind0, 封装为异步任务</li>
<li>绑定端口地址<ol>
<li>HeadContext</li>
<li>channelActive事件处理, 封装为异步任务</li>
<li>beginRead</li>
</ol>
</li>
</ol>
<p><code>Unsafe</code>为<code>Channel</code>接口的一个内部接口，用于定义实现对Channel底层的各种操作，Unsafe接口定义的操作行为只能由Netty框架的Reactor线程调用，用户线程禁止调用</p>
<p>Netty自定义的SocketChannel类型均继承AttributeMap接口以及DefaultAttributeMap类，正是它们定义了ChannelAttributes, 用于向Channel添加用户自定义的一些信息</p>
<p>初始化NioServerSocketChannel中pipeline的时机是: 当NioServerSocketChannel注册到Main Reactor之后，绑定端口地址之前</p>
<p>Reactor线程的启动是在向Reactor提交第一个异步任务的时候启动的</p>
<p>Netty中的主Reactor线程组NioEventLoopGroup中的Main ReactorNioEventLoop, 是在用户程序Main线程向Main Reactor提交用于注册NioServerSocketChannel的异步任务时开始启动</p>
<h1 id="Reactor的运转架构"><a href="#Reactor的运转架构" class="headerlink" title="Reactor的运转架构"></a>Reactor的运转架构</h1><h2 id="Reactor线程的整个运行框架"><a href="#Reactor线程的整个运行框架" class="headerlink" title="Reactor线程的整个运行框架"></a>Reactor线程的整个运行框架</h2><p>Netty中的Reactor线程主要干三件事情：</p>
<ul>
<li>轮询注册在Reactor上的所有Channel感兴趣的IO就绪事件</li>
<li>处理Channel上的IO就绪事件</li>
<li>执行Netty中的异步任务</li>
</ul>
<p>Reactor线程其实执行的就是一个死循环，在死循环中不断的通过Selector去轮询IO就绪事件，如果发生IO就绪事件则从Selector系统调用中返回并处理IO就绪事件，如果没有发生IO就绪事件则一直阻塞在Selector系统调用上，直到满足Selector唤醒条件:</p>
<ol>
<li>当Selector轮询到有IO活跃事件发生时</li>
<li>当Reactor线程需要执行的定时任务到达任务执行时间deadline时</li>
<li>当有异步任务提交给Reactor时，Reactor线程需要从Selector上被唤醒，这样才能及时的去执行异步任务</li>
</ol>
<p><img src="../../../../image/netty5.png" alt="Reactor工作流程图"></p>
<h2 id="Reactor线程轮询IO就绪事件"><a href="#Reactor线程轮询IO就绪事件" class="headerlink" title="Reactor线程轮询IO就绪事件"></a>Reactor线程轮询IO就绪事件</h2><p>在Reactor线程的轮询工作开始之前，需要首先判断下当前是否有异步任务需要执行。判断依据就是查看Reactor中的异步任务队列taskQueue和用于统计信息任务用的尾部队列tailTask是否有异步任务</p>
<p>如果Reactor中有异步任务需要执行，那么Reactor线程需要立即执行，不能阻塞在Selector上。在返回前需要再顺带调用selectNow()非阻塞查看一下当前是否有IO就绪事件发生。如果有，那么正好可以和异步任务一起被处理，如果没有，则及时地处理异步任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSelectStrategy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Reactor线程要保证及时的执行异步任务</span></span><br><span class="line"><span class="comment">    * 1：如果有异步任务等待执行，则马上执行selectNow()非阻塞轮询一次IO就绪事件</span></span><br><span class="line"><span class="comment">    * 2：没有异步任务，则跳到switch select分支</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IntSupplier selectNowSupplier = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">return</span> selector.selectNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>NioEventLoop是ScheduledExecutorService的子类, 支持执行定时任务, 在阻塞轮询IO任务之前通过<code>AbstractScheduledEventExecutor</code>的<code>nextScheduledTaskDeadlineNanos</code>获取到下个定时任务执行的时间作为阻塞超时时间</p>
<p>异步任务在被提交后希望立马得到执行，那么就在提交异步任务的时候去唤醒正在阻塞轮询的Reactor线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">        strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 执行到这里说明Reactor已经从Selector上被唤醒了</span></span><br><span class="line">    <span class="comment">// 设置Reactor的状态为苏醒状态AWAKE</span></span><br><span class="line">    <span class="comment">// lazySet优化不必要的volatile操作，不使用内存屏障，不保证写操作的可见性（单线程不需要保证）</span></span><br><span class="line">    nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reactor处理IO与处理异步任务的时间比例分配"><a href="#Reactor处理IO与处理异步任务的时间比例分配" class="headerlink" title="Reactor处理IO与处理异步任务的时间比例分配"></a>Reactor处理IO与处理异步任务的时间比例分配</h2><p>Netty通过ioRatio变量来调配Reactor线程在处理IO事件和执行异步任务之间的CPU时间分配比例，防止Reactor线程处理异步任务时间过长而导致I/O 事件得不到及时地处理</p>
<p>ioRatio / 100 = 执行异步任务时间 / (执行异步任务时间 + 轮询IO事件时间), 默认50</p>
<h2 id="Reactor线程处理IO就绪事件"><a href="#Reactor线程处理IO就绪事件" class="headerlink" title="Reactor线程处理IO就绪事件"></a>Reactor线程处理IO就绪事件</h2><ol>
<li>processSelectedKeysPlain, JDK实现<ol>
<li>获取IO就绪的Channel</li>
<li>处理Channel上的IO事件<ol>
<li>处理Connect事件</li>
<li>处理Write事件</li>
<li>处理Read事件或者Accept事件</li>
</ol>
</li>
<li>从Selector中移除失效的SelectionKey, 为了保证Selector中所有KeySet的有效性，需要在Channel取消个数达到256时，触发一次selectNow，目的是清除无效的SelectionKey</li>
</ol>
</li>
<li>processSelectedKeysOptimized, Netty实现<ol>
<li>数组需要手动做清除</li>
</ol>
</li>
</ol>
<p>服务端NioServerSocketChannel中的Read方法处理的是Accept事件，客户端NioSocketChannel中的Read方法处理的是Read事件</p>
<h2 id="Reactor线程处理异步任务"><a href="#Reactor线程处理异步任务" class="headerlink" title="Reactor线程处理异步任务"></a>Reactor线程处理异步任务</h2><p>Reactor线程执行异步任务的核心逻辑:</p>
<ol>
<li>先将到期的定时任务一股脑的从定时任务队列scheduledTaskQueue中取出并转存到普通任务队列taskQueue中</li>
<li>由Reactor线程统一从普通任务队列taskQueue中取出任务执行</li>
<li>在Reactor线程执行完定时任务和普通任务后，开始执行存储于尾部任务队列tailTasks中的尾部任务</li>
</ol>
<h2 id="规避JDK-Epoll空轮询bug"><a href="#规避JDK-Epoll空轮询bug" class="headerlink" title="规避JDK Epoll空轮询bug"></a>规避JDK Epoll空轮询bug</h2><p>由于JDK NIO Epoll的空轮询BUG存在，这样会导致Reactor线程在没有任何事情可做的情况下被意外唤醒，导致CPU空转</p>
<p>既没有IO就绪事件，也没有异步任务，Reactor线程从Selector上被异常唤醒, 发生512次之后认为已触发bug, 则重建Selector(将之前注册的所有Channel重新注册到新的Selector上并关闭旧的Selector)，selectCnt计数归0</p>
<h1 id="Netty如何高效接收网络连接"><a href="#Netty如何高效接收网络连接" class="headerlink" title="Netty如何高效接收网络连接"></a>Netty如何高效接收网络连接</h1><h2 id="MainReactor处理OP-ACCEPT事件"><a href="#MainReactor处理OP-ACCEPT事件" class="headerlink" title="MainReactor处理OP_ACCEPT事件"></a>MainReactor处理OP_ACCEPT事件</h2><p>Netty将OP_ACCEPT事件处理的入口函数封装在NioServerSocketChannel里的底层操作类Unsafe的read方法中</p>
<p><img src="../../../../netty6.png" alt="接收客户端连接"></p>
<p>main reactor线程是在一个无限循环read loop中不断的调用JDK NIO serverSocketChannel.accept()方法来接收完成三次握手的客户端连接NioSocketChannel的，并将接收到的客户端连接NioSocketChannel临时保存在List<Object> readBuf集合中, 后续在NioServerSocketChannel的pipeline中通过ChannelRead事件来传递，最终会在ServerBootstrapAcceptor这个ChannelHandler中被处理初始化，并将其注册到Sub Reator Group中</p>
<p>这里的read loop循环会被限定只能读取16次，当main reactor从NioServerSocketChannel中读取客户端连接NioSocketChannel的次数达到16次之后，无论此时是否还有客户端连接都不能在继续读取了，因为还需要分配时间去执行异步任务，不能因为无限制的接收客户端连接而耽误了异步任务的执行</p>
<p><img src="../../../../netty7.png" alt="Netty接收请求"></p>
<h2 id="doReadMessages接收客户端连接"><a href="#doReadMessages接收客户端连接" class="headerlink" title="doReadMessages接收客户端连接"></a>doReadMessages接收客户端连接</h2><p>根据ServerSocketChannel的accept方法获取到JDK NIO 原生的SocketChannel（用于底层真正与客户端通信的Channel），来创建Netty中的NioSocketChannel</p>
<p><code>NioServerSocketChannel</code>与<code>NioSocketChannel</code>的不同</p>
<ol>
<li><code>NioServerSocketChannel</code>在Reactor启动过程中创建, <code>NioSocketChannel</code>在main reactor接收连接时在<code>NioServerSocketChannel</code>中被创建</li>
<li><code>NioServerSocketChannel</code>向<code>Main Reactor</code>注册<code>SelectionKey.OP_ACCEPT</code>事件, <code>NioSocketChannel</code>向<code>Sub Reactor</code>注册<code>SelectionKey.OP_READ</code>事件</li>
<li><code>NioServerSocketChannel</code>继承<code>AbstractNioMessageChannel</code>, 输出的Message指的是<code>SocketChannel</code>客户端连接; <code>NioSocketChannel</code>继承的是<code>AbstractNioByteChannel</code>, 输出的是网络数据Byte</li>
</ol>
<p><img src="../../../../netty8.png" alt="NioSocketChannel结构"></p>
<h2 id="ChannelRead事件的响应"><a href="#ChannelRead事件的响应" class="headerlink" title="ChannelRead事件的响应"></a>ChannelRead事件的响应</h2><p><code>ServerBootstrapAcceptor</code>主要的作用就是初始化客户端<code>NioSocketChannel</code>，并将客户端<code>NioSocketChannel</code>注册到<code>Sub Reactor Group</code>中，并监听OP_READ事件</p>
<h2 id="向SubReactorGroup中注册NioSocketChannel"><a href="#向SubReactorGroup中注册NioSocketChannel" class="headerlink" title="向SubReactorGroup中注册NioSocketChannel"></a>向SubReactorGroup中注册NioSocketChannel</h2><ol>
<li>从Sub Reactor Group中选取一个Sub Reactor进行绑定</li>
<li>向绑定的Sub Reactor上注册NioSocketChannel</li>
<li>register0</li>
</ol>
<p><img src="../../../../netty9.png" alt="主从Reactor组完整结构"></p>
<h1 id="Netty如何高效接收网络数据"><a href="#Netty如何高效接收网络数据" class="headerlink" title="Netty如何高效接收网络数据"></a>Netty如何高效接收网络数据</h1><h2 id="SubReactor处理OP-READ事件流程总览"><a href="#SubReactor处理OP-READ事件流程总览" class="headerlink" title="SubReactor处理OP_READ事件流程总览"></a>SubReactor处理OP_READ事件流程总览</h2><p>当网络数据到达服务端的网卡并经过内核协议栈的处理，最终数据到达Socket的接收缓冲区之后，Sub Reactor轮询到<code>NioSocketChannel</code>上的<code>OP_READ</code>事件就绪，随后Sub Reactor线程就会从JDK Selector上的阻塞轮询API<code>selector.select(timeoutMillis)</code>调用中返回，转而去处理<code>NioSocketChannel</code>上的<code>OP_READ</code>事件</p>
<p>Reactor在处理Channel上的IO事件入口函数为<code>NioEventLoop#processSelectedKey</code></p>
<h2 id="Netty接收网络数据流程总览"><a href="#Netty接收网络数据流程总览" class="headerlink" title="Netty接收网络数据流程总览"></a>Netty接收网络数据流程总览</h2><p><img src="../../../../netty10.png" alt="Netty接收网络数据流程"></p>
<p>同样在NioSocketChannel读取连接数据的read loop中也是受最大读取次数的限制，默认配置最多只能读取16次，超过16次无论此时NioSocketChannel中是否还有数据可读都不能在进行读取了</p>
<ul>
<li>lastBytesRead &lt; 0：表示客户端主动发起了连接关闭流程，Netty开始连接关闭处理流程</li>
<li>lastBytesRead = 0：表示当前NioSocketChannel上的数据已经全部读取完毕，没有数据可读，本次OP_READ事件处理完毕</li>
<li>lastBytesRead &gt; 0：表示在本次read loop中从NioSocketChannel中读取到了数据，会在NioSocketChannel的pipeline中触发ChannelRead事件，进而在pipeline中负责IO处理的ChannelHandelr中响应，处理网络请求</li>
</ul>
<h2 id="ChannelRead和ChannelReadComplete的区别"><a href="#ChannelRead和ChannelReadComplete的区别" class="headerlink" title="ChannelRead和ChannelReadComplete的区别"></a>ChannelRead和ChannelReadComplete的区别</h2><ul>
<li>ChanneRead事件：一次循环读取一次数据，就触发一次ChannelRead事件。本次最多读取在read loop循环开始分配的DirectByteBuffer容量大小</li>
<li>ChannelReadComplete事件：当读取不到数据或者不满足continueReading的任意一个条件就会退出read loop，这时就会触发ChannelReadComplete事件</li>
</ul>
<p>触发ChannelReadComplete事件并不代表NioSocketChannel中的数据已经读取完了，只能说明本次OP_READ事件处理完毕。因为有可能是客户端发送的数据太多，Netty读了16次还没读完，那就只能等到下次OP_READ事件到来的时候在进行读取了</p>
<h2 id="源码核心框架总览"><a href="#源码核心框架总览" class="headerlink" title="源码核心框架总览"></a>源码核心框架总览</h2><h3 id="分配DirectByteBuffer接收网络数据"><a href="#分配DirectByteBuffer接收网络数据" class="headerlink" title="分配DirectByteBuffer接收网络数据"></a>分配DirectByteBuffer接收网络数据</h3><p><code>NioSocketChannel</code>的2个<code>ByteBufAllocator</code></p>
<ul>
<li><code>ByteBufAllocator</code>是一个<code>PooledByteBufAllocator</code>的实例, 内存池，用来管理堆外内存<code>DirectByteBuffer</code></li>
<li><code>RecvByteBufAllocator</code>是一个<code>AdaptiveRecvByteBufAllocator</code>类的实例, 可以动态调整ByteBuffer的容量，初始为2048</li>
</ul>
<p><code>RecvByteBufAllocator</code>计算大小, 然后<code>ByteBufAllocator</code>进行内存分配</p>
<h2 id="ByteBuffer动态自适应括缩容机制"><a href="#ByteBuffer动态自适应括缩容机制" class="headerlink" title="ByteBuffer动态自适应括缩容机制"></a>ByteBuffer动态自适应括缩容机制</h2><p><strong>容量索引表</strong></p>
<ol>
<li>当索引容量小于512时，容量索引从16开始按16递增</li>
<li>当索引容量大于512时，容量索引按前一个索引容量的2倍递增</li>
</ol>
<p><code>AdaptiveRecvByteBufAllocator</code>类中定义的扩容步长<code>INDEX_INCREMENT = 4</code>，缩容步长<code>INDEX_DECREMENT = 1</code></p>
<ul>
<li>扩容: 取容量索引向后走4步对应的size</li>
<li>缩容: 取容量索引向前走1步对应的size, 满足两次缩容条件才会进行缩容</li>
</ul>
<h2 id="使用堆外内存为ByteBuffer分配内存"><a href="#使用堆外内存为ByteBuffer分配内存" class="headerlink" title="使用堆外内存为ByteBuffer分配内存"></a>使用堆外内存为ByteBuffer分配内存</h2><p>JDK接收请求的拷贝次数</p>
<ol>
<li><code>网卡</code> -&gt; <code>内核空间</code>, 使用DMA</li>
<li><code>内核空间</code> -&gt; <code>用户空间</code>, 系统调用触发</li>
<li><code>堆外内存</code> -&gt; <code>堆内存</code>, JVM拷贝</li>
</ol>
<p>Netty的好处</p>
<ol>
<li>减少FGC, 手动引用计数维护内存</li>
<li>减少一次拷贝</li>
</ol>
<h1 id="Recycler对象池"><a href="#Recycler对象池" class="headerlink" title="Recycler对象池"></a>Recycler对象池</h1><h1 id="Netty发送数据全流程"><a href="#Netty发送数据全流程" class="headerlink" title="Netty发送数据全流程"></a>Netty发送数据全流程</h1><h1 id="Pipeline-详解所有-IO-事件的触发时机以及传播路径"><a href="#Pipeline-详解所有-IO-事件的触发时机以及传播路径" class="headerlink" title="Pipeline, 详解所有 IO 事件的触发时机以及传播路径"></a>Pipeline, 详解所有 IO 事件的触发时机以及传播路径</h1><h1 id="Netty-如何处理-TCP-连接的正常关闭，异常关闭，半关闭场景"><a href="#Netty-如何处理-TCP-连接的正常关闭，异常关闭，半关闭场景" class="headerlink" title="Netty 如何处理 TCP 连接的正常关闭，异常关闭，半关闭场景"></a>Netty 如何处理 TCP 连接的正常关闭，异常关闭，半关闭场景</h1><hr>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483737&idx=1&sn=7ef3afbb54289c6e839eed724bb8a9d6">聊聊Netty那些事儿之从内核角度看IO模型</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483907&idx=1&sn=084c470a8fe6234c2c9461b5f713ff30">聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484005&idx=1&sn=52f51269902a58f40d33208421109bc3">详细图解Netty Reactor启动全流程</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484087&idx=1&sn=0c065780e0f05c23c8e6465ede86cba0">一文聊透Netty核心引擎Reactor的运转架构</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484184&idx=1&sn=726877ce28cf6e5d2ac3225fae687f19">抓到Netty一个Bug，聊一下Netty是如何高效接收网络连接的</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484244&idx=1&sn=831060fc38caa201d69f87305de7f86a">Netty如何高效接收网络数据？ByteBuffer动态自适应扩缩容机制</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484419&idx=1&sn=3a75a495f0f117cca1548da1e0f3e6e6">抓到Netty一个内存泄露Bug | 详解Recycler对象池的设计与实现</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484532&idx=1&sn=c3a8b37a2eb09509d9914494ef108c68">Netty发送数据全流程</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484823&idx=1&sn=9396fb0f5dbac5e32d0fa1129d385fbc">Netty IO 事件的编排利器 pipeline | 所有 IO 事件的触发时机以及传播路径</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247485060&idx=1&sn=736360af6eb3a4db496de2d6665ebd3c">Netty 如何应对 TCP 连接的正常关闭，异常关闭，半关闭场景</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Netty/" rel="tag"># Netty</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2077-01-01-shou-cang-jia.html" rel="prev" title="收藏夹">
      <i class="fa fa-chevron-left"></i> 收藏夹
    </a></div>
      <div class="post-nav-item">
    <a href="/2022-05-13-http-shang-chuan-wen-jian-da-xiao-chao-xian-wu-fa-fan-hui-http-body-copy.html" rel="next" title="处理HTTP接口上传文件大小超限异常">
      处理HTTP接口上传文件大小超限异常 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E5%86%85%E6%A0%B8%E8%A7%92%E5%BA%A6%E7%9C%8BIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">从内核角度看IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E8%AF%A6%E7%BB%86%E5%BC%80%E9%94%80"><span class="nav-number">1.1.</span> <span class="nav-text">接收网络数据包的详细开销</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%842%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">接收网络数据包的2个流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">1.3.</span> <span class="nav-text">同步与异步, 阻塞与非阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO-%E8%B7%B3%E8%BF%87%E4%BA%86select-poll-epoll%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">TODO 跳过了select&#x2F;poll&#x2F;epoll的执行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">Reactor模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty%E5%AF%B9Reactor%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.</span> <span class="nav-text">Netty对Reactor模型的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MainReactorGroup"><span class="nav-number">1.6.1.</span> <span class="nav-text">MainReactorGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SubReactorGroup"><span class="nav-number">1.6.2.</span> <span class="nav-text">SubReactorGroup</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reactor%E5%9C%A8Netty%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%88%9B%E5%BB%BA%E7%AF%87"><span class="nav-number">2.</span> <span class="nav-text">Reactor在Netty中的实现(创建篇)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.1.</span> <span class="nav-text">Netty服务端代码模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E4%BA%8E%E5%90%AF%E5%8A%A8Reactor%E7%BA%BF%E7%A8%8B%E7%9A%84executor"><span class="nav-number">2.2.</span> <span class="nav-text">创建用于启动Reactor线程的executor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAReactor"><span class="nav-number">2.3.</span> <span class="nav-text">创建Reactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAChannel%E5%88%B0Reactor%E7%9A%84%E7%BB%91%E5%AE%9A%E7%AD%96%E7%95%A5"><span class="nav-number">2.4.</span> <span class="nav-text">创建Channel到Reactor的绑定策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty-Reactor%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">Netty Reactor启动全流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">3.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">3.2.</span> <span class="nav-text">Netty服务端的启动</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reactor%E7%9A%84%E8%BF%90%E8%BD%AC%E6%9E%B6%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">Reactor的运转架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%90%E8%A1%8C%E6%A1%86%E6%9E%B6"><span class="nav-number">4.1.</span> <span class="nav-text">Reactor线程的整个运行框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E7%BA%BF%E7%A8%8B%E8%BD%AE%E8%AF%A2IO%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">Reactor线程轮询IO就绪事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E5%A4%84%E7%90%86IO%E4%B8%8E%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%97%B6%E9%97%B4%E6%AF%94%E4%BE%8B%E5%88%86%E9%85%8D"><span class="nav-number">4.3.</span> <span class="nav-text">Reactor处理IO与处理异步任务的时间比例分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86IO%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.4.</span> <span class="nav-text">Reactor线程处理IO就绪事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.5.</span> <span class="nav-text">Reactor线程处理异步任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%84%E9%81%BFJDK-Epoll%E7%A9%BA%E8%BD%AE%E8%AF%A2bug"><span class="nav-number">4.6.</span> <span class="nav-text">规避JDK Epoll空轮询bug</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.</span> <span class="nav-text">Netty如何高效接收网络连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MainReactor%E5%A4%84%E7%90%86OP-ACCEPT%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.1.</span> <span class="nav-text">MainReactor处理OP_ACCEPT事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#doReadMessages%E6%8E%A5%E6%94%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.2.</span> <span class="nav-text">doReadMessages接收客户端连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelRead%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94"><span class="nav-number">5.3.</span> <span class="nav-text">ChannelRead事件的响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91SubReactorGroup%E4%B8%AD%E6%B3%A8%E5%86%8CNioSocketChannel"><span class="nav-number">5.4.</span> <span class="nav-text">向SubReactorGroup中注册NioSocketChannel</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE"><span class="nav-number">6.</span> <span class="nav-text">Netty如何高效接收网络数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SubReactor%E5%A4%84%E7%90%86OP-READ%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B%E6%80%BB%E8%A7%88"><span class="nav-number">6.1.</span> <span class="nav-text">SubReactor处理OP_READ事件流程总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E6%80%BB%E8%A7%88"><span class="nav-number">6.2.</span> <span class="nav-text">Netty接收网络数据流程总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelRead%E5%92%8CChannelReadComplete%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.3.</span> <span class="nav-text">ChannelRead和ChannelReadComplete的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%80%BB%E8%A7%88"><span class="nav-number">6.4.</span> <span class="nav-text">源码核心框架总览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8DDirectByteBuffer%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE"><span class="nav-number">6.4.1.</span> <span class="nav-text">分配DirectByteBuffer接收网络数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ByteBuffer%E5%8A%A8%E6%80%81%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%AC%E7%BC%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">6.5.</span> <span class="nav-text">ByteBuffer动态自适应括缩容机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%B8%BAByteBuffer%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">6.6.</span> <span class="nav-text">使用堆外内存为ByteBuffer分配内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Recycler%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="nav-number">7.</span> <span class="nav-text">Recycler对象池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">Netty发送数据全流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pipeline-%E8%AF%A6%E8%A7%A3%E6%89%80%E6%9C%89-IO-%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA%E4%BB%A5%E5%8F%8A%E4%BC%A0%E6%92%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">9.</span> <span class="nav-text">Pipeline, 详解所有 IO 事件的触发时机以及传播路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD%EF%BC%8C%E5%BC%82%E5%B8%B8%E5%85%B3%E9%97%AD%EF%BC%8C%E5%8D%8A%E5%85%B3%E9%97%AD%E5%9C%BA%E6%99%AF"><span class="nav-number">10.</span> <span class="nav-text">Netty 如何处理 TCP 连接的正常关闭，异常关闭，半关闭场景</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hahahaha123567"
      src="/images/nicoumi.jpg">
  <p class="site-author-name" itemprop="name">hahahaha123567</p>
  <div class="site-description" itemprop="description">niconiconi</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hahahaha123567" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hahahaha123567" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/hahahaha1235678" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;hahahaha1235678" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://bangumi.tv/user/hahahaha123567" title="Bangumi → http:&#x2F;&#x2F;bangumi.tv&#x2F;user&#x2F;hahahaha123567" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bangumi</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/hahahaha123567" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hahahaha123567" rel="noopener" target="_blank"><i class=" fa-fw"></i>Zhihu</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://lovelive.ws/" title="https:&#x2F;&#x2F;lovelive.ws&#x2F;" rel="noopener" target="_blank">μ's</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hahahaha123567</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
