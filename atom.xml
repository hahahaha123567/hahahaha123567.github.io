<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hahahaha123567</title>
  
  
  <link href="https://hahahaha123567.github.io/atom.xml" rel="self"/>
  
  <link href="https://hahahaha123567.github.io/"/>
  <updated>2024-03-27T09:07:26.599Z</updated>
  <id>https://hahahaha123567.github.io/</id>
  
  <author>
    <name>hahahaha123567</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《独裁者手册》读书笔记</title>
    <link href="https://hahahaha123567.github.io/2024-03-26-%E3%80%8A%E7%8B%AC%E8%A3%81%E8%80%85%E6%89%8B%E5%86%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hahahaha123567.github.io/2024-03-26-%E3%80%8A%E7%8B%AC%E8%A3%81%E8%80%85%E6%89%8B%E5%86%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</id>
    <published>2024-03-26T13:55:00.000Z</published>
    <updated>2024-03-27T09:07:26.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文摘抄"><a href="#原文摘抄" class="headerlink" title="原文摘抄"></a>原文摘抄</h1><h2 id="引言-统治的规则"><a href="#引言-统治的规则" class="headerlink" title="引言 统治的规则"></a>引言 统治的规则</h2><blockquote><p>在对待政治时，我们必须使自己习惯于思考和谈论具体的、有名有姓的领导人的行为和利益，而不是思考和谈论那些含糊不清的理念如国家利益、共同福祉、普遍福利等</p></blockquote><blockquote><p>关于如何统治才是最佳，答案就是：采取一切必要手段先攫取权力，然后维持权力，并从始至终掌握尽可能多的国家（或企业）收入。</p></blockquote><h2 id="第一章-政治的法则"><a href="#第一章-政治的法则" class="headerlink" title="第一章 政治的法则"></a>第一章 政治的法则</h2><blockquote><p>对领导人而言，政治情势可以被分解为三种人群：名义选择人集团、实际选择人集团和致胜联盟。(the nominal selectorate, the real selectorate, and the winning coalition.)</p></blockquote><blockquote><p>像东北亚的某个国家，有规模巨大的名义选择人集团，每个人都能投票——当然这是个笑话——有规模很小的实际选择人集团，以及一个也许不超过几百人的致胜联盟，但没有这个联盟的话甚至当年他们的第一任领导人都早已灰飞烟灭。</p></blockquote><blockquote><p>我们将看到，在不同国家、不同企业或任何其他组织里，这三种人群的规模差异几乎决定了政治里发生的一切</p></blockquote><blockquote><p>政府都一个样。差别只在于选择人和致胜联盟维度。</p></blockquote><blockquote><p>“独裁制”这个术语在我们这里的真正意思是，政府建立在极少数不可或缺者的基础上</p></blockquote><blockquote><p>法则1：让你的致胜联盟越小越好</p></blockquote><blockquote><p>法则2：让你的名义选择人集团越大越好</p></blockquote><blockquote><p>法则3：掌控收入的分配</p></blockquote><blockquote><p>法则4：支付给你的核心支持者刚好足够确保他们忠诚的钱</p></blockquote><blockquote><p>法则5：不要从你的支持者的口袋里挪钱去改善人民的生活</p></blockquote><h2 id="第二章-上台"><a href="#第二章-上台" class="headerlink" title="第二章 上台"></a>第二章 上台</h2><blockquote><p>不过即便你没有走运到出生于一个政治王朝，只要你有好的或至少受欢迎的理念，你也有望在民主国家上台。而在独裁专制国家，造福人民的好的理念几乎不可能助你掌权。</p></blockquote><blockquote><p>愿意多做事是有好处的（相比少做事）——哪怕将来会产生极其严重的经济后果（不过届时你已经卸任了）</p></blockquote><h2 id="第四章-窃贫济富"><a href="#第四章-窃贫济富" class="headerlink" title="第四章 窃贫济富"></a>第四章 窃贫济富</h2><blockquote><p>对于掌管任何组织的任何人来说，钱都是至关重要的。从政府的奖赏里没法分一杯羹的话，几乎没有人会长久地忠于在位者。</p></blockquote><blockquote><p>民主国家具有条理井然和相对透明的国家财政，领导人更迭不会干扰到资金流动。</p></blockquote><blockquote><p>致胜联盟承担税负的意愿才是民主国家税收水平的真正限制因素</p></blockquote><blockquote><p>因为独裁者的关键支持者人数很少，他很容易补偿落到他们身上的税负。这对民主领导人来说行不通，因为他的支持者的数量很大。税率因此被限制在一个需要的水平，就是让联盟成员不指望在别的领导人统治下能获得更好的待遇</p></blockquote><blockquote><p>对很多领导人来说，腐败并不是什么需要根除的坏事，反而是一种很关键的政治工具。</p></blockquote><blockquote><p>一旦某个国家从矿产财富中获利，它就不可能民主化。鼓励领导人采取自由化政策的最简单方式是迫使他依赖税收来获得收入。</p></blockquote><h2 id="第五章-获取与花费"><a href="#第五章-获取与花费" class="headerlink" title="第五章 获取与花费"></a>第五章 获取与花费</h2><blockquote><p>受教育程度高的人对独裁者来说是潜在的威胁，因此独裁者要限制教育机会。</p></blockquote><h2 id="第六章-腐败使人有权-绝对的腐败绝对使人有权"><a href="#第六章-腐败使人有权-绝对的腐败绝对使人有权" class="headerlink" title="第六章 腐败使人有权 绝对的腐败绝对使人有权"></a>第六章 腐败使人有权 绝对的腐败绝对使人有权</h2><blockquote><p>提高法律惩处力度无非是使领导人又多了一项惩戒他人的工具。</p></blockquote><h2 id="第八章-反叛中的人民"><a href="#第八章-反叛中的人民" class="headerlink" title="第八章 反叛中的人民"></a>第八章 反叛中的人民</h2><blockquote><p>在民主国家，抗议是为了警告领导人注意一个事实，那就是人民不高兴了，而如果政策不改变，他们将把无赖赶下台。然而在独裁国家，抗议具有更深层的目的：摧毁政府的整套制度，改变人民被统治的方式。</p></blockquote><blockquote><p>独裁者讨厌各种自由权利，因为它们使人民能更容易了解彼此共有的悲惨境况并相互协作起而反抗政府。任何时候只要可以的话，独裁者都要取缔集会自由、新闻自由和言论自由，把自己和人民的威胁隔离开来。</p></blockquote><h2 id="第九章-战争，和平与世界秩序"><a href="#第九章-战争，和平与世界秩序" class="headerlink" title="第九章 战争，和平与世界秩序"></a>第九章 战争，和平与世界秩序</h2><blockquote><p>民主领导人想尽办法要减少这样的危险。在独裁国家，步兵不具有政治上的重要性。独裁领导人不会浪费资源保护他们。</p></blockquote><blockquote><p>独裁者不愿将资源浪费在战场上。而装备精良的精英部队更主要是用来粉碎国内反对派而不是抗击意志坚定的外国对手。</p></blockquote><blockquote><p>你所要做的就是告诉他们敌人打过来了，然后谴责和平主义分子缺乏爱国心将国家置于危险之中。这套方法在任何国家都管用……</p></blockquote><blockquote><p>民主国家领导人需要推行成功的政策，否则会被人民赶下台。由于这个原因，他们只在认为胜券在握的前提下才发动战争。</p></blockquote><blockquote><p>这些强加的政策符合的是民主领导人国内支持者的利益，有时这些政策非常不友好。</p></blockquote><h2 id="第十章-怎么办？"><a href="#第十章-怎么办？" class="headerlink" title="第十章 怎么办？"></a>第十章 怎么办？</h2><blockquote><p>一个人做任何事情总有两个理由：一个好的理由和一个真正的理由。</p></blockquote><blockquote><p>那就是对人们的动机要保持怀疑。诉诸意识形态原则和人权通常都是幌子。</p></blockquote><blockquote><p>一个聪明的联盟会与人民大众合作推动联盟的扩大。人民愿意合作是因为这将为他们带来更多公共物品；联盟愿意合作是因为这将减小他们出局的风险</p></blockquote><blockquote><p>任何重大的经济压力都能迫使领导人产生自由化的想法，只要压力深重到他没有足够的钱收买政治忠诚。</p></blockquote><blockquote><p>面临风险的领导人常常决定举行欺骗性的选举以给外界造成公开公正的印象。</p></blockquote><h1 id="中国相关部分的中英文对照"><a href="#中国相关部分的中英文对照" class="headerlink" title="中国相关部分的中英文对照"></a>中国相关部分的中英文对照</h1><p>英文来源 <a href="https://www.burmalibrary.org/docs13/The_Dictators_Handbook.pdf">The Dictator’s Handbook: Why Bad Behavior is Almost Always Good Politics</a></p><p>中文来源 江苏文艺出版社</p><hr><p><strong>英文原文</strong></p><p>The second stratum of politics consists of the real selectorate. This is the group that actually chooses the leader. In today’s China (as in the old Soviet Union), it consists of all voting members of the Communist Party; in Saudi Arabia’s monarchy it is the senior members of the royal family; in Great Britain, the voters backing members of parliament from the majority party.</p><p><strong>原文谷歌翻译</strong></p><p>政治的第二层由真正的选举人组成。这是实际选择领导者的群体。在今天的中国（就像在旧苏联一样），它由所有有投票权的共产党员组成；在沙特阿拉伯的君主制中，是王室的高级成员；在英国，选民支持多数党的议会成员。</p><p><strong>中文版译文</strong></p><p>第二个政治阶层由实际选择人组成。真正选择领导人的是这个集团。在沙特阿拉伯的君主政体下，指的就是皇室的高级成员；在英国则指的是支持多数党议员的选民。</p><hr><p><strong>英文原文</strong></p><p>Strange as it may seem, the same ideas and subtle differences that held true in San Francisco can be applied to illiberal governments like Zimbabwe, China, and Cuba, and even to the more ambiguous sorts of governments like current-day Russia or Venezuela or Singapore.</p><p><strong>原文谷歌翻译</strong></p><p>尽管看起来很奇怪，但在旧金山适用的同样的想法和微妙的差异也适用于津巴布韦、中国和古巴等非自由政府，甚至适用于当今的俄罗斯、委内瑞拉或新加坡等更加模糊的政府。</p><p><strong>中文版译文</strong></p><p>看上去也许有点奇怪的是，旧金山发生的情况同样适用于一些非自由主义国家的政府，如津巴布韦、古巴，乃至一些性质更模糊的政府，如今日的俄罗斯、委内瑞拉或新加坡。</p><hr><p><strong>英文原文</strong></p><p>A few civic-minded autocrats slip a little into secret accounts, preferring to fend off the threat of revolt by using their discretionary funds (the leftover tax revenue not spent on buying coalition loyalty) to invest in public works. Those public works may prove successful, as was true for Lee KwanYew’s efforts in Singapore and Deng Xiaoping’s in China. They may also prove to be dismal failures, as was true for Kwame Nkrumah’s civic-minded industrial program in Ghana or Mao Zedong’s Great Leap Forward, which turned out to be a great leap backwards for China. </p><p><strong>原文谷歌翻译</strong></p><p>一些有公民意识的独裁者会偷偷存入一些秘密账户，他们更愿意用他们的可自由支配资金（未用于购买联盟忠诚度的剩余税收收入）投资于公共工程来抵御叛乱的威胁。这些公共工程可能会取得成功，正如李光耀在新加坡和邓小平在中国所做的努力一样。它们也可能被证明是令人沮丧的失败，就像夸梅·恩克鲁玛在加纳的具有公民意识的工业计划或毛泽东的大跃进一样，这对中国来说是一次大倒退。</p><p><strong>中文版译文</strong></p><p>一些有责任感的独裁者会将少部分钱存入秘密账户，宁愿用他们可自由裁量的资金（收买致胜联盟后剩余的钱）投资于公共事业以遏止反叛的威胁。这些公共事业可能会很成功，如李光耀在新加坡做到的。也可能产生灾难性的失败，如克瓦米·恩克鲁玛在加纳进行的公共工业项目。</p><hr><p><strong>英文原文</strong></p><p>It turns out, though, that Gorbachev was much less ruthless than contemporaries of the autocratic class. He forced adversaries, like Boris Yeltsin, out of the politburo to be sure. But, as Yeltsin surely realized, he would have been killed under Stalin. Equally, he and many others must have known that it was much better to cross swords with Gorbachev, an intellectual reformer, than with such contemporaries as Mobutu Sese Seko of Zaire or even Deng Xiaoping of China. Deng, after all, used ruthless force to end the prodemocracy uprising at Tiananmen Square in 1989. Gorbachev, as we will see, did not hesitate to use force outside of Russia, but he also did not go around killing his political rivals.</p><p><strong>原文谷歌翻译</strong></p><p>但事实证明，戈尔巴乔夫远没有同时代的专制阶级无情。可以肯定的是，他迫使鲍里斯·叶利钦等对手退出政治局。但是，叶利钦肯定意识到，在斯大林统治下他可能会被杀。同样，他和其他许多人一定知道，与知识分子改革家戈尔巴乔夫交锋比与扎伊尔的蒙博托·塞塞·塞科甚至中国的邓小平等同时代人交锋要好得多。毕竟，邓小平在1989年使用了残酷的武力结束了天安门广场的民主起义。我们将看到，戈尔巴乔夫毫不犹豫地在俄罗斯境外使用武力，但他也没有四处杀害他的政治对手。</p><p><strong>中文版译文</strong></p><p>不过事实证明，戈尔巴乔夫远不如他那一代独裁者们那般残酷无情。他确实将政治对手鲍里斯·叶利钦赶出了政治局，但叶利钦显然也知道，如果是在斯大林统治下自己早就被杀掉了。不仅如此，叶利钦和其他人也知道，与戈尔巴乔夫这样的理智改革家交锋远远好过挑战扎伊尔的蒙博托·塞塞·塞科这样的同代人物。而我们看到，戈尔巴乔夫尽管在国外使用武力毫不犹豫，在国内却未曾杀害过自己的政治对手。</p><hr><p><strong>英文原文</strong></p><p>By looking at how much tax has to be paid at a given income level across countries we get close to comparing apples to apples and oranges to oranges. In the United States, for example, a couple with one child and an income under about $32,400 pays no income tax. If their income were, say, $20,000 they would receive $1,000 from the federal government to help support their child. In China, a family with an income of $32,400 is expected to pay about $6,725 in income tax. Further, even when nominal rates are low, autocracies have high implicit taxes—if you have something valuable then it simply gets taken. It’s worth remembering that the wealthiest man in China and the wealthiest man in Russia are both currently in prison</p><p><strong>原文谷歌翻译</strong></p><p>通过观察不同国家在给定收入水平下必须缴纳多少税款，我们几乎可以将苹果与苹果、橙子与橙子进行比较。例如，在美国，一对有一个孩子且收入低于 32,400 美元的夫妇无需缴纳所得税。例如，如果他们的收入为 20,000 美元，他们将从联邦政府获得 1,000 美元来帮助抚养他们的孩子。在中国，一个收入为32,400美元的家庭预计需要缴纳约6,725美元的所得税。此外，即使名义利率很低，独裁国家的隐性税收也很高——如果你有一些有价值的东西，那么它就会被拿走。值得记住的是，中国首富和俄罗斯首富目前都在监狱中</p><p><strong>中文版译文</strong></p><p>考察在不同国家的同一个给定收入水平上征税多少，这才有可比性。举例来说，在美国，拥有一个孩子的一对夫妇，年收入在大约32400美元以下无须缴纳所得税。假如他们的年收入只有20000美元，他们将从联邦政府那里获得1000美元补助金以抚养孩子。</p><hr><p><strong>英文原文</strong></p><p>His Chinese counterpart, Huang Guangyu, also known as Wong Kwong Ku, fared little better. Starting with nothing but $500 and a street cart, Guangyu created Gome, the largest electrical retailer in China. He was repeatedly ranked as China’s richest individual—until he was sentenced to fourteen years in prison for bribery. It is likely that he was guilty since bribery is commonplace in Chinese business dealings. It is also likely that he and others who have been prosecuted for corruption in China were “chosen for political reasons.”</p><p><strong>原文谷歌翻译</strong></p><p>他的中国同行黄光裕（又名黄光谷）的情况也好不到哪儿去。光裕仅用 500 美元和一辆街头购物车起家，创建了中国最大的电器零售商国美电器。他曾多次被评为中国首富——直到他因受贿被判处十四年有期徒刑。他很可能有罪，因为贿赂在中国商业交易中很常见。他和其他因腐败而在中国被起诉的人也很可能是“出于政治原因而被选中的”。</p><p><strong>中文版译文</strong></p><p>无</p><hr><p><strong>英文原文</strong></p><p>Hobbes was only half right. It is true, as Hobbes’s believed, that happy, well-cared-for people are unlikely to revolt. China’s prolonged economic growth seems to have verified that belief (at least for now). Keep them fat and happy and the masses are unlikely to rise up against you. It seems equally true, however, that sick, starving, ignorant people are also unlikely to revolt. All seems quiet among North Korea’s masses, who deify their Dear Leader as the sole source of whatever meager, life-sustaining resources they have.</p><p><strong>原文谷歌翻译</strong></p><p>霍布斯只说对了一半。确实，正如霍布斯所认为的那样，快乐、受到良好照顾的人不太可能反抗。中国长期的经济增长似乎证实了这一信念（至少目前如此）。让他们又胖又快乐，群众就不太可能起来反对你。然而，疾病、饥饿、无知的人们似乎也不太可能反抗。朝鲜群众似乎一切都很平静，他们将敬爱的领袖奉为他们所拥有的微薄的、维持生命的资源的唯一来源。</p><p><strong>中文版译文</strong></p><p>霍布斯只对了一半。确实如霍布斯相信的，快乐的、得到良好照料的人民不太可能造反。让民众富裕和愉快，他们就不太可能起而反对你。然而似乎同样正确的是，病怏怏的、忍饥挨饿和无知的人民也不太可能造反。有些国家的民众似乎就完全安顺，他们将敬爱的领袖奉若神明，将他视作任何他们拥有的粗劣生活资料的唯一来源。</p><hr><p><strong>英文原文</strong></p><p>Indeed, a common refrain among small-coalition rulers is that the very freedoms, like free speech, free press, and especially freedom of assembly, that promote welfare-improving government policies are luxuries to be doled out only after prosperity is achieved and not before. This seems to be the self-serving claim of leaders who keep their people poor and oppressed. ThePeople’s Republic of China is the poster boy for this view. When Deng Xiaoping introduced economic liberalization to China in the 1980s, experts in wealthy Western countries contended that now China’s economy would grow and the growth would lead to rapid democratization. Today, more than thirty years into sustained rapid growth we still await these anticipated political reforms. Growth does not guarantee political improvement but neither does it preclude it. The Republic of China (aka Taiwan) and the Republic of Korea (aka South Korea) are models of building prosperity ahead of democracy. Needless to say, the People’s Republic of China certainly is not fond of promoting either of those countries’ experiences.</p><p><strong>原文谷歌翻译</strong></p><p>事实上，小联盟统治者的一个共同观点是，那些促进改善福利的政府政策的自由，如言论自由、新闻自由，尤其是集会自由，都是奢侈品，只有在实现繁荣之后才能发放，而不是在实现繁荣之前。这似乎是那些让人民陷入贫困和受压迫的领导人自私的主张。中华民国是这一观点的典型代表。当邓小平在20世纪80年代向中国引入经济自由化时，西方富裕国家的专家认为，现在中国的经济将会增长，而这种增长将导致快速的民主化。今天，在持续快速增长三十多年之后，我们仍在等待这些预期的政治改革。增长并不能保证政治进步，但也不排除政治进步。中华民国（又名台湾）和大韩民国（又名韩国）是先于民主建设繁荣的典范。不用说，中华人民共和国当然不喜欢推广这两个国家的经验。</p><p><strong>中文版译文</strong></p><p>事实上，那些依赖小联盟的国家领导人们有一种普遍的说辞是，能够促进政府改善人民福利的那些自由权利太奢侈——比如言论自由、新闻自由，特别是集会自由——只可能在获得经济繁荣之后才能让民众享有，而不是之前。这看上去正是那些让人民受穷受迫的领导人们的自私主张。</p><hr><p><strong>英文原文</strong></p><p>A far better measure of leaders’ interest in education is the distribution of top universities. With the sole exceptions of China and Singapore, no nondemocratic country has even one university rated among the world’s top 200. Despite its size, and not counting universities in Hong Kong, which were established under British rule before Hong Kong’s return to China in 1997, the best-ranked Chinese university is only in 47th place despite China’s opportunity to draw top minds from its vast population. The highest ranking Russian university, with Russia’s long history of dictatorship, is 210th. By contrast, countries with relatively few people but with dependence on many essential backers, like Israel, Finland, Norway, the Netherlands, Belgium, andCanada, have several universities ranked among the top 200.That this uneven distribution of top-notch universities favors large</p><p><strong>原文谷歌翻译</strong></p><p>衡量领导人对教育兴趣的一个更好的衡量标准是顶尖大学的分布情况。除了中国和新加坡之外，没有一个非民主国家有一所大学跻身世界前 200 名。尽管香港大学规模庞大，而且还不包括 1997 年香港回归中国之前在英国统治下建立的香港大学，尽管中国有机会从其庞大的人口中吸引顶尖人才，但排名最好的中国大学仅排在第 47 位。由于俄罗斯长期独裁历史，排名最高的俄罗斯大学排名第210位。相比之下，人口相对较少但依赖许多重要支持者的国家，如以色列、芬兰、挪威、荷兰、比利时和加拿大，有几所大学跻身前 200 名。</p><p><strong>中文版译文</strong></p><p>考察领导人对教育的兴趣，有一个更好的衡量办法，就是看顶尖大学在世界上的分布情况。除了几个特例之外，没有任何一个非民主国家拥有排名世界200强的大学。独裁历史悠久的俄罗斯在世界上排名最高的大学仅排在第210名。相比之下，那些人口较少、依赖大量核心支持者的国家，比如以色列、芬兰、挪威、荷兰、比利时、加拿大，无一不拥有多所大学进入世界200强。</p><hr><p><strong>英文原文</strong></p><p>Why, for instance, would any autocrat eager to stay in power want to open the secondary schools to people who are not likely to contribute to the coalition’s wealth and security? Math and science are great subjects for study in China; sociology and political science are the subjects of democracies.</p><p><strong>原文谷歌翻译</strong></p><p>例如，为什么渴望继续掌权的独裁者想要向那些不太可能为联盟的财富和安全做出贡献的人开放中学？ 数学和科学是中国学习的重要学科；社会学和政治学是民主国家的学科。</p><p><strong>中文版译文</strong></p><p>举例来说，渴望长久掌权的独裁者干吗要为那些不大可能为联盟的财富和安全做出贡献的人开放中等学校？数学和科学在独裁国家是很棒的学科，而社会学和政治科学则是民主国家的学科。</p><hr><p><strong>英文原文</strong></p><p>It is incredible to see how easily leaders can take people’s property in the People’s Republic of China and how hard it is to do the same in Hong Kong. When essentials are few, pretty much anything goes.</p><p><strong>原文谷歌翻译</strong></p><p>(本人按照自己的理解修改了最后一句的翻译)</p><p>令人难以置信的是，在中华人民共和国，领导人可以如此轻松地夺取人民的财产，而在香港做同样的事情却是多么困难。当制胜联盟很小时，几乎做什么都可以。</p><p><strong>中文版译文</strong></p><p>无</p><hr><p><strong>英文原文</strong></p><p>Massive construction projects, like the Aswan Dam in Egypt and China’s Three Gorges Dam, are very much like Mobutu’s power grid. These sorts of projects are great for autocrats. Although they dislocate vast numbers of people, they also generate vast corruption opportunities, making them gems of private rewards as well as providers of basic public infrastructure.</p><p><strong>原文谷歌翻译</strong></p><p>埃及阿斯旺大坝和中国三峡大坝等大型建设项目与蒙博托的电网非常相似。这类项目对于独裁者来说非常有利。尽管它们使大量人员流离失所，但也产生了大量腐败机会，使它们成为私人奖励的瑰宝以及基本公共基础设施的提供者。</p><p><strong>中文版译文</strong></p><p>类似埃及阿斯旺水坝这样的大规模建设项目很像蒙博托的电网。这种工程对独裁者们来说太有利可图了。尽管这种工程必须搬迁走数量庞大的库区居民，它们也创造了巨大的贪腐机会，在成为基本公共基础设施提供者的同时成为私人报偿的绝佳来源。</p><hr><p><strong>英文原文</strong></p><p>The comparison of Iran and Chile is far from unusual. China, like Chile, suffered a 7.9 earthquake of its own. It struck in May 2008, bringing down many shoddily constructed schools and apartment buildings, killing nearly 70,000. Even accounting for variations in Chile’s and China’s populations and incomes, it is impossible to reconcile the difference between China’s death toll and Chile’s, except by reflecting on the incentives to enforce proper building standards in democratic Chile—incentives missing in autocratic China and Iran. And lest it is thought these are special cases, it is worth noting that democratic Honduras had a 7.1 earthquake in May 2009, with 6 deaths and Italy a 6.3 inApril 2009 with 207 deaths.</p><p><strong>原文谷歌翻译</strong></p><p>伊朗和智利的比较并不罕见。中国和智利一样，也遭遇了7.9级地震。2008 年 5 月的袭击摧毁了许多粗制滥造的学校和公寓楼，造成近 7 万人死亡。即使考虑到智利和中国的人口和收入差异，也无法调和中国和智利死亡人数之间的差异，除非反思民主智利执行适当建筑标准的激励措施——而专制中国和伊朗则缺乏这种激励措施。为了避免人们认为这些是特殊情况，值得注意的是，民主国家洪都拉斯在 2009 年 5 月发生了 7.1 级地震，造成 6 人死亡，意大利在 2009 年 4 月发生了 6.3 级地震，造成 207 人死亡。</p><p><strong>中文版译文</strong></p><p>智利和伊朗之间的这种对比远不是特例。与智利一样，值得指出的是，2009年5月民主国家洪都拉斯发生里氏7.1级地震，仅6人死亡；2009年4月意大利发生6.3级地震，207人死亡。</p><hr><p><strong>英文原文</strong></p><p>Mao Zedong and Deng Xiaoping in China mirrored Khrushchev and Gorbachev, but with an important difference. All of these leaders seem to have been initially motivated by the sincere desire to improve their economy. All seemed to have recognized that failing to get their economy moving could pose a threat to their hold on power. But unlike Mao, Mikhail, and Nikita, Deng belongs squarely in the hall of fame. Like them, he was not accountable to the people and, like them, he was not hesitant to put down mass movements against his rule. The horrors of Tiananmen Square should not be forgotten.But unlike his fellow dictators, he actually had good ideas about how to improve economic performance.<br>Deng and Singapore’s Lee Kwan Yew are surely among the contemporary world’s two greatest icons of the authoritarian’s hall of fame. They did not sock fortunes away in secret bank accounts (to the best of our knowledge). They did not live the lavish lifestyles of Mobutu Sese Seko or SaddamHussein. They used their discretionary power over revenue to institute successful, market-oriented economic reforms that made Singaporeans among the world’s wealthiest people and lifted millions of Chinese out of abject poverty. Nothing about their actions contradicts the rules of successful, long-lasting governance. They were brutal when that served their interest in staying in power, Deng with murderous violence and Lee Kwan Yew through the power of the courts to drive his opponents into bankruptcy. Lee’s approach was vastly more civilized than Deng’s, but nevertheless it was the arbitrary and tough use of power dictated by the logic of political survival. And that, in the end, is what politics is all about.</p><p><strong>原文谷歌翻译</strong></p><p>中国的毛泽东和邓小平与赫鲁晓夫和戈尔巴乔夫相似，但有一个重要的区别。所有这些领导人最初似乎都是出于改善经济的真诚愿望。所有人似乎都认识到，如果经济无法发展，可能会对他们的权力构成威胁。但与毛泽东、米哈伊尔和尼基塔不同，邓完全属于名人堂。和他们一样，他不对人民负责；和他们一样，他毫不犹豫地镇压反对他统治的群众运动。天安门广场的恐怖不应该被忘记。但与他的独裁者同僚不同，他实际上对如何提高经济绩效有很好的想法。<br>邓小平和新加坡李光耀无疑是当今世界独裁者名人堂中最伟大的两位偶像。他们并没有将财富存入秘密银行账户（据我们所知）。他们没有过蒙博托·塞塞·塞科或萨达姆·侯赛因那样的奢华生活方式。他们利用对收入的自由裁量权实施了成功的、以市场为导向的经济改革，使新加坡人成为世界上最富有的人之一，并使数百万中国人摆脱了赤贫。他们的行为丝毫不违背成功、持久治理的规则。当这符合他们继续掌权的利益时，他们是残酷的，邓小平用凶残的暴力，李光耀则通过法院的力量迫使他的对手破产。李的做法比邓的文明得多，但仍然是出于政治生存逻辑而任意而强硬地使用权力。最终，这就是政治的全部意义所在。</p><p><strong>中文版译文</strong></p><p>但与他们不同的是，李光耀确实知道如何改善经济表现。李光耀毫无疑问是当代世界名人堂中最伟大的一尊偶像。他不曾将钱转到自己的秘密账户里（就我们所知而言），也不曾像蒙博托·塞塞·塞科或萨达姆·侯赛因那样过奢华的生活。他使用对政府收入的自由裁量权力进行成功的、以市场为导向的经济改革，使新加坡成为世界上最富有的国家之一。他的一切作为都符合成功和持续统治的规则。</p><hr><p><strong>英文原文</strong></p><p>At first, a few especially bold individuals may rise up in revolt. They proclaim their intention to make their country a democracy. Every revolution and every mass movement begins with a promise of democratic reform, of a new government that will lift up the downtrodden and alleviate their suffering. That is an essential ingredient in getting the masses to take to the streets. Of course, it doesn’t always work.<br>The Chinese communists, for instance, declared the formation of a Chinese Soviet Republic on November 7, 1931. They said of their newly declared state,<br>It is the state of the suppressed workers, farmers, soldiers, and working mass. Its flag calls for the downfall of imperialism, the liquidation of landlords, the overthrow of the warlord government of the Nationalists. We shall establish a soviet government over the whole of China; we shall struggle for the interests of thousands of deprived workers, farmers, and soldiers and other suppressed masses; and to endeavor for peaceful unification of the whole of China</p><p><strong>原文谷歌翻译</strong></p><p>起初，一些特别大胆的人可能会起来反抗。他们宣称打算使自己的国家成为民主国家。每一次革命和每一次群众运动都始于民主改革的承诺，以及新政府将提升受压迫者并减轻他们的痛苦的承诺。这是让群众走上街头的重要因素。当然，它并不总是有效。<br>例如，中国共产党于 1931 年 11 月 7 日宣布成立中华苏维埃共和国。他们谈到新宣布的国家时说：<br>这是工人、农民、士兵和劳动群众被压迫的状态。它的旗帜要求打倒帝国主义、清算地主、推翻国民党军阀政府。我们要建立全中国的苏维埃政府；我们将为成千上万被剥夺的工人、农民、士兵和其他受压迫群众的利益而奋斗；为全中国的和平统一而努力</p><p><strong>中文版译文</strong></p><p>一开始，一些特别勇敢的人可能率先造反，他们宣称将把国家变成民主国家。每一次革命和每一次群众运动都肇始于承诺进行民主改革，承诺建立一个解放受压迫者、减轻人民苦难的新政府。这是发动大众走上街头必不可少的因素。当然，它并不常常奏效。</p><hr><p><strong>英文原文</strong></p><p>Many revolutions end up simply replacing one autocracy with another. On some occasions the successor regime can actually be worse than its predecessor. This might well have been the case with Sergeant Doe’s deposition of Liberia’s True Whig government or Mao’s success against Chiang Kai Shek’s Kuomintang government in China. But the hope of the people when they participate is that they will improve their lot, either by enlarging the winning coalition through democratization or at least by becoming part of the new coalition.</p><p><strong>原文谷歌翻译</strong></p><p>许多革命最终只是简单地用一种独裁政权取代另一种独裁政权。在某些情况下，继任政权实际上可能比其前任政权更糟糕。多伊中士推翻利比里亚真正的辉格党政府或毛泽东在中国成功对抗蒋介石的国民党政府的情况很可能就是这种情况。但人民参与的希望是改善自己的命运，要么通过民主化扩大获胜联盟，要么至少成为新联盟的一部分。</p><p><strong>中文版译文</strong></p><p>很多革命的结果无非是让一个专制政权取代了另一个而已。某些情况下新政权实际上比前政权更坏。利比里亚的多伊军士推翻“真正独立党”政府大概就属于这种情况。但对于参加革命运动的人民来说，他们的希望在于可以改变命运，要么通过实现民主化扩大致胜联盟的规模，要么至少成为新联盟的一部分。</p><hr><p><strong>英文原文</strong></p><p>Not all disasters are equal in the eyes of autocrats. Dictators are particularly wary of natural disasters when they occur in politically and economically important centers. Disaster management in China emphasizes this point. When an earthquake struck the remote province of Qinghai in 2010, theChinese government’s response was, at best, halfhearted. In contrast, its handling of disaster relief in the wake of a 2008 earthquake in Sichuan won the approval of much of the international community. The differences are stark and driven by politics. The Sichuan quake occurred in an economically and politically important center where a massed protest could potentially threaten the government. Qinghai is remote and of little political importance. Protest there would do little to threaten the government. The government did much less to assist people who could not threaten them</p><p><strong>原文谷歌翻译</strong></p><p>在独裁者眼中，并非所有灾难都是平等的。当自然灾害发生在政治和经济重要中心时，独裁者尤其警惕。中国的灾害管理强调了这一点。2010年，当地震袭击偏远的青海省时，中国政府的反应充其量只是半心半意。相比之下，中国在2008年四川地震救灾中的表现赢得了国际社会的广泛认可。这些差异是明显的，并且是由政治驱动的。四川地震发生在一个具有重要经济和政治意义的中心，那里的大规模抗议活动可能会威胁到政府。青海地处偏远，政治重要性不大。那里的抗议对威胁政府没什么作用。政府对那些无法威胁他们的人提供的帮助要少得多</p><p><strong>中文版译文</strong></p><p>无</p><hr><p><strong>英文原文</strong></p><p>Perhaps even more interestingly, a few leaders threatened with revolution have also democratized as the path to keep themselves in power. Ghana’s Jerry John “J. J.” Rawlings is a perfect example. Common threads run through each of these democratizers—common threads that are absent from revolutions that replaced one dictator with another, such as occurred under Mao Zedong in China, Fidel Castro in Cuba, Porfirio Diaz in Mexico, and Jomo Kenyatta in Kenya.</p><p><strong>原文谷歌翻译</strong></p><p>也许更有趣的是，一些受到革命威胁的领导人也将民主化作为保住权力的途径。加纳的杰里·约翰“J. J。” 罗林斯就是一个完美的例子。这些民主化者都有共同的主线——这些共同主线在用一个独裁者取代另一个独裁者的革命中是不存在的，例如中国毛泽东、古巴菲德尔·卡斯特罗、墨西哥波菲里奥·迪亚兹和肯尼亚乔莫·肯雅塔领导下发生的革命。</p><p><strong>中文版译文</strong></p><p>也许更有意思的是，有不少面临革命威胁的领导人主动民主化以保留权位。加纳的杰瑞·约翰·罗林斯就是一个绝佳例子。在这些实现民主化的革命当中有一条共同的主线，这条主线在那些新独裁者取代旧独裁者的革命当中是没有的，比如波费里奥·迪亚斯领导的墨西哥革命以及乔莫·肯雅塔领导的肯尼亚革命。</p><hr><p><strong>英文原文</strong></p><p>Sure, places like Singapore and parts of China prove that it is possible to have a good material life with limited freedom—yet the vast majority of the evidence suggests that these are exceptions and not the rule. Economic success can postpone the democratic moment but it ultimately cannot replace it.</p><p><strong>原文谷歌翻译</strong></p><p>当然，像新加坡和中国部分地区这样的地方证明，在有限的自由下也可以过上良好的物质生活，但绝大多数证据表明，这些都是例外，而不是普遍现象。经济上的成功可以推迟民主时刻，但最终无法取代它。</p><p><strong>中文版译文</strong></p><p>当然，像新加坡证明了可以在有限自由的情况下实现富足的物质生活——然而大量证据表明这是例外而不是通则。经济成功会延迟民主化的到来，但最终而言不能取代它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原文摘抄&quot;&gt;&lt;a href=&quot;#原文摘抄&quot; class=&quot;headerlink&quot; title=&quot;原文摘抄&quot;&gt;&lt;/a&gt;原文摘抄&lt;/h1&gt;&lt;h2 id=&quot;引言-统治的规则&quot;&gt;&lt;a href=&quot;#引言-统治的规则&quot; class=&quot;headerlink&quot; title=&quot;引</summary>
      
    
    
    
    
    <category term="政治" scheme="https://hahahaha123567.github.io/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis的key里的大括号会影响指令的路由</title>
    <link href="https://hahahaha123567.github.io/2024-03-20-Redis%E7%9A%84key%E9%87%8C%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8C%87%E4%BB%A4%E7%9A%84%E8%B7%AF%E7%94%B1.html"/>
    <id>https://hahahaha123567.github.io/2024-03-20-Redis%E7%9A%84key%E9%87%8C%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8C%87%E4%BB%A4%E7%9A%84%E8%B7%AF%E7%94%B1.html</id>
    <published>2024-03-20T06:30:00.000Z</published>
    <updated>2024-03-20T06:54:41.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>系统压测时发现Redis集群的某个节点出现CPU过高的情况，使用Redis阿里云控制台的[实时TopKey统计]功能发现某一高频写Redis的功能使用的几个key都被路由到了同一个Redis节点，key形如</p><ul><li>{cache}:::table_name:::field1</li><li>{cache}:::table_name:::field2</li></ul><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>阿里云提供了一些文档进行Redis的基本的性能优化 <a href="https://help.aliyun.com/zh/redis/user-guide/performance-optimization/">性能调优_云数据库 Redis 版(Redis)-阿里云帮助中心</a> 但是显然多个高频写的key被路由到同一个节点导致CPU升高的问题不是Redis自身的优化能够解决的</p><p>阿里云的Redis集群是Redis cluster的实现，查询Redis cluster的文档后发现了问题</p><p>关于Redis cluster的简要描述 <a href="https://redis.io/docs/reference/cluster-spec/#overview-of-redis-cluster-main-components">overview-of-redis-cluster-main-components</a> , Redis使用<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC16</a>算法对key进行hash, hash值再对cluster的size取模后决定路由的节点</p><p>使用 <a href="https://redis.io/commands/cluster-keyslot/">CLUSTER KEYSLOT | Redis</a> 命令查询这几个key的hash值都是相等的，为什么？</p><p><a href="https://redis.io/docs/reference/cluster-spec/#hash-tags">hash-tags</a> 哈希标签是一种确保多个键分配在同一个哈希槽中的方法。这用于在 Redis Cluster 中实现多键操作。为了实现哈希标签，在某些条件下，密钥的哈希槽的计算方式略有不同。如果密钥包含“{…}”模式，则仅对和之间的子字符串进行哈希 {处理}以获取哈希槽</p><p>样例里的几个key使用了共同的”{cache}”前缀导致Redis计算hash时只计算了”cache”这5个字符的hash值，导致几个key路由到了同一个节点</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>进行修复时要注意这几个key的读操作和写操作的服务，必要时可以对读服务进行灰度发布，保证旧的key全部被消费、写服务全部更新为新key后再全量发布读服务</p>]]></content>
    
    
    <summary type="html">Redis cluster的proxy会计算key的hash路由到不同的计算节点, 此时key里的大括号会影响的路由规则</summary>
    
    
    
    
    <category term="Java, Redis" scheme="https://hahahaha123567.github.io/tags/Java-Redis/"/>
    
  </entry>
  
  <entry>
    <title>定位dependencyManagement指定的错误版本</title>
    <link href="https://hahahaha123567.github.io/2024-02-23-%E5%AE%9A%E4%BD%8DdependencyManagement%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC.html"/>
    <id>https://hahahaha123567.github.io/2024-02-23-%E5%AE%9A%E4%BD%8DdependencyManagement%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC.html</id>
    <published>2024-02-23T03:30:00.000Z</published>
    <updated>2024-03-20T06:35:40.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>项目引入<code>shardingsphere-jdbc</code>和<code>shardingsphere-cluster-mode-repository-zookeeper</code>后启动报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: org/apache/curator/connection/StandardConnectionHandlingPolicy</span><br><span class="line">at org.apache.curator.framework.CuratorFrameworkFactory$Builder.&lt;init&gt;(CuratorFrameworkFactory.java:147)</span><br><span class="line">at org.apache.curator.framework.CuratorFrameworkFactory$Builder.&lt;init&gt;(CuratorFrameworkFactory.java:130)</span><br><span class="line">at org.apache.curator.framework.CuratorFrameworkFactory.builder(CuratorFrameworkFactory.java:78)</span><br><span class="line">at org.apache.shardingsphere.mode.repository.cluster.zookeeper.ZookeeperRepository.&lt;init&gt;(ZookeeperRepository.java:65)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:380)</span><br><span class="line">... 90 common frames omitted</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.apache.curator.connection.StandardConnectionHandlingPolicy</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:387)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:419)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:352)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:352)</span><br><span class="line">... 100 common frames omitted</span><br></pre></td></tr></table></figure><p>可以看到<code>CuratorFrameworkFactory</code>类中引用的<code>StandardConnectionHandlingPolicy</code>没有被找到</p><p>项目的<code>pom.xml</code>配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mvn-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-cluster-mode-repository-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-cluster-mode-repository-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>shardingsphere-cluster-mode-repository-zookeeper</code>会引入依赖<code>curator-framework</code> <code>curator-client</code> <code>curator-recipes</code></p><h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>按照经验, 出现依赖项冲突后执行<code>mvn dependency:tree &gt; tree</code>后检查依赖树发现了奇怪的现象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[INFO] org.example:mvn-test:jar:1.0.0-SNAPSHOT</span><br><span class="line">[INFO] +- org.apache.shardingsphere:shardingsphere-jdbc-core:jar:5.4.1:compile</span><br><span class="line">[INFO] \- org.apache.shardingsphere:shardingsphere-cluster-mode-repository-zookeeper:jar:5.4.1:compile</span><br><span class="line">[INFO]    +- org.apache.shardingsphere:shardingsphere-cluster-mode-repository-api:jar:5.4.1:compile</span><br><span class="line">[INFO]    +- org.apache.curator:curator-framework:jar:4.0.1:compile</span><br><span class="line">[INFO]    +- org.apache.curator:curator-client:jar:5.5.0:compile</span><br><span class="line">[INFO]    |  \- org.apache.zookeeper:zookeeper:jar:3.7.1:compile</span><br><span class="line">[INFO]    \- org.apache.curator:curator-recipes:jar:4.0.1:compile</span><br></pre></td></tr></table></figure><p>5.4.1版本的<code>shardingsphere-cluster-mode-repository-zookeeper</code>引入的<code>curator-client</code>是正确版本5.5.0, 但是<code>curator-framework</code>和<code>curator-recipes</code>都是错误的旧版本4.0.1</p><p>检查了<code>shardingsphere-cluster-mode-repository-zookeeper</code>的pom文件后确认curator的几个库期望结果应该均为5.5.0</p><p>控制变量法, <code>dependency</code>没有异常的话问题可能出在<code>dependencyManagement</code>中, 删除其他无关依赖项后发现问题出在<code>spring-cloud-dependencies</code>中, 定位具体原因的话需要使用<code>mvn help:effective-pom</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:effective-pom &gt; effective.pom</span><br></pre></td></tr></table></figure><p>输出的文件中, 配置的<code>dependencyManagement</code>会展开, 其中可以发现指定了<code>curator-framework</code>和<code>curator-recipes</code>的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p><code>dependencyManagement</code>不支持exclusion, 需要自己声明所需的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-cluster-mode-repository-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他</p><p>基于springboot的项目引入sharding-jdbc</p><p>5.0-5.2版本官方建议使用<code>shardingsphere-cluster-mode-repository-zookeeper-curator</code></p><p><a href="https://shardingsphere.apache.org/document/5.0.0/cn/user-manual/shardingsphere-jdbc/usage/governance/spring-boot-starter/">使用 Spring Boot Starter :: ShardingSphere</a></p><p>5.3版本开始</p><p><a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/java-api/mode/">模式配置 :: ShardingSphere</a></p><p><a href="https://github.com/apache/shardingsphere/issues/24258">shardingsphere-jdbc-core-spring-boot-starter,When will version 5.3.0 be released? · Issue #24258 · apache&#x2F;shardingsphere</a></p><p>参考</p><p><a href="https://maven.apache.org/plugins/maven-help-plugin/index.html">Apache Maven Help Plugin – Introduction</a></p>]]></content>
    
    
    <summary type="html">dependencyManagement 中的 spring-cloud-dependencies 导致 shardingsphere-jdbc 引入依赖的版本出错, 使用 mvn help:effective-pom 分析并解决</summary>
    
    
    
    
    <category term="Java, Maven" scheme="https://hahahaha123567.github.io/tags/Java-Maven/"/>
    
  </entry>
  
  <entry>
    <title>Virtual Threads虚拟线程(译)</title>
    <link href="https://hahahaha123567.github.io/2023-10-07-VirtualThreads%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B(%E8%AF%91).html"/>
    <id>https://hahahaha123567.github.io/2023-10-07-VirtualThreads%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B(%E8%AF%91).html</id>
    <published>2023-10-07T04:00:00.000Z</published>
    <updated>2024-02-23T03:30:38.459Z</updated>
    
    <content type="html"><![CDATA[<p>原文 <a href="https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html">Virtual Threads</a></p><hr><p>Virtual threads 虚拟线程是轻量级的线程，可以减少编写、维护和调试高吞吐量并发应用程序的工作量</p><p>有关 Virtual Threads 的背景信息，请参阅 <a href="https://openjdk.org/jeps/444">JEP 444</a></p><p>thread是可调度的最小处理单元，thread之间同时（并且独立）运行</p><p>thread有两种，Platform Threads 平台线程和 Virtual Threads 虚拟线程</p><h1 id="Platform-Threads-是什么"><a href="#Platform-Threads-是什么" class="headerlink" title="Platform Threads 是什么"></a>Platform Threads 是什么</h1><p>Platform Threads 是操作系统 (OS) 线程的简单封装，在底层OS线程上运行 Java 代码，因此 Platform Threads 的可用数量受限于OS线程的数量</p><p>Platform Threads 通常具有大型线程堆栈和由OS维护的其他资源，适合运行所有类型的任务，但资源有限</p><h1 id="Virtual-Threads-是什么"><a href="#Virtual-Threads-是什么" class="headerlink" title="Virtual Threads 是什么"></a>Virtual Threads 是什么</h1><p>与 Platform Threads 一样，Virtual Threads 也是 java.lang.Thread 的一个实例。 但是，Virtual Threads 并不依赖于特定的OS线程。Virtual Threads 仍然在OS线程上运行，但是当 Virtual Thread 中运行的代码调用阻塞 I&#x2F;O 操作时，Java 运行时会挂起 Virtual Threads，直到可以恢复为止。与挂起的 Virtual Thread 关联的OS线程现在可以自由地为其他 Virtual Threads 执行操作</p><p>Virtual Thread 的实现方式与虚拟内存类似。为了模拟大量内存，操作系统将较大的虚拟地址空间映射到有限的 RAM。同样，为了模拟大量线程，Java运行时将大量 Virtual Threads 映射到少量OS线程。</p><p>与 Platform Thread 不同，Virtual Threads 通常具有浅调用堆栈，只执行单个 HTTP 客户端调用或单个 JDBC 查询。 尽管Virtual Threads 支持线程本地变量和可继承的线程本地变量，但您应该仔细考虑使用它们，因为单个 JVM 可能支持数百万个 Virtual Threads</p><p>Virtual Threads 适合运行大部分时间处于阻塞状态、通常等待 I&#x2F;O 操作完成的任务，不适用于长时间运行的 CPU 密集型操作</p><h1 id="为什么要使用-Virtual-Threads"><a href="#为什么要使用-Virtual-Threads" class="headerlink" title="为什么要使用 Virtual Threads"></a>为什么要使用 Virtual Threads</h1><p>在高并发IO应用程序中使用 Virtual Threads，尤其是那些包含大量并发任务且大部分时间都在等待的应用程序。服务器应用程序是高吞吐量应用程序的示例，因为它们通常处理许多执行阻塞 I&#x2F;O 操作（例如获取资源）的客户端请求</p><p>Virtual Threads 运行代码的速度并不比 Platform Threads 快。 它们的存在是为了提供scale规模（更高的吞吐量），而不是速度（更低的延迟）</p><h1 id="创建并运行-Virtual-Thread"><a href="#创建并运行-Virtual-Thread" class="headerlink" title="创建并运行 Virtual Thread"></a>创建并运行 Virtual Thread</h1><p>Thread 和 Thread.Builder API 提供了创建 Platform Thread 和 Virtual Threads 的方法。</p><p>java.util.concurrent.Executors 类还定义了创建 ExecutorService 的方法，该服务为每个任务启动一个新的 Virtual Threads</p><h2 id="使用-Thread-类和-Thread-Builder-接口创建-Virtual-Threads"><a href="#使用-Thread-类和-Thread-Builder-接口创建-Virtual-Threads" class="headerlink" title="使用 Thread 类和 Thread.Builder 接口创建 Virtual Threads"></a>使用 Thread 类和 Thread.Builder 接口创建 Virtual Threads</h2><p>调用 Thread.ofVirtual() 方法创建 Thread.Builder 实例来创建 Virtual Threads</p><p>以下示例创建并启动一个打印消息的 Virtual Threads。 它调用 join 方法来等待 Virtual Threads 终止（这使您能够在主线程终止之前看到打印的消息）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.ofVirtual().start(() -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure><h3 id="Thread-Builder-接口允许您创建具有常见线程属性（例如线程名称）的线程。-Thread-Builder-OfPlatform-子接口创建-Platform-Threads，而-Thread-Builder-OfVirtual-创建-Virtual-Threads"><a href="#Thread-Builder-接口允许您创建具有常见线程属性（例如线程名称）的线程。-Thread-Builder-OfPlatform-子接口创建-Platform-Threads，而-Thread-Builder-OfVirtual-创建-Virtual-Threads" class="headerlink" title="Thread.Builder 接口允许您创建具有常见线程属性（例如线程名称）的线程。 Thread.Builder.OfPlatform 子接口创建 Platform Threads，而 Thread.Builder.OfVirtual 创建 Virtual Threads"></a>Thread.Builder 接口允许您创建具有常见线程属性（例如线程名称）的线程。 Thread.Builder.OfPlatform 子接口创建 Platform Threads，而 Thread.Builder.OfVirtual 创建 Virtual Threads</h3><p>以下示例使用 Thread.Builder 接口创建一个名为 MyThread 的 Virtual Threads</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Running thread&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> builder.start(task);</span><br><span class="line">System.out.println(<span class="string">&quot;Thread t name: &quot;</span> + t.getName());</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure><p>以下示例使用 Thread.Builder 创建并启动两个 Virtual Threads</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;worker-&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Thread ID: &quot;</span> + Thread.currentThread().threadId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// name &quot;worker-0&quot;</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> builder.start(task);   </span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(t1.getName() + <span class="string">&quot; terminated&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name &quot;worker-1&quot;</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> builder.start(task);   </span><br><span class="line">t2.join();  </span><br><span class="line">System.out.println(t2.getName() + <span class="string">&quot; terminated&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 21</span><br><span class="line">worker-0 terminated</span><br><span class="line">Thread ID: 24</span><br><span class="line">worker-1 terminated</span><br></pre></td></tr></table></figure><h2 id="使用-Executors-newVirtualThreadPerTaskExecutor-方法创建并运行-Virtual-Threads"><a href="#使用-Executors-newVirtualThreadPerTaskExecutor-方法创建并运行-Virtual-Threads" class="headerlink" title="使用 Executors.newVirtualThreadPerTaskExecutor() 方法创建并运行 Virtual Threads"></a>使用 Executors.newVirtualThreadPerTaskExecutor() 方法创建并运行 Virtual Threads</h2><p>Executors 允许您将线程的管理和创建与应用程序的其余部分分开。</p><p>以下示例使用 Executors.newVirtualThreadPerTaskExecutor() 方法创建 ExecutorService。 每当调用 ExecutorService.submit(Runnable) 时，就会创建一个新的 Virtual Thread 并开始运行任务。 该方法返回一个 Future 的实例。 请注意，Future.get() 方法等待线程任务完成。 因此，一旦 Virtual Threads 的任务完成，此示例就会打印一条消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">myExecutor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    Future&lt;?&gt; future = myExecutor.submit(() -&gt; System.out.println(<span class="string">&quot;Running thread&quot;</span>));</span><br><span class="line">    future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;Task completed&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程-Client-Server-示例"><a href="#多线程-Client-Server-示例" class="headerlink" title="多线程 Client Server 示例"></a>多线程 Client Server 示例</h2><p>以下示例由两个类组成。 EchoServer 是一个服务器程序，它监听端口并为每个连接启动一个新的 Virtual Thread</p><p>EchoClient 是一个客户端程序，它连接到服务器并发送在命令行中输入的消息</p><p>EchoClient 创建一个 Socket，从而获得与 EchoServer 的连接。 它在标准输入流上读取用户的输入，然后通过将文本写入 Socket 来将该文本转发到 EchoServer。 EchoServer 通过 Socket 将输入回显给 EchoClient。 EchoClient 读取并显示从服务器传回给它的数据。 EchoServer 可以通过 Virtual Threads 同时为多个客户端提供服务，每个客户端连接一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage: java EchoServer &lt;port&gt;&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">portNumber</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(Integer.parseInt(args[<span class="number">0</span>]));</span><br><span class="line">        ) &#123;                </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">// Accept incoming connections</span></span><br><span class="line">                <span class="comment">// Start a service thread</span></span><br><span class="line">                Thread.ofVirtual().start(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> (</span><br><span class="line">                        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">                        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(clientSocket.getInputStream()));</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        String inputLine;</span><br><span class="line">                        <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            System.out.println(inputLine);</span><br><span class="line">                            out.println(inputLine);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception caught when trying to listen on port &quot;</span></span><br><span class="line">                + portNumber + <span class="string">&quot; or listening for a connection&quot;</span>);</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage: java EchoClient &lt;hostname&gt; &lt;port&gt;&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">portNumber</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">echoSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(hostName, portNumber);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(echoSocket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(echoSocket.getInputStream()));</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">stdIn</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            String userInput;</span><br><span class="line">            <span class="keyword">while</span> ((userInput = stdIn.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                out.println(userInput);</span><br><span class="line">                System.out.println(<span class="string">&quot;echo: &quot;</span> + in.readLine());</span><br><span class="line">                <span class="keyword">if</span> (userInput.equals(<span class="string">&quot;bye&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Don&#x27;t know about host &quot;</span> + hostName);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Couldn&#x27;t get I/O for the connection to &quot;</span> + hostName);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Virtual-Threads-的调度和固定（pin）"><a href="#Virtual-Threads-的调度和固定（pin）" class="headerlink" title="Virtual Threads 的调度和固定（pin）"></a>Virtual Threads 的调度和固定（pin）</h2><p>OS调度 platform threads 何时运行。 但是，Java 运行时会调度 virtual threads 的运行时间。 当Java运行时调度 virtual threads 时，它会在 platform threads 上分配或安装 virtual threads，然后OS照常调度该 platform threads。 该 platform threads 称为 carrier 载体。运行一些代码后，virtual threads 可以从其 carrier 上卸载。 这通常发生在 virtual threads 执行阻塞 I&#x2F;O 操作时。Virtual threads 从其 carrier 上卸载后，carrier 就空闲了，这意味着Java运行时调度程序可以在其上挂载不同的 virtual threads</p><p>当 virtual thread 固定到其 carrier 时，无法在阻塞操作期间卸载该 virtual thread。Virtual threads 在以下情况下被固定</p><ol><li><p>Virtual threads 在同步块或方法内运行代码</p></li><li><p>Virtual threads 运行 native 方法或 foreign 函数（请参阅外部函数和内存 API）</p></li></ol><p>固定不会使应用程序不正确，但可能会妨碍其可扩展性。 尝试通过修改频繁运行的同步块或方法并使用 java.util.concurrent.locks.ReentrantLock 给潜在的长 I&#x2F;O 操作加锁来避免频繁且长期的固定</p><h1 id="Debugging-Virtual-Threads"><a href="#Debugging-Virtual-Threads" class="headerlink" title="Debugging Virtual Threads"></a>Debugging Virtual Threads</h1><p>Virtual Threads 仍然是 thread, debugger 可以像 platform thread 一样单步调试它们。Java Flight Recorder 和 jcmd 工具具有附加功能，可帮助您观察应用程序中的 Virtual Threads</p><h2 id="Virtual-Threads-的-Java-Flight-Recorder-事件"><a href="#Virtual-Threads-的-Java-Flight-Recorder-事件" class="headerlink" title="Virtual Threads 的 Java Flight Recorder 事件"></a>Virtual Threads 的 Java Flight Recorder 事件</h2><p>Java Flight Recorder (JFR) 可以发出与 Virtual Threads 相关的以下事件：</p><ul><li><p>jdk.VirtualThreadStart 和 jdk.VirtualThreadEnd 指示 Virtual Threads 何时开始和结束。 默认情况下禁用这些事件。</p></li><li><p>jdk.VirtualThreadPinned 指示 Virtual Threads 被固定（并且其载体线程未释放）的时间超过阈值持续时间。 默认情况下启用此事件，阈值为 20 毫秒。</p></li><li><p>jdk.VirtualThreadSubmitFailed 表示启动或取消停放 Virtual Threads 失败，可能是由于资源问题。 停放 Virtual Threads 会释放底层承载线程以执行其他工作，而取消停放 Virtual Threads 会安排其继续。 该事件默认启用。</p></li></ul><p>通过 JDK Mission Control 或使用自定义 JFR 配置启用事件 jdk.VirtualThreadStart 和 jdk.VirtualThreadEnd，如 Java 平台标准版 Flight Recorder API 程序员指南中的 Flight Recorder 配置中所述。</p><p>要打印这些事件，请运行以下命令，其中recording.jfr 是录制文件的文件名：</p><p>jfr print –events jdk.VirtualThreadStart,jdk.VirtualThreadEnd,jdk.VirtualThreadPinned,jdk.VirtualThreadSubmitFailed recording.jfr</p><h2 id="查看-jcmd-线程-dump-中的-virtual-threads"><a href="#查看-jcmd-线程-dump-中的-virtual-threads" class="headerlink" title="查看 jcmd 线程 dump 中的 virtual threads"></a>查看 jcmd 线程 dump 中的 virtual threads</h2><p>您可以以纯文本和 JSON 格式创建线程dump：</p><p>jcmd <PID> Thread.dump_to_file -format&#x3D;text <file></p><p>jcmd <PID> Thread.dump_to_file -format&#x3D;json <file></p><p>jcmd 线程转储列出了网络 I&#x2F;O 操作中被阻塞的 virtual threads 以及 ExecutorService 接口创建的 virtual threads。 它不包括对象地址、锁、JNI 统计信息、堆统计信息以及传统线程dump中出现的其他信息</p><h1 id="Virtual-Threads-采用指南"><a href="#Virtual-Threads-采用指南" class="headerlink" title="Virtual Threads 采用指南"></a>Virtual Threads 采用指南</h1><p>Virtual Threads 是由 Java 运行时而不是OS实现的 Java 线程。Virtual Threads 和传统线程（我们称之为 Platform Threads）之间的主要区别在于，我们可以轻松地在同一个 Java 进程中运行大量活动 Virtual Threads，甚至数百万个。Virtual Threads 的数量众多，赋予了 Virtual Threads 强大的力量：通过允许服务器同时处理更多请求，它们可以更有效地运行以 thread-per-request 风格编写的服务器应用程序，从而提高吞吐量并减少硬件浪费。</p><p>由于 Virtual Threads 是 java.lang.Thread 的实现，并且遵守自 Java SE 1.0 以来指定 java.lang.Thread 的相同规则，因此开发人员无需学习新概念即可使用它们。 然而，由于无法生成大量 Platform Threads （多年来 Java 中唯一可用的线程实现），已经产生了旨在应对其高成本的实践。 这些做法在应用于 Virtual Threads 时会适得其反，必须摒弃。 此外，成本上的巨大差异提供了一种新的思考线程的方式，而这些线程一开始可能是陌生的。</p><p>本指南无意全面涵盖 Virtual Threads 的每个重要细节。 其目的只是提供一套介绍性指南，以帮助那些希望开始使用 Virtual Threads 的人充分利用它们。</p><h2 id="使用阻塞-I-x2F-O-API-以-thread-per-request-的方式编写简单的同步代码"><a href="#使用阻塞-I-x2F-O-API-以-thread-per-request-的方式编写简单的同步代码" class="headerlink" title="使用阻塞 I&#x2F;O API 以 thread-per-request 的方式编写简单的同步代码"></a>使用阻塞 I&#x2F;O API 以 thread-per-request 的方式编写简单的同步代码</h2><p>Virtual Threads 可以显著提高以 thread-per-request 风格编写的服务器的吞吐量（而不是延迟）。 在这种风格中，服务器专用一个线程在整个持续时间内处理每个传入请求。 它至少专用一个线程，因为在处理单个请求时，您可能希望使用更多线程来同时执行某些任务。</p><p>阻塞 Platform Threads 的成本很高，因为它保留了线程（一种相对稀缺的资源），而它没有做太多有意义的工作。 因为 Virtual Threads 可能很丰富，所以阻塞它们是廉价的并且值得鼓励。 因此，您应该以简单的同步风格编写代码并使用阻塞 I&#x2F;O API</p><p>例如，以下以非阻塞异步风格编写的代码不会从 Virtual Threads 中受益太多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(info::getUrl, pool)</span><br><span class="line">   .thenCompose(url -&gt; getBodyAsync(url, HttpResponse.BodyHandlers.ofString()))</span><br><span class="line">   .thenApply(info::findImage)</span><br><span class="line">   .thenCompose(url -&gt; getBodyAsync(url, HttpResponse.BodyHandlers.ofByteArray()))</span><br><span class="line">   .thenApply(info::setImageData)</span><br><span class="line">   .thenAccept(<span class="built_in">this</span>::process)</span><br><span class="line">   .exceptionally(t -&gt; &#123; t.printStackTrace(); <span class="keyword">return</span> <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure><p>另一方面，以下以同步风格编写并使用简单阻塞 IO 的代码将受益匪浅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">page</span> <span class="operator">=</span> getBody(info.getUrl(), HttpResponse.BodyHandlers.ofString());</span><br><span class="line">   <span class="type">String</span> <span class="variable">imageUrl</span> <span class="operator">=</span> info.findImage(page);</span><br><span class="line">   <span class="type">byte</span>[] data = getBody(imageUrl, HttpResponse.BodyHandlers.ofByteArray());   </span><br><span class="line">   info.setImageData(data);</span><br><span class="line">   process(info);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">   t.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类代码也更容易在调试器中调试、在分析器中分析或通过线程dump进行观察。要观察 virtual thread，请使用 jcmd 命令创建线程dump：</p><p><code>jcmd &lt;pid&gt; Thread.dump_to_file -format=json &lt;文件&gt;</code></p><p>以这种方式编写的堆栈越多， virtual threads 的性能和可观察性就越好。 以其他风格编写的程序或框架，如果每个任务没有专用一个线程，则不应期望从  virtual threads 中获得显著的好处。 避免将同步、阻塞代码与异步框架混合</p><h2 id="将每个并发任务表示为一个-Virtual-Thread-不池化-Virtual-Threads"><a href="#将每个并发任务表示为一个-Virtual-Thread-不池化-Virtual-Threads" class="headerlink" title="将每个并发任务表示为一个 Virtual Thread, 不池化 Virtual Threads"></a>将每个并发任务表示为一个 Virtual Thread, 不池化 Virtual Threads</h2><p>关于 Virtual Threads 最难理解的事情是，虽然它们具有与 Platform Threads 相同的行为，但它们不应该代表相同的程序概念</p><p> Platform Threads 稀缺，因此是宝贵的资源。 宝贵的资源需要管理，管理 Platform Threads 最常见的方法是使用线程池。 然后您需要回答的一个问题是，池中应该有多少个线程？</p><p>但 Virtual Threads 非常丰富，因此每个 Virtual Threads 不应代表某些共享的、池化的资源，而应代表一个任务。 线程从托管资源转变为应用程序域对象。 我们应该有多少个 Virtual Threads 的问题变得显而易见，就像我们应该使用多少个字符串在内存中存储一组用户名的问题一样显而易见：在您的应用程序中，Virtual Threads 的数量始终等于并发任务的数量</p><p>将 n 个平台线程转换为 n 个 Virtual Threads 不会产生什么好处；相反，它是需要转换的任务</p><p>要将每个应用程序任务表示为一个线程，请不要使用共享线程池执行器，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;ResultA&gt; f1 = sharedThreadPoolExecutor.submit(task1);</span><br><span class="line">Future&lt;ResultB&gt; f2 = sharedThreadPoolExecutor.submit(task2);</span><br><span class="line"><span class="comment">// ... use futures</span></span><br></pre></td></tr></table></figure><p>相反，请使用 Virtual Threads 执行器，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">   Future&lt;ResultA&gt; f1 = executor.submit(task1);</span><br><span class="line">   Future&lt;ResultB&gt; f2 = executor.submit(task2);</span><br><span class="line">   <span class="comment">// ... use futures</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码仍然使用 ExecutorService，但从 Executors.newVirtualThreadPerTaskExecutor() 返回的 service 不使用线程池。 相反，它为每个提交的任务创建一个新的 Vritual Thread</p><p>此外，ExecutorService 本身是轻量级的，我们可以像创建任何简单对象一样创建一个新的。这使我们能够依赖新添加的 ExecutorService.close() 方法和 try-with-resources 构造。 在 try 块末尾隐式调用的 close 方法将自动等待提交给 ExecutorService 的所有任务（即 ExecutorService 生成的所有 Virtual Threads）终止</p><p>对于扇出（fanout）场景来说，这是一种特别有用的模式，在这种场景中，您希望同时对不同的服务执行多个传出调用，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Request request, Response response)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">url1</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">var</span> <span class="variable">url2</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">future1</span> <span class="operator">=</span> executor.submit(() -&gt; fetchURL(url1));</span><br><span class="line">        <span class="type">var</span> <span class="variable">future2</span> <span class="operator">=</span> executor.submit(() -&gt; fetchURL(url2));</span><br><span class="line">        response.send(future1.get() + future2.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">        response.fail(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">fetchURL</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> url.openStream()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(in.readAllBytes(), StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，您应该为即使是小型、短期的并发任务创建一个新的 Vritual Thread</p><p>为了获得更多帮助编写扇出（fanout）模式和其他常见并发模式，并具有更好的可观察性，请使用结构化并发（structured concurrency）</p><p>根据经验，如果您的应用程序从未拥有 10,000 个或更多 Vritual Threads，则它不太可能从 Vritual Threads 中受益。 要么它的负载太轻而需要更高的吞吐量，要么您没有向 Vritual Threads 表示足够多的任务</p><h2 id="用-Semaphores-限制并发"><a href="#用-Semaphores-限制并发" class="headerlink" title="用 Semaphores 限制并发"></a>用 Semaphores 限制并发</h2><p>有时需要限制某个操作的并发数。 例如，某些外部服务可能无法处理超过 10 个并发请求。 由于 Platform Threads 是一种宝贵的资源，通常在池中进行管理，因此线程池已经变得如此普遍，以至于它们被用于限制并发的目的，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">...</span><br><span class="line">Result <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">fut</span> <span class="operator">=</span> es.submit(() -&gt; callLimitedService());</span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例确保有限服务最多有 10 个并发请求</p><p>但限制并发只是线程池操作的副作用。 池旨在共享稀缺资源，而 Virtual Threads 并不稀缺，因此永远不应该池化！</p><p>使用 Virtual Threads 时，如果要限制访问某些服务的并发性，则应该使用专门为此目的设计的构造：Semaphore 类。 下面的例子演示了这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line">...</span><br><span class="line">Result <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> callLimitedService();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 foo 的线程将被阻塞，因此一次只有 10 个线程可以取得进展，而其他线程将不受阻碍地继续自己的业务</p><p>简单地使用信号量阻塞某些 Virtual Threads 可能看起来与将任务提交到固定线程池有很大不同，但事实并非如此。 将任务提交到线程池会将它们排队以供稍后执行，但内部信号量（或与此相关的任何其他阻塞同步构造）会创建一个在其上阻塞的线程队列，该队列镜像等待池线程执行的任务队列来执行。 因为 Virtual Threads 是任务，所以结果结构是等效的</p><p><img src="https://docs.oracle.com/en/java/javase/21/core/img/java-core-libraries-virtual-threads-thread-pool-and-semaphore.png" alt="线程池与信号量的比较"></p><p>尽管您可以将 Platform Threads 池视为处理从队列中提取的任务的工作人员，并将 Virtual Threads 视为任务本身，在它们可以继续之前被阻塞，但计算机中的底层表示实际上是相同的。 认识排队任务和阻塞线程之间的等效性将帮助您充分利用 Virtual Threads</p><p>数据库连接池本身充当信号量。 连接池限制为十个连接将阻止第十一个线程尝试获取连接。 无需在连接池之上添加额外的信号量</p><h2 id="不要在线程局部变量中缓存昂贵的可重用对象"><a href="#不要在线程局部变量中缓存昂贵的可重用对象" class="headerlink" title="不要在线程局部变量中缓存昂贵的可重用对象"></a>不要在线程局部变量中缓存昂贵的可重用对象</h2><p>Virtual Threads 支持线程局部变量，就像平台线程一样。 有关详细信息，请参阅线程局部变量。 通常，线程局部变量用于将一些特定于上下文的信息与当前运行的代码关联起来，例如当前事务和用户ID。 对于 Virtual Threads 来说，线程局部变量的使用是完全合理的。 但是，请考虑使用更安全、更有效的范围值。 有关详细信息，请参阅范围值。</p><p>线程局部变量的另一种用途与 Virtual Threads 根本上是不一致的：缓存可重用对象。 这些对象的创建成本通常很高（并且消耗大量内存），并且是可变的，并且不是线程安全的。 它们被缓存在线程局部变量中，以减少它们实例化的次数以及它们在内存中的实例数量，但它们可以被线程上不同时间运行的多个任务重用。</p><p>例如，SimpleDateFormat 的实例创建成本很高，而且不是线程安全的。 出现的一种模式是将此类实例缓存在 ThreadLocal 中，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; cachedFormatter = ThreadLocal.withInitial(SimpleDateFormat::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">        cachedFormatter.get().format(...);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅当线程（以及因此在线程本地缓存的昂贵对象）被多个任务共享和重用时（就像平台线程被池化时的情况一样），这种缓存才有用。 许多任务在线程池中运行时可能会调用 foo，但由于池中仅包含几个线程，因此该对象只会被实例化几次（每个池线程一次）并被缓存和重用。</p><p>但是，Virtual Threads 永远不会被池化，也不会被不相关的任务重用。 因为每个任务都有自己的 Virtual hreads ，所以每次从不同任务调用 foo 都会触发新 SimpleDateFormat 的实例化。 而且，由于可能有大量的 Virtual Threads 同时运行，昂贵的对象可能会消耗相当多的内存。 这些结果与线程本地缓存想要实现的结果恰恰相反。</p><p>没有提供单一的通用替代方案，但对于 SimpleDateFormat，您应该将其替换为 DateTimeFormatter，DateTimeFormatter 是不可变的，因此单个实例可以由所有线程共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter….;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">        formatter.format(...);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，使用线程局部变量来缓存共享的昂贵对象有时是由异步框架在幕后完成的，其隐含的假设是它们由极少数池线程使用。 这就是为什么混合 Virtual Threads 和异步框架不是一个好主意的原因之一：对方法的调用可能会导致在本来要缓存和共享的线程局部变量中实例化昂贵的对象</p><h2 id="避免长时间和频繁的固定"><a href="#避免长时间和频繁的固定" class="headerlink" title="避免长时间和频繁的固定"></a>避免长时间和频繁的固定</h2><p>当前 Virtual Threads 实现的一个限制是，在同步块或方法内执行阻塞操作会导致 JDK 的 Virtual Threads 调度程序阻塞宝贵的OS线程，而如果阻塞操作是在同步块之外完成则不会，我们称这种情况为“固定”。 如果阻塞操作既长期又频繁，则固定可能会对服务器的吞吐量产生不利影响。 保护短期操作（例如内存中操作）或使用同步块或方法的不频繁操作应该不会产生不利影响。</p><p>为了检测可能有害的固定实例，（JDK Flight Recorder (JFR) 在固定阻塞操作时发出 jdk.VirtualThreadPinned 线程；默认情况下，当操作时间超过 20 毫秒时启用此事件</p><p>或者，您可以使用系统属性 jdk.tracePinnedThreads 在线程被固定时阻塞时发出堆栈跟踪。 使用选项 -Djdk.tracePinnedThreads&#x3D;full 运行会在线程被固定时阻塞时打印完整的堆栈跟踪，突出显示本机帧和持有监视器的帧。 使用选项 -Djdk.tracePinnedThreads&#x3D;short 运行将输出限制为仅有问题的帧。</p><p>如果这些机制检测到固定既长期又频繁的地方，请在这些特定地方将同步的使用替换为 ReentrantLock（同样，无需在保护短期或不频繁操作的地方替换同步）。 以下是长期且频繁使用同步块的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lockObj) &#123;</span><br><span class="line">    frequentIO();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以将其替换为以下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    frequentIO();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Oracle文档翻译</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="并发" scheme="https://hahahaha123567.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="JDK21" scheme="https://hahahaha123567.github.io/tags/JDK21/"/>
    
  </entry>
  
  <entry>
    <title>Virtual Threads背景和影响</title>
    <link href="https://hahahaha123567.github.io/2023-09-27-VirtualThreads%E8%83%8C%E6%99%AF%E5%92%8C%E5%BD%B1%E5%93%8D.html"/>
    <id>https://hahahaha123567.github.io/2023-09-27-VirtualThreads%E8%83%8C%E6%99%AF%E5%92%8C%E5%BD%B1%E5%93%8D.html</id>
    <published>2023-09-27T04:00:00.000Z</published>
    <updated>2024-02-23T03:31:02.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="JEP-JDK-Enhancement-Proposals-推进"><a href="#JEP-JDK-Enhancement-Proposals-推进" class="headerlink" title="JEP(JDK Enhancement Proposals)推进"></a>JEP(JDK Enhancement Proposals)推进</h2><p>将虚拟线程引入Java 平台。虚拟线程是轻量级线程，可以显著减少编写、维护和观察高吞吐量并发应用程序的工作量</p><ul><li><p>使以简单的每个请求线程风格编写的服务器应用程序能够以接近最佳的硬件利用率进行扩展</p></li><li><p>使使用 java.lang.Thread API 的现有代码能够以最小的更改采用虚拟线程</p></li><li><p>使用现有 JDK 工具轻松进行虚拟线程故障排除、调试和分析</p></li></ul><p>2022-09-20 Java19发布, virtual threads作为preview功能发布 <a href="https://openjdk.org/jeps/425">https://openjdk.org/jeps/425</a></p><p>2023-03-21 Java20发布, virtual threads作为second preview预览功能发布 <a href="https://openjdk.org/jeps/436">https://openjdk.org/jeps/436</a></p><p>2023-09-19 Java21(LTS)发布, virtual threads正式发布 <a href="https://openjdk.org/jeps/444">https://openjdk.org/jeps/444</a></p><h2 id="Loom"><a href="#Loom" class="headerlink" title="Loom"></a>Loom</h2><p>Loom 是一个OpenJDK的项目，旨在探索、孵化和交付构建在其之上的 Java VM 功能和 API，以支持 Java 平台上易于使用、高吞吐量的轻量级并发和新的编程模型</p><p>主要包含2部分</p><ol><li><p>Virtual threads</p></li><li><p>Structured concurrency</p></li></ol><p><a href="https://wiki.openjdk.org/display/loom">https://wiki.openjdk.org/display/loom</a></p><h2 id="Structured-Concurrency-结构化并发"><a href="#Structured-Concurrency-结构化并发" class="headerlink" title="Structured Concurrency 结构化并发"></a>Structured Concurrency 结构化并发</h2><p>通过引入结构化并发 API 来简化并发编程。结构化并发将在不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消、提高可靠性并增强可观察性</p><p>2022-09-20 Java19发布, structured concurrency作为Incubator开始孵化 <a href="https://openjdk.org/jeps/428">https://openjdk.org/jeps/428</a></p><p>2023-03-21 Java20发布, structured concurrency作为Second Incubator <a href="https://openjdk.org/jeps/437">https://openjdk.org/jeps/437</a></p><p>2023-09-19 Java21(LTS)发布, structured concurrency作为preview功能发布 <a href="https://openjdk.org/jeps/453">https://openjdk.org/jeps/453</a></p><h1 id="对开发的影响"><a href="#对开发的影响" class="headerlink" title="对开发的影响"></a>对开发的影响</h1><h2 id="框架开发or应用开发"><a href="#框架开发or应用开发" class="headerlink" title="框架开发or应用开发"></a>框架开发or应用开发</h2><p>对于使用线程或并行的库和框架来说，将是一件大事。库作者能够实现巨大的性能和可扩展性提升，同时简化代码库，使其更易维护。大多数使用线程池和平台线程的 Java 项目都能够从切换至虚拟线程的过程中受益，候选项目包括 Tomcat、Undertow 和 Netty 这样的 Java 服务器软件，以及 Spring 和 Micronaut 这样的 Web 框架</p><p>不会对普通的 Java 开发人员产生太大的影响，因为这些开发人员可能正在使用某些库来处理并发的场景。但是，在一些比较罕见的场景中，比如你可能进行了大量的多线程操作但是没有使用库，那么这些特性就是很有价值的了。虚拟线程可以毫不费力地替代你现在使用的线程池。根据现有的基准测试，在大多数情况下它们都能提高性能和可扩展性</p><p><a href="https://www.infoq.cn/article/wg5qybla1ps222larj3y">https://www.infoq.cn/article/wg5qybla1ps222larj3y</a></p><h2 id="库依赖版本"><a href="#库依赖版本" class="headerlink" title="库依赖版本"></a>库依赖版本</h2><p><a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions</a></p><p><a href="https://stackoverflow.com/questions/42659920/is-there-a-compatibility-matrix-of-spring-boot-and-spring-cloud">https://stackoverflow.com/questions/42659920/is-there-a-compatibility-matrix-of-spring-boot-and-spring-cloud</a></p><h2 id="VS-反应式编程"><a href="#VS-反应式编程" class="headerlink" title="VS 反应式编程"></a>VS 反应式编程</h2><p>对于应用开发者来说，Virtual Threads 和 Reactive 的目的一样，都是对于IO密集型服务，通过提高CPU的使用率来实现提高服务的吞吐量</p><p>在Virtual Threads没有作为JEPS正式提出前，知乎上就有一些讨论，大部分人认为 Virtual Threads 这样将负担交给JVM的方式更好，而不是自己组织Reactive代码写回调</p><ul><li><p>Oracle的Reactive驱动ADBA停止开发，现在使用较多的MySQL Reactive驱动是Spring主导开发的R2DBC</p></li><li><p>loom的tech lead认为正确的方向是”Code like sync, works like async”</p></li></ul><p><a href="https://www.zhihu.com/question/67579790">如何看待Project Loom? - 知乎</a></p><p><a href="https://www.zhihu.com/question/375996978">对于后端开发，响应式编程真的是大势所趋吗？ - 知乎</a></p><h1 id="其他语言的coroutine"><a href="#其他语言的coroutine" class="headerlink" title="其他语言的coroutine"></a>其他语言的coroutine</h1><h2 id="go的goroutine"><a href="#go的goroutine" class="headerlink" title="go的goroutine"></a>go的goroutine</h2><p><a href="https://colobu.com/2016/06/27/dive-into-go-8/">深入Go语言 - 8 - colobu.com</a></p><p><a href="https://colobu.com/2016/04/19/Scheduler-Tracing-In-Go/">Go 调度器跟踪 - colobu.com</a></p><p>Go所有线程都是”虚拟线程”</p><p>Java兼容GUI、Android，Virtual Thread是Thread的子类，支持手动指定Virtual Thread pin到 Platform Thread的逻辑</p><h2 id="kotlin的coroutine"><a href="#kotlin的coroutine" class="headerlink" title="kotlin的coroutine"></a>kotlin的coroutine</h2><p><a href="https://kotlinlang.org/docs/coroutines-overview.html">Coroutines | Kotlin Documentation - kotlinlang.org</a></p><hr><p>参考文章</p><p><a href="https://juejin.cn/post/7280746515526058038">Java21手册（一）：虚拟线程 Virtual Threads - 掘金 - juejin.cn</a></p>]]></content>
    
    
    <summary type="html">Virtual Threads背景和影响</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="并发" scheme="https://hahahaha123567.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="JDK21" scheme="https://hahahaha123567.github.io/tags/JDK21/"/>
    
  </entry>
  
  <entry>
    <title>lombok的@Builder使用避雷</title>
    <link href="https://hahahaha123567.github.io/2023-07-12-%E4%BD%BF%E7%94%A8lombok%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html"/>
    <id>https://hahahaha123567.github.io/2023-07-12-%E4%BD%BF%E7%94%A8lombok%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</id>
    <published>2023-07-12T11:42:00.000Z</published>
    <updated>2024-03-22T06:13:46.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>新项目的mybatis反序列化报错, Enum类型的字段, 在mapper中指定了typeHandler但是未生效, 报错内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column &#x27;account&#x27; from result set.  Cause: java.lang.IllegalArgumentException: No enum constant com.billing.api.enums.TenantAccountEnum.0</span><br><span class="line">at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:96)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)</span><br><span class="line">at com.sun.proxy.$Proxy141.selectOne(Unknown Source)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate.selectOne(SqlSessionTemplate.java:160)</span><br><span class="line">at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:87)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86)</span><br><span class="line">at com.sun.proxy.$Proxy148.selectBySourceModuleExtendId(Unknown Source)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)</span><br><span class="line">at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212)</span><br><span class="line">at com.sun.proxy.$Proxy149.selectBySourceModuleExtendId(Unknown Source)</span><br><span class="line">at com.billing.provider.service.impl.BillServiceImpl.selectBySourceModuleExtendId(BillServiceImpl.java:25)</span><br><span class="line">at com.billing.provider.service.BillServiceTest.create(BillServiceTest.java:26)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)</span><br><span class="line">at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)</span><br><span class="line">at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)</span><br><span class="line">at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</span><br><span class="line">at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</span><br><span class="line">at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</span><br><span class="line">at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</span><br><span class="line">at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)</span><br><span class="line">at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)</span><br><span class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:137)</span><br><span class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:115)</span><br><span class="line">at org.junit.vintage.engine.execution.RunnerExecutor.execute(RunnerExecutor.java:40)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)</span><br><span class="line">at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)</span><br><span class="line">at java.util.Iterator.forEachRemaining(Iterator.java:116)</span><br><span class="line">at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)</span><br><span class="line">at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)</span><br><span class="line">at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)</span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)</span><br><span class="line">at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)</span><br><span class="line">at org.junit.vintage.engine.VintageTestEngine.executeAllChildren(VintageTestEngine.java:80)</span><br><span class="line">at org.junit.vintage.engine.VintageTestEngine.execute(VintageTestEngine.java:71)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)</span><br><span class="line">at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71)</span><br><span class="line">at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)</span><br><span class="line">at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:221)</span><br><span class="line">at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)</span><br><span class="line">Caused by: org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column &#x27;account&#x27; from result set.  Cause: java.lang.IllegalArgumentException: No enum constant com.billing.api.enums.TenantAccountEnum.0</span><br><span class="line">at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:87)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.createUsingConstructor(EnumResultSetHandler.java:705)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.createByConstructorSignature(EnumResultSetHandler.java:688)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.createResultObject(EnumResultSetHandler.java:652)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.createResultObject(EnumResultSetHandler.java:625)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.getRowValue(EnumResultSetHandler.java:375)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.handleRowValuesForSimpleResultMap(EnumResultSetHandler.java:332)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.handleRowValues(EnumResultSetHandler.java:306)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.handleResultSet(EnumResultSetHandler.java:279)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.handleResultSets(EnumResultSetHandler.java:172)</span><br><span class="line">at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:65)</span><br><span class="line">at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79)</span><br><span class="line">at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63)</span><br><span class="line">at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:325)</span><br><span class="line">at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156)</span><br><span class="line">at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109)</span><br><span class="line">at com.github.pagehelper.PageInterceptor.intercept(PageInterceptor.java:151)</span><br><span class="line">at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:62)</span><br><span class="line">at com.sun.proxy.$Proxy230.query(Unknown Source)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.apache.ibatis.plugin.Invocation.proceed(Invocation.java:49)</span><br><span class="line">at com.middleware.mysql.common.MybatisLogInterceptor.intercept(MybatisLogInterceptor.java:143)</span><br><span class="line">at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:62)</span><br><span class="line">at com.sun.proxy.$Proxy230.query(Unknown Source)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.apache.ibatis.plugin.Invocation.proceed(Invocation.java:49)</span><br><span class="line">at com.middleware.mysql.common.EnumInterceptor.intercept(EnumInterceptor.java:66)</span><br><span class="line">at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:62)</span><br><span class="line">at com.sun.proxy.$Proxy230.query(Unknown Source)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:151)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:145)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:76)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:427)</span><br><span class="line">... 68 more</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: No enum constant com.billing.api.enums.TenantAccountEnum.0</span><br><span class="line">at java.lang.Enum.valueOf(Enum.java:238)</span><br><span class="line">at org.apache.ibatis.type.EnumTypeHandler.getNullableResult(EnumTypeHandler.java:49)</span><br><span class="line">at org.apache.ibatis.type.EnumTypeHandler.getNullableResult(EnumTypeHandler.java:26)</span><br><span class="line">at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:85)</span><br><span class="line">... 111 more</span><br></pre></td></tr></table></figure><p>数据库中 <code>account</code> 为0的数据本应使用自定义的typeHandler转换为 <code>TenantAccountEnum</code> 的一个类型, 但是自定义的typeHandler未生效</p><h1 id="排查流程"><a href="#排查流程" class="headerlink" title="排查流程"></a>排查流程</h1><p>检查mybatis的配置项, typeHandler所在目录正常配置, 且mapper中显示指定了类的完整路径</p><p>打断点排查, 发现并不是在反序列化<code>account</code>字段时产生的异常, 而是在sql执行完, 创建目标对象时产生的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; resultType = resultMap.getType();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MetaClass</span> <span class="variable">metaType</span> <span class="operator">=</span> MetaClass.forClass(resultType, reflectorFactory);</span><br><span class="line">    <span class="keyword">final</span> List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span><br><span class="line">    <span class="keyword">if</span> (hasTypeHandlerForResultObject(rsw, resultType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!constructorMappings.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123;</span><br><span class="line">        <span class="keyword">return</span> objectFactory.create(resultType);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Do not know how to create an instance of &quot;</span> + resultType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 框架尝试用反射创建该对象的一个实例, 在其中一步判断<code>metaType.hasDefaultConstructor()</code>时, 代理对象返回false导致没有使用空构造函数新建实例, 后续使用反射新建实例时框架没有使用mapper中配置的typeHandler导致抛出异常</p><p>对象使用了lombok的<code>@Data</code>注解为什么会没有空构造函数?</p><p>因为又使用了<code>@Builder</code>注解</p><h1 id="lombok的这几个对象注解"><a href="#lombok的这几个对象注解" class="headerlink" title="lombok的这几个对象注解"></a>lombok的这几个对象注解</h1><p>TODO</p><p><a href="https://mp.weixin.qq.com/s/yp-lvB9A5dVBrsBT3XkICA">请谨慎使用 @Builder 注解！</a></p>]]></content>
    
    
    <summary type="html">TODO</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Encoding</title>
    <link href="https://hahahaha123567.github.io/2022-12-15-%E3%80%8A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E3%80%8B%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hahahaha123567.github.io/2022-12-15-%E3%80%8A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E3%80%8B%E7%AC%94%E8%AE%B0.html</id>
    <published>2022-12-15T03:10:00.000Z</published>
    <updated>2022-12-15T03:11:00.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h1><p>字符集：字符的集合</p><p>字符编码：字符集中的字符映射到数字序列的方式</p><h1 id="为什么计算机需要编码"><a href="#为什么计算机需要编码" class="headerlink" title="为什么计算机需要编码"></a>为什么计算机需要编码</h1><ul><li>磁盘使用凸起&#x2F;凹陷存储数据</li><li>内存使用有电荷&#x2F;无电荷</li><li>显示器不同颜色的二极管分别亮或灭</li></ul><p>二进制是为了处理这些情况抽象出来的数学逻辑</p><h1 id="字的编码"><a href="#字的编码" class="headerlink" title="字的编码"></a>字的编码</h1><ul><li>字形码: 屏幕上最终展示的字</li><li>机内码: 计算机内部存储的字符格式</li></ul><p>字形码&#x3D;机内码+字体, 换句话说, 机内码是对字形码的一种压缩</p><h1 id="字符编码演化"><a href="#字符编码演化" class="headerlink" title="字符编码演化"></a>字符编码演化</h1><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>一个字节，最高位0，剩下7位表示127个字符，控制字符和英文数字字符</p><h2 id="ISO-8859系列"><a href="#ISO-8859系列" class="headerlink" title="ISO-8859系列"></a>ISO-8859系列</h2><p>ASCII+欧洲字符</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>一套字符编码体系，涵盖抽象字符集、编号、逻辑编码、编码实现</p><p>可以容纳世界上所有国家的文字和符号，其编号范围是0-0x10FFFF，有1,114,112个码位，现已定义的码位有238,605个</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>Unicode最开始设计位双字节编码，固定16位表示一个字符，后来发现不够用，修改为变长编码，常用字符使用2字节，不常用字符使用4字节</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8是变长编码，范围1-4字节</p><p>UTF-16不兼容ASCII，UTF-8兼容ASCII</p><h2 id="GB系列"><a href="#GB系列" class="headerlink" title="GB系列"></a>GB系列</h2><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>双字节编码，两个大于 127 的字节连在一起来共同表示一个汉字</p><p>由__区位码__和__国标码__组成</p><p>可容纳字符数过少</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>国标扩展</p><p>双字节编码，字符数&#x3D;2*GB2312</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>强制性标准，现在在中国大陆销售的软件都支持</p><p>Unicode的一种实现，兼容GB系列，是GB2312、GBK的超集</p><hr><p>参考资料</p><p><a href="https://mp.weixin.qq.com/s/5pAgcjk_lFGrPhSUp2Na3Q">一文读懂字符编码</a></p><p><a href="https://www.zhihu.com/question/23374078">Unicode 和 UTF-8 有何区别？ - 知乎</a></p>]]></content>
    
    
    <summary type="html">常用字符集和字符编码科普</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Kafka设计</title>
    <link href="https://hahahaha123567.github.io/2022-08-05-Kafka%E8%AE%BE%E8%AE%A1.html"/>
    <id>https://hahahaha123567.github.io/2022-08-05-Kafka%E8%AE%BE%E8%AE%A1.html</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-08T08:21:24.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><code>Apache Kafka</code>是一个开源的分布式事件流平台, 用于高性能数据管道、流分析、数据集成</p><p>事件流是从事件源（如数据库、传感器、移动设备、云服务和软件应用程序）以事件流的形式实时捕获数据的实践；持久存储这些事件流以供以后检索；实时和回顾性地操作、处理和响应事件流；并根据需要将事件流路由到不同的目标技术</p><ul><li>publish&#x2F;subscribe(write&#x2F;read)事件流</li><li>存储事件流</li><li>实时或追溯处理事件流</li></ul><h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>与传统的MQ相比，更像数据库日志</p><ul><li>支持高吞吐</li><li>支持处理大量数据积压</li><li>支持低延迟</li><li>机器故障时支持容错</li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>Kafka非常依赖文件系统进行存储和缓存</p><p>使用内存缓存的坏处:</p><ol><li>OS会将内存转移到磁盘缓存</li><li>Java的对象内存开销大</li><li>堆内存使用越多GC越慢</li><li>服务重启时重建缓存慢</li></ol><p>进行的优化:</p><ol><li>自动访问空闲内存</li><li>保存byte[]而不是Java对象</li></ol><ul><li>NO  在内存中维护尽可能多的内容，并在空间不足时将其全部刷新到文件系统</li><li>YES 所有数据都会立即写入文件系统上的持久日志, 不必刷新到磁盘(实际上只是被转移到内核的页面缓存中)</li></ul><h3 id="常数时间"><a href="#常数时间" class="headerlink" title="常数时间"></a>常数时间</h3><p>Queue建立在对文件的read和append上(在日志系统中很常见), 而BTree等数据结构如果触发磁盘寻道会开销很大</p><p>优点:</p><ol><li>操作的时间复杂度O(1)</li><li>读写不会阻塞</li><li>性能与数据量无关</li><li>支持消息保存较长时间</li></ol><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>避免效率低的磁盘访问:</p><ol><li>过多的小型IO操作</li><li>过多的byte复制</li></ol><p>如何避免:</p><ol><li>将数据抽象为<code>message set</code>, 网络请求将消息组合在一起, 服务器将消息一次性append, 消费者一次性获取大数据块</li><li>使用标准化二进制格式, 这样数据传输时不用修改, 就可以利用OS提供的<code>zero-copy</code>, 在Linux中为<code>sendfile</code>系统调用. 使用<code>pagecache</code>+<code>sendfile</code>使磁盘几乎不会有高负载</li></ol><h3 id="端到端批量压缩"><a href="#端到端批量压缩" class="headerlink" title="端到端批量压缩"></a>端到端批量压缩</h3><p>大部分信息冗余来源于同一种类型的不同消息, Kafka支持一批消息批量压缩</p><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>客户端可以控制消息的目标partition, 支持设置使用指定字段作为分区根据, 这样设计使consumer可以做局部敏感数据处理</p><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>producer支持异步, 在内存中保留一定消息然后批处理发送以提高效率, 可以配置缓存的大小和有效时间</p><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>consumer在每个请求中指定想要访问的偏移量</p><h3 id="PUSH-vs-PULL"><a href="#PUSH-vs-PULL" class="headerlink" title="PUSH vs PULL"></a>PUSH vs PULL</h3><p>Kafka使用支持阻塞的PULL请求</p><p>PULL的优点</p><ol><li>consumer不会收到超出可处理上限的消息, 不同的consumer可以按照自己的处理能力获取消息</li><li>PUSH需要针对可能的阻塞设置推送延迟, PULL不需要设置</li></ol><p>简单的PULL的缺点</p><ol><li>没有消息的时候consumer浪费CPU资源进行空轮询</li></ol><h3 id="Consumer记录位置"><a href="#Consumer记录位置" class="headerlink" title="Consumer记录位置"></a>Consumer记录位置</h3><p>MQ需要确认消息是否被成功消费, 一些MQ引入一个中间状态”已发送未消费”</p><p>Kafka的topic的每个分区记录一个consumer位置, 不需要维护每个消息的确认状态</p><h3 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h3><p>可以在所有情况下提供多种保证()</p><ol><li>最多一次, 消息可能会丢失, 不会重复</li><li>最少一次, 消息可能会重复, 不会丢失</li><li>精确一次</li></ol><p>Kafka默认保证最少一次, 事务性producer&#x2F;consumer可以实现精确一次</p><h4 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h4><p>Kafka支持<code>idempotent delivery</code>幂等生产, 重新发送消息不会导致broker中出现重复消息</p><h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><p>Kafka需要支持一个consumer崩溃后切换到其他consumer的场景</p><ol><li>最多一次, consumer读消息-&gt;保存位置-&gt;处理消息</li><li>至少一次, consumer读消息-&gt;处理消息-&gt;保存位置</li><li>精确一次, 使用事务更新, broker同时更新consumer的位置和处理结果</li></ol><h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><p>replication的单位是partition, 每个partition都有1个主节点0或多个从节点, 主写从读</p><p>replication的心跳使用ZooKeeper维护</p><p>分布式一致性</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>NIO服务器</p><h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>key&#x2F;value不透明</p><hr><p><a href="https://kafka.apache.org/intro">Apache Kafka - intro</a></p><p><a href="https://kafka.apache.org/documentation/#design">Apache Kafka - doc</a></p>]]></content>
    
    
    <summary type="html">Kafka官方文档里讲到的设计原则</summary>
    
    
    
    
    <category term="Message Queue" scheme="https://hahahaha123567.github.io/tags/Message-Queue/"/>
    
  </entry>
  
  <entry>
    <title>《聊聊Netty那些事》阅读笔记</title>
    <link href="https://hahahaha123567.github.io/2022-07-07-%E3%80%8A%E8%81%8A%E8%81%8ANetty%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hahahaha123567.github.io/2022-07-07-%E3%80%8A%E8%81%8A%E8%81%8ANetty%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2022-07-27T01:27:26.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内核IO模型"><a href="#内核IO模型" class="headerlink" title="内核IO模型"></a>内核IO模型</h1><h2 id="网络包接收流程"><a href="#网络包接收流程" class="headerlink" title="网络包接收流程"></a>网络包接收流程</h2><p>接收网络数据包的详细开销</p><ul><li>从<code>网卡</code>DMA拷贝网络数据包到<code>内存</code>中的开销(DMA指网卡可以在没有CPU参与的情况下独立写内存)</li><li>CPU收到<code>硬中断</code>后调用网卡驱动进行响应的开销</li><li>OS的内核线程<code>ksoftirqd</code>响应<code>软中断</code>的开销</li><li>应用程序通过系统调用从<code>用户态</code>转为<code>内核态</code>的开销, 系统调用返回时从<code>内核态</code>转为<code>用户态</code>的开销</li><li>网络数据从<code>内存</code>的<code>内核空间</code>通过CPU拷贝到<code>用户空间</code>的开销</li></ul><p><img src="/../../../../image/netty1-1.png" alt="网络包接收过程"></p><p><img src="/../../../../image/netty1-2.png" alt="网络包发送过程"></p><h2 id="同步与异步-阻塞与非阻塞"><a href="#同步与异步-阻塞与非阻塞" class="headerlink" title="同步与异步, 阻塞与非阻塞"></a>同步与异步, 阻塞与非阻塞</h2><p>接收网络数据包的2个流程</p><ul><li>数据准备阶段:  在这个阶段, 网络数据包到达<code>网卡</code>, 通过<code>DMA</code>的方式将数据包拷贝到<code>内存</code>中, 然后经过<code>硬中断</code>, <code>软中断</code>, 接着通过内核线程<code>ksoftirqd</code>经过内核协议栈的处理, 最终将数据发送到<code>内核Socket的接收缓冲区</code>中</li><li>数据拷贝阶段:  当数据到达内核Socket的接收缓冲区中时, 此时数据存在于<code>内核空间</code>中, 需要将数据拷贝到<code>用户空间</code>中, 才能够被应用程序读取</li></ul><p>参考<a href="https://hahahaha123567.github.io/2022-01-14-feng-huang-jia-gou-du-shu-bi-ji-copy.html">《凤凰架构》读书摘要</a>的<code>网络IO模型</code>一节</p><p><a href="http://icyfenix.cn/distribution/connect/service-routing.html">网关路由 | 凤凰架构</a></p><ul><li>同步IO(Synchronous I&#x2F;O)<ul><li>阻塞IO(Blocking I&#x2F;O), 节省 CPU 资源(Java传统IO模型)</li><li>非阻塞IO(Non-Blocking I&#x2F;O), 浪费 CPU 资源(Java的NIO)</li><li>多路复用IO(Multiplexing I&#x2F;O), 主流(通过NIO实现的Reactor模式)</li><li>信号驱动IO(Signal-Driven I&#x2F;O), 需要自己从缓冲区获取数据</li></ul></li><li>异步IO(Asynchronous I&#x2F;O)(通过AIO实现的Proactor模式)</li></ul><p>阻塞与非阻塞的区别主要发生在第一阶段: 数据准备阶段</p><ul><li>阻塞模式, 当Socket的接收缓冲区中没有数据的时候, 应用线程会一直等待</li><li>非阻塞模式, 应用线程不会等待, 系统调用直接返回错误标志<code>EWOULDBLOCK</code></li></ul><p>同步与异步主要的区别发生在第二阶段: 数据拷贝阶段</p><ul><li>同步模式在数据准备好后, 是由用户线程的内核态来执行第二阶段, 所以应用程序会在第二阶段发生阻塞, 直到数据从内核空间拷贝到用户空间, 系统调用才会返回</li><li>异步模式下是由内核来执行第二阶段的数据拷贝操作, 当内核执行完第二阶段, 会通知用户线程IO操作已经完成, 并将数据回调给用户线程</li></ul><h2 id="IO多路复用-TODO"><a href="#IO多路复用-TODO" class="headerlink" title="IO多路复用 TODO"></a>IO多路复用 TODO</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><img src="/../../../../image/netty1-3.png" alt="select"></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="/../../../../image/netty1-4.png" alt="epoll"></p><p>在Netty中实现的<code>EpollSocketChannel</code>默认的就是边缘触发模式, JDK的NIO默认是水平触发模式</p><p>epoll对select, poll的优化</p><ol><li><p>epoll在内核中通过红黑树管理海量的连接, 所以在调用<code>epoll_wait</code>获取IO就绪的socket时, 不需要传入监听的socket文件描述符, 从而避免了海量的文件描述符集合在用户空间和内核空间中来回复制</p></li><li><p>epoll仅会通知IO就绪的socket, 避免了在用户空间遍历的开销</p></li><li><p>epoll通过在socket的等待队列上注册回调函数<code>ep_poll_callback</code>通知用户程序IO就绪的socket, 避免了在内核中轮询的开销</p></li></ol><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p><code>Reactor</code>基于<code>NIO</code>, <code>Proactor</code>基于<code>AIO</code></p><ul><li>单Reactor单线程<ul><li>单Reactor意味着只有一个epoll对象, 监听所有的事件, 包括连接事件, 读写事件</li><li>单线程意味着只有一个线程来执行<code>epoll_wait</code>获取IO就绪的Socket, 然后对这些就绪的Socket执行读写, 后续的业务处理也依然是这个线程</li></ul></li><li>单Reactor多线程<ul><li>只有一个epoll对象来监听所有的IO事件, 一个线程来调用<code>epoll_wait</code>获取IO就绪的Socket</li><li>当IO就绪事件产生时, 这些IO事件对应处理的业务Handler, 我们是通过线程池来执行, 这样相比单Reactor单线程模型提高了执行效率, 充分发挥了多核CPU的优势</li></ul></li><li>主从Reactor多线程<ul><li><code>主Reactor</code>处理连接事件</li><li>当创建好连接, 建立好对应的socket后, 在acceptor中将需要监听的read事件注册到<code>从Reactor</code>中, 由<code>从Reactor</code>来监听socket上的读写事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置单Reactor单线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(eventGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置多Reactor线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(eventGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置主从Reactor多线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure><h2 id="Netty对Reactor模型的实现"><a href="#Netty对Reactor模型的实现" class="headerlink" title="Netty对Reactor模型的实现"></a>Netty对Reactor模型的实现</h2><p><img src="/../../../../image/netty1-5.png" alt="Netty中的reactor"></p><p>Reactor在netty中是以group的形式出现的, netty中将Reactor分为两组, 一组是<code>主ReactorGroup</code>也就是<code>bossGroup</code>, 另一组是<code>从ReactorGroup</code>也就是<code>workerGroup</code></p><h3 id="主ReactorGroup"><a href="#主ReactorGroup" class="headerlink" title="主ReactorGroup"></a>主ReactorGroup</h3><p><code>主ReactorGroup</code>中通常只有一个Reactor, 专门负责监听<code>连接accept事件</code>, 当有连接事件产生时, 在acceptor中创建相应的<code>NioSocketChannel</code>(代表一个Socket连接), 然后以负载均衡的方式在<code>从ReactorGroup</code>中选一个Reactor, 注册监听<code>Read事件</code></p><p><code>主ReactorGroup</code>中只有一个Reactor, 因为通常我们服务端程序只会绑定监听一个端口, 如果要绑定监听多个端口, 就会配置多个Reactor</p><h3 id="从ReactorGroup"><a href="#从ReactorGroup" class="headerlink" title="从ReactorGroup"></a>从ReactorGroup</h3><p><code>从ReactorGroup</code>中有多个Reactor, 具体Reactor的个数可以由系统参数指定, 默认的Reactor的个数为<code>CPU核数 * 2</code>, <code>从ReactorGroup</code>中的Reactor主要负责监听读写事件, 每一个Reactor负责监听一组socket连接</p><p>Socket连接在创建后就被固定的分配给一个Reactor, 所以一个Socket连接也只会被一个固定的IO线程执行, 这种无锁串行化的设计的目的是为了防止多线程并发执行同一个socket连接上的IO逻辑处理, 防止出现线程安全问题</p><ol><li>轮询IO就绪事件</li><li>处理IO事件</li><li>执行异步任务</li></ol><p>由于每个Reactor中只有一个IO线程, <code>ChannelHandler</code>中执行的逻辑不能耗时太长, 尽量将耗时的业务逻辑处理放入单独的业务线程池中处理, 否则会影响其他连接的IO读写, 从而影响整个服务程序的IO吞吐</p><h1 id="Reactor在Netty中的实现-创建"><a href="#Reactor在Netty中的实现-创建" class="headerlink" title="Reactor在Netty中的实现(创建)"></a>Reactor在Netty中的实现(创建)</h1><h2 id="Netty服务端代码模板"><a href="#Netty服务端代码模板" class="headerlink" title="Netty服务端代码模板"></a>Netty服务端代码模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Echoes back any received data from a client.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        <span class="comment">//创建主从Reactor线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">EchoServerHandler</span> <span class="variable">serverHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup) <span class="comment">// 配置主从Reactor</span></span><br><span class="line">             .channel(NioServerSocketChannel.class) <span class="comment">// 配置主Reactor中的channel类型</span></span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>) <span class="comment">// 设置主Reactor中channel的option选项</span></span><br><span class="line">             .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">// 设置主Reactor中Channel-&gt;pipline-&gt;handler</span></span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="comment">// 设置从Reactor中注册channel的pipeline</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                     <span class="comment">// p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口启动服务, 开始监听accept事件</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>主从ReactorGroup</code>, 在Netty中<code>EventLoopGroup</code>就是<code>ReactorGroup</code>的实现类, <code>EventLoop</code>就是<code>Reactor</code>的实现类</p><p>SocketChannel</p><ul><li><code>NioServerSocketChannel</code>, 监听Socket, 负责listen和bind, 使用<code>ServerBootstrapAcceptor</code>创建<code>NioSocketChannel</code></li><li><code>NioSocketChannel</code>, 客户端连接socket, 负责与客户端之间的网络通信</li></ul><p>serverBootstrap.handler设置的是服务端NioServerSocketChannel PipeLine中的ChannelHandler, ServerBootstrap启动类方法带有child前缀的均是设置客户端NioSocketChannel属性的</p><h2 id="创建用于启动EventLoop线程的executor"><a href="#创建用于启动EventLoop线程的executor" class="headerlink" title="创建用于启动EventLoop线程的executor"></a>创建用于启动EventLoop线程的executor</h2><p><code>ThreadPerTaskExecutor</code>, 来一个任务就创建一个线程执行, EventLoop线程的核心就是一个死循环不停的轮询IO就绪事件, 处理IO事件, 执行异步任务</p><h2 id="创建EventLoop"><a href="#创建EventLoop" class="headerlink" title="创建EventLoop"></a>创建EventLoop</h2><p><img src="/../../../../image/netty2-1.png" alt="EventLoop结构"></p><p>EventLoop线程组<code>NioEventLoopGroup</code>包含多个<code>EventLoop</code>, 存放于<code>private final EventExecutor[] children</code>中</p><p>EventLoop的核心是使用IO多路复用模型来对客户端连接上的IO事件进行监听, 所以最重要的事情是创建Selector</p><p>openSelector是NioEventLoop类中用于创建IO多路复用的Selector, 并对创建出来的JDK NIO原生的Selector进行性能优化: </p><ol><li>将<code>SelectorImpl</code>中存放可用socket的<code>HashSet</code>使用反射修改为<code>SelectedSelectionKeySet</code>, 底层实现从<code>HashMap</code>变为<code>数组</code>, 优化遍历、插入性能, 利用cpu cache</li><li>使用代理模式, 用<code>SelectedSelectionKeySetSelector</code>代理selector的真实实现类, 在每次遍历结束后清空SelectedSelectionKeySet的内容</li></ol><p>EventLoop内的异步任务队列的类型为<code>MpscQueue</code>,它是由<code>JCTools</code>提供的一个高性能无锁队列, 从命名前缀Mpsc可以看出, 它适用于多生产者单消费者的场景</p><p>EventLoop负责执行的异步任务分为三类: </p><ul><li>普通任务: 这是Netty最主要执行的异步任务, 存放在普通任务队列taskQueue中, 在<code>NioEventLoop</code>构造函数中创建</li><li>定时任务: 存放在优先级队列中</li><li>尾部任务: 存放于尾部任务队列tailTasks中, 尾部任务一般不常用, 在普通任务执行完后 EventLoop线程会执行尾部任务, 比如对Netty的运行状态做一些统计数据, 例如任务循环的耗时、占用物理内存的大小等等都可以向尾部队列添加一个收尾任务完成统计数据的实时更新</li></ul><h2 id="创建Channel到EventLoop的绑定策略"><a href="#创建Channel到EventLoop的绑定策略" class="headerlink" title="创建Channel到EventLoop的绑定策略"></a>创建Channel到EventLoop的绑定策略</h2><p>无论是Netty服务端<code>NioServerSocketChannel</code>关注的<code>OP_ACCEPT</code>事件, 还是Netty客户端<code>NioSocketChannel</code>关注的<code>OP_READ</code>和<code>OP_WRITE</code>事件, 都需要先注册到EventLoop上, EventLoop才能监听Channel上关注的IO事件实现IO多路复用</p><p><code>MultithreadEventExecutorGroup</code>类的构造器参数<code>EventExecutorChooserFactory</code>负责创建Channel到EventLoop的绑定策略, 默认为round-robin轮询, 如果EventLoop数量为2的次幂可以用移位快速计算</p><h1 id="Netty启动流程"><a href="#Netty启动流程" class="headerlink" title="Netty启动流程"></a>Netty启动流程</h1><p><img src="/../../../../image/netty3-1.png" alt="EventLoop启动流程图"></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>不管是服务端用到的<code>NioServerSocketChannel</code>还是客户端用到的<code>NioSocketChannel</code>, 每个Channel实例都会有一个Pipeline, Pipeline中有多个<code>ChannelHandler</code>用于编排处理对应Channel上感兴趣的IO事件</p><p>向<code>NioServerSocketChannel</code>中的Pipeline添加<code>ChannelHandler</code>分为两种方式</p><ol><li>显式添加: 用户通过<code>ServerBootstrap#handler</code>添加, 如果需要添加多个<code>ChannelHandler</code>, 则可以通过<code>ChannelInitializer</code>向pipeline中进行添加</li><li>隐式添加: 隐式添加主要添加的就是<code>MainEventLoopGroup</code>的核心组件, 也就是图中的acceptor, Netty中的实现为<code>ServerBootstrapAcceptor</code>, 本质上也是一种<code>ChannelHandler</code>, 主要负责在客户端连接建立好后, 初始化客户端<code>NioSocketChannel</code>, 在从EventLoop线程组中选取一个<code>SubEventLoop</code>, 将客户端<code>NioSocketChannel</code>注册到<code>SubEventLoop</code>中的selector上</li></ol><p><img src="/../../../../image/netty3-2.png" alt="EventLoopGroup结构"></p><p>由于在Netty的IO线程模型中, 是由单个<code>SubEventLoop</code>线程负责执行客户端<code>NioSocketChannel</code>中的Pipeline, 一个<code>SubEventLoop</code>线程负责处理多个<code>NioSocketChannel</code>上的IO事件, 如果Pipeline中的<code>ChannelHandler</code>添加的太多, 就会影响<code>SubEventLoop</code>线程执行其他<code>NioSocketChannel</code>上的Pipeline, 从而降低IO处理效率, 降低吞吐量</p><p>所以Pipeline中的<code>ChannelHandler</code>不易添加过多, 并且不能在<code>ChannelHandler</code>中执行耗时的业务处理任务</p><h2 id="Netty服务端的启动"><a href="#Netty服务端的启动" class="headerlink" title="Netty服务端的启动"></a>Netty服务端的启动</h2><p><img src="/../../../../image/netty3-3.png" alt="EventLoop启动后的结构"></p><p>Netty服务端的启动流程总体如下: </p><ol><li>创建服务端<code>NioServerSocketChannel</code>并初始化</li><li>将服务端<code>NioServerSocketChannel</code>注册到<code>主EventLoopGroup</code>中</li><li>注册成功后, 开始初始化<code>NioServerSocketChannel</code>中的pipeline, 然后在pipeline中触发<code>ChannelRegister</code>事件</li><li>随后由<code>NioServerSocketChannel</code>绑定端口地址</li><li>绑定端口地址成功后, 向<code>NioServerSocketChannel</code>对应的Pipeline中触发传播<code>ChannelActive</code>事件, 在事件回调中向<code>MainEventLoop</code>注册<code>OP_ACCEPT</code>事件, 开始等待客户端连接, 服务端启动完成</li></ol><p>代码执行流程:</p><ol><li>创建<code>NioServerSocketChannel</code></li><li>初始化<code>NioServerSocketChannel</code></li><li>向<code>MainEventLoop</code>注册<code>NioServerSocketChannel</code><ol><li><code>MainEventLoopGroup</code>中选取一个<code>MainEventLoop</code>进行注册</li><li>向绑定后的<code>MainEventLoop</code>进行注册</li><li><code>MainEventLoop</code>的启动</li><li>startThread</li><li>register0, 封装为异步任务</li><li>doRegister(), 添加Acceptor封装为异步任务</li><li><code>HandlerAdded</code>事件回调中初始化ChannelPipeline</li><li>回调regFuture的<code>ChannelFutureListener</code></li></ol></li><li>doBind0, 封装为异步任务</li><li>绑定端口地址<ol><li>HeadContext</li><li><code>channelActive</code>事件处理, 封装为异步任务</li><li>beginRead</li></ol></li></ol><p><code>Unsafe</code>为<code>Channel</code>接口的一个内部接口, 用于定义实现对Channel底层的各种操作, Unsafe接口定义的操作行为只能由Netty框架的Reactor线程调用, 用户线程禁止调用</p><p>Netty自定义的<code>SocketChannel</code>类型均继承<code>AttributeMap</code>接口以及<code>DefaultAttributeMap</code>类, 正是它们定义了<code>ChannelAttributes</code>, 用于向Channel添加用户自定义的一些信息</p><p>初始化<code>NioServerSocketChannel</code>中pipeline的时机是: 当<code>NioServerSocketChannel</code>注册到<code>MainEventLoop</code>之后, 绑定端口地址之前</p><p><code>MainEventLoop</code>线程是在提交第一个异步任务的时候启动的, 在用户程序(Main线程)提交用于注册<code>NioServerSocketChannel</code>的异步任务时开始启动</p><h1 id="Reactor的架构"><a href="#Reactor的架构" class="headerlink" title="Reactor的架构"></a>Reactor的架构</h1><h2 id="Reactor线程的整个运行框架"><a href="#Reactor线程的整个运行框架" class="headerlink" title="Reactor线程的整个运行框架"></a>Reactor线程的整个运行框架</h2><p>Netty中的Reactor线程主要干三件事情: </p><ul><li>轮询注册在<code>EventLoop</code>上的所有Channel感兴趣的IO就绪事件</li><li>处理Channel上的IO就绪事件</li><li>执行Netty中的异步任务</li></ul><p><code>EventLoop</code>线程其实执行的就是一个死循环, 在死循环中不断的通过Selector去轮询IO就绪事件, 如果发生IO就绪事件则从Selector系统调用中返回并处理IO就绪事件, 如果没有发生IO就绪事件则一直阻塞在Selector系统调用上, 直到满足Selector唤醒条件:</p><ol><li>当Selector轮询到有IO活跃事件发生时</li><li>当<code>EventLoop</code>线程需要执行的定时任务到达任务执行时间deadline时</li><li>当有异步任务提交给<code>EventLoop</code>时, <code>EventLoop</code>线程需要从Selector上被唤醒, 这样才能及时的去执行异步任务</li></ol><p><img src="/../../../../image/netty4-1.png" alt="EventLoop工作流程图"></p><h2 id="Reactor线程轮询IO就绪事件"><a href="#Reactor线程轮询IO就绪事件" class="headerlink" title="Reactor线程轮询IO就绪事件"></a>Reactor线程轮询IO就绪事件</h2><p>在Reactor线程的轮询工作开始之前, 需要首先判断下当前是否有异步任务需要执行, 判断依据就是查看Reactor中的异步任务队列taskQueue和用于统计信息任务用的尾部队列tailTask是否有异步任务</p><p>如果Reactor中有异步任务需要执行, 那么Reactor线程需要立即执行, 不能阻塞在Selector上, 在返回前需要再顺带调用<code>selectNow()</code>非阻塞查看一下当前是否有IO就绪事件发生, 如果有, 那么正好可以和异步任务一起被处理, 如果没有, 则及时地处理异步任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSelectStrategy</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="type">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reactor线程要保证及时的执行异步任务</span></span><br><span class="line"><span class="comment">     * 1: 如果有异步任务等待执行, 则马上执行selectNow()非阻塞轮询一次IO就绪事件</span></span><br><span class="line"><span class="comment">     * 2: 没有异步任务, 则跳到switch select分支</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">IntSupplier</span> <span class="variable">selectNowSupplier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntSupplier</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">return</span> selector.selectNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>NioEventLoop</code>是<code>ScheduledExecutorService</code>的子类, 支持执行定时任务, 在阻塞轮询IO任务之前通过<code>AbstractScheduledEventExecutor</code>的<code>nextScheduledTaskDeadlineNanos</code>获取到下个定时任务执行的时间作为阻塞超时时间</p><p>异步任务在被提交后希望立马得到执行, 那么就在提交异步任务的时候去唤醒正在阻塞轮询的Reactor线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">        strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 执行到这里说明EventLoop已经从Selector上被唤醒了</span></span><br><span class="line">    <span class="comment">// 设置EventLoop的状态为苏醒状态AWAKE</span></span><br><span class="line">    <span class="comment">// lazySet优化不必要的volatile操作, 不使用内存屏障, 不保证写操作的可见性（单线程不需要保证）</span></span><br><span class="line">    nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactor处理IO与处理异步任务的时间比例分配"><a href="#Reactor处理IO与处理异步任务的时间比例分配" class="headerlink" title="Reactor处理IO与处理异步任务的时间比例分配"></a>Reactor处理IO与处理异步任务的时间比例分配</h2><p>Netty通过ioRatio变量来调配<code>EventLoop</code>线程在处理IO事件和执行异步任务之间的CPU时间分配比例, 防止<code>EventLoop</code>线程处理异步任务时间过长而导致I&#x2F;O 事件得不到及时地处理</p><p><code>ioRatio / 100 = 执行异步任务时间 / (执行异步任务时间 + 轮询IO事件时间)</code>, 默认50</p><h2 id="Reactor线程处理IO就绪事件"><a href="#Reactor线程处理IO就绪事件" class="headerlink" title="Reactor线程处理IO就绪事件"></a>Reactor线程处理IO就绪事件</h2><ol><li><code>processSelectedKeysPlain</code>, JDK实现<ol><li>获取IO就绪的Channel</li><li>处理Channel上的IO事件<ol><li>处理Connect事件</li><li>处理Write事件</li><li>处理Read事件或者Accept事件</li></ol></li><li>从Selector中移除失效的<code>SelectionKey</code>, 为了保证Selector中所有KeySet的有效性, 需要在Channel取消个数达到256时, 触发一次selectNow, 目的是清除无效的<code>SelectionKey</code></li></ol></li><li><code>processSelectedKeysOptimized</code>, Netty实现<ol><li>数组需要手动做清除</li></ol></li></ol><p>服务端<code>NioServerSocketChannel</code>中的Read方法处理的是Accept事件, 客户端<code>NioSocketChannel</code>中的Read方法处理的是Read事件</p><h2 id="Reactor线程处理异步任务"><a href="#Reactor线程处理异步任务" class="headerlink" title="Reactor线程处理异步任务"></a>Reactor线程处理异步任务</h2><p><code>EventLoop</code>线程执行异步任务的核心逻辑:</p><ol><li>先将到期的定时任务从定时任务队列<code>scheduledTaskQueue</code>中全部取出并转存到普通任务队列taskQueue中</li><li>由<code>EventLoop</code>线程统一从普通任务队列taskQueue中取出任务执行</li><li>在<code>EventLoop</code>线程执行完定时任务和普通任务后, 开始执行存储于尾部任务队列tailTasks中的尾部任务</li></ol><h2 id="规避JDK-Epoll空轮询bug"><a href="#规避JDK-Epoll空轮询bug" class="headerlink" title="规避JDK Epoll空轮询bug"></a>规避JDK Epoll空轮询bug</h2><p>JDK NIO Epoll的空轮询BUG会导致<code>EventLoop</code>线程在没有任何事情可做的情况下被意外唤醒, 导致CPU空转</p><p>既没有IO就绪事件, 也没有异步任务, <code>EventLoop</code>线程从Selector上被异常唤醒, 发生512次之后认为已触发bug, 则重建Selector(将之前注册的所有Channel重新注册到新的Selector上并关闭旧的Selector), selectCnt计数归0</p><h1 id="Netty接收网络连接"><a href="#Netty接收网络连接" class="headerlink" title="Netty接收网络连接"></a>Netty接收网络连接</h1><h2 id="MainReactor处理OP-ACCEPT事件"><a href="#MainReactor处理OP-ACCEPT事件" class="headerlink" title="MainReactor处理OP_ACCEPT事件"></a>MainReactor处理OP_ACCEPT事件</h2><p>Netty将<code>OP_ACCEPT</code>事件处理的入口函数封装在<code>NioServerSocketChannel</code>里的底层操作类Unsafe的read方法中</p><p><img src="/../../../../image/netty6.png" alt="接收客户端连接"></p><p>main reactor线程是在一个无限循环read loop中不断的调用JDK NIO <code>serverSocketChannel.accept()</code>方法来接收完成三次握手的客户端连接<code>NioSocketChannel</code>的, 并将接收到的<code>NioSocketChannel</code>临时保存在<code>List&lt;Object&gt; readBuf</code>集合中, 后续在<code>NioServerSocketChannel</code>的pipeline中通过<code>ChannelRead</code>事件来传递, 最终会在<code>ServerBootstrapAcceptor</code>这个ChannelHandler中被处理初始化, 并将其注册到<code>SubEventLoop</code>中</p><p>这里的read loop循环会被限定只能读取16次, 当<code>MainEventLoop</code>从<code>NioServerSocketChannel</code>中读取客户端连接<code>NioSocketChannel</code>的次数达到16次之后, 无论此时是否还有客户端连接都不能在继续读取了, 因为还需要分配时间去执行异步任务, 不能因为无限制的接收客户端连接而耽误了异步任务的执行</p><h2 id="doReadMessages接收客户端连接"><a href="#doReadMessages接收客户端连接" class="headerlink" title="doReadMessages接收客户端连接"></a>doReadMessages接收客户端连接</h2><p>根据<code>ServerSocketChannel</code>的accept方法获取到JDK NIO 原生的<code>SocketChannel</code>(用于底层真正与客户端通信的Channel), 来创建Netty中的<code>NioSocketChannel</code></p><p><code>NioServerSocketChannel</code>与<code>NioSocketChannel</code>的不同</p><ol><li><code>NioServerSocketChannel</code>在<code>EventLoop</code>启动过程中创建, <code>NioSocketChannel</code>在<code>EventLoop</code>接收连接时被<code>NioServerSocketChannel</code>创建</li><li><code>NioServerSocketChannel</code>向<code>MainEventLoop</code>注册<code>OP_ACCEPT</code>事件, <code>NioSocketChannel</code>向<code>SubEventLoop</code>注册<code>OP_READ</code>事件</li><li><code>NioServerSocketChannel</code>继承<code>AbstractNioMessageChannel</code>, 输出的Message指的是<code>SocketChannel</code>客户端连接; <code>NioSocketChannel</code>继承的是<code>AbstractNioByteChannel</code>, 输出的是网络数据Byte</li></ol><p><img src="/../../../../image/netty8.png" alt="NioSocketChannel结构"></p><h2 id="ChannelRead事件的响应"><a href="#ChannelRead事件的响应" class="headerlink" title="ChannelRead事件的响应"></a>ChannelRead事件的响应</h2><p><code>ServerBootstrapAcceptor</code>主要的作用就是初始化客户端<code>NioSocketChannel</code>, 并将客户端<code>NioSocketChannel</code>注册到<code>从ReactorGroup</code>中, 并监听OP_READ事件</p><h2 id="向从ReactorGroup注册NioSocketChannel"><a href="#向从ReactorGroup注册NioSocketChannel" class="headerlink" title="向从ReactorGroup注册NioSocketChannel"></a>向从ReactorGroup注册NioSocketChannel</h2><ol><li>从<code>从ReactorGroup</code>中选取一个<code>从Reactor</code>进行绑定</li><li>向绑定的<code>从Reactor</code>上注册<code>NioSocketChannel</code></li><li>register0</li></ol><h1 id="Netty接收网络数据"><a href="#Netty接收网络数据" class="headerlink" title="Netty接收网络数据"></a>Netty接收网络数据</h1><h2 id="SubReactor处理OP-READ事件流程总览"><a href="#SubReactor处理OP-READ事件流程总览" class="headerlink" title="SubReactor处理OP_READ事件流程总览"></a>SubReactor处理OP_READ事件流程总览</h2><p>当网络数据到达服务端的网卡并经过内核协议栈的处理, 最终数据到达Socket的接收缓冲区之后, <code>SubEventLoop</code>轮询到<code>NioSocketChannel</code>上的<code>OP_READ</code>事件就绪, 随后<code>SubEventLoop</code>线程就会从JDK Selector上的阻塞轮询API<code>selector.select(timeoutMillis)</code>调用中返回, 转而去处理<code>NioSocketChannel</code>上的<code>OP_READ</code>事件</p><p><code>SubEventLoop</code>在处理Channel上的IO事件入口函数为<code>NioEventLoop#processSelectedKey</code></p><h2 id="Netty接收网络数据流程总览"><a href="#Netty接收网络数据流程总览" class="headerlink" title="Netty接收网络数据流程总览"></a>Netty接收网络数据流程总览</h2><p><img src="/../../../../image/netty10.png" alt="Netty接收网络数据流程"></p><p><code>NioSocketChannel</code>读取连接数据的read loop中受最大读取次数的限制, 默认配置最多只能读取16次, 超过16次无论此时<code>NioSocketChannel</code>中是否还有可读数据都不能在进行读取了</p><ul><li>lastBytesRead &lt; 0: 表示客户端主动发起了连接关闭流程, Netty开始连接关闭处理流程</li><li>lastBytesRead &#x3D; 0: 表示当前<code>NioSocketChannel</code>上的数据已经全部读取完毕, 没有数据可读, 本次<code>OP_READ</code>事件处理完毕</li><li>lastBytesRead &gt; 0: 表示在本次read loop中从<code>NioSocketChannel</code>中读取到了数据, 会在<code>NioSocketChannel</code>的pipeline中触发<code>ChannelRead</code>事件, 进而在pipeline中负责IO处理的<code>ChannelHandelr</code>中响应, 处理网络请求</li></ul><h2 id="ChannelRead和ChannelReadComplete的区别"><a href="#ChannelRead和ChannelReadComplete的区别" class="headerlink" title="ChannelRead和ChannelReadComplete的区别"></a>ChannelRead和ChannelReadComplete的区别</h2><ul><li><code>ChanneRead</code>事件: 一次循环读取一次数据, 就触发一次ChannelRead事件, 本次最多读取在read loop循环开始分配的<code>DirectByteBuffer</code>容量大小</li><li><code>ChannelReadComplete</code>事件: 当读取不到数据或者不满足continueReading的任意一个条件就会退出read loop, 这时就会触发<code>ChannelReadComplete</code>事件</li></ul><p>触发<code>ChannelReadComplete</code>事件并不代表<code>NioSocketChannel</code>中的数据已经读取完了, 只能说明本次<code>OP_READ</code>事件处理完毕, 因为有可能是客户端发送的数据太多, Netty读了16次还没读完, 那就只能等到下次<code>OP_READ</code>事件到来的时候在进行读取了</p><h2 id="源码核心框架总览"><a href="#源码核心框架总览" class="headerlink" title="源码核心框架总览"></a>源码核心框架总览</h2><h3 id="分配DirectByteBuffer接收网络数据"><a href="#分配DirectByteBuffer接收网络数据" class="headerlink" title="分配DirectByteBuffer接收网络数据"></a>分配DirectByteBuffer接收网络数据</h3><p><code>NioSocketChannel</code>的2个<code>ByteBufAllocator</code></p><ul><li><code>ByteBufAllocator</code>是一个<code>PooledByteBufAllocator</code>的实例, 内存池, 用来管理堆外内存<code>DirectByteBuffer</code></li><li><code>RecvByteBufAllocator</code>是一个<code>AdaptiveRecvByteBufAllocator</code>类的实例, 可以动态调整ByteBuffer的容量, 初始为2048</li></ul><p><code>RecvByteBufAllocator</code>计算大小, 然后<code>ByteBufAllocator</code>进行内存分配</p><h2 id="ByteBuffer动态自适应括缩容机制"><a href="#ByteBuffer动态自适应括缩容机制" class="headerlink" title="ByteBuffer动态自适应括缩容机制"></a>ByteBuffer动态自适应括缩容机制</h2><p>容量索引表</p><ol><li>当索引容量小于512时, 容量索引从16开始按16递增</li><li>当索引容量大于512时, 容量索引按前一个索引容量的2倍递增</li></ol><p><code>AdaptiveRecvByteBufAllocator</code>类中定义的扩容步长<code>INDEX_INCREMENT = 4</code>, 缩容步长<code>INDEX_DECREMENT = 1</code></p><ul><li>扩容: 取容量索引向后走4步对应的size</li><li>缩容: 取容量索引向前走1步对应的size, 满足两次缩容条件才会进行缩容</li></ul><h2 id="使用堆外内存为ByteBuffer分配内存"><a href="#使用堆外内存为ByteBuffer分配内存" class="headerlink" title="使用堆外内存为ByteBuffer分配内存"></a>使用堆外内存为ByteBuffer分配内存</h2><p>JDK接收请求的拷贝次数</p><ol><li><code>网卡</code> -&gt; <code>内核空间</code>, 使用DMA</li><li><code>内核空间</code> -&gt; <code>用户空间</code>, 系统调用触发</li><li><code>堆外内存</code> -&gt; <code>堆内存</code>, JVM拷贝</li></ol><p>Netty使用堆外内存的好处</p><ol><li>减少一次拷贝</li><li>手动引用计数维护内存可以减少FGC</li></ol><h1 id="Recycler对象池"><a href="#Recycler对象池" class="headerlink" title="Recycler对象池"></a>Recycler对象池</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Netty选择使用堆外内存存储网络通信数据</p><ol><li>在JVM堆中创建一个用于引用native memory的引用对象<code>DirectByteBuffer</code></li><li>使用native方法<code>unsafe.allocateMemory</code>通过底层<code>malloc</code>系统调用申请一块堆外内存, 然后被<code>DirectByteBuffer</code>引用</li></ol><p>Netty面对的高并发网络通信场景下, 申请堆外内存是一个非常频繁的操作, 这种大量频繁的内存申请释放操作对程序的性能影响是巨大的, 所以Netty就引入了内存池对内存相关的操作进行统一的管理</p><h2 id="对象在JVM中创建和回收开销"><a href="#对象在JVM中创建和回收开销" class="headerlink" title="对象在JVM中创建和回收开销"></a>对象在JVM中创建和回收开销</h2><p>略过</p><h2 id="对象池Recycler"><a href="#对象池Recycler" class="headerlink" title="对象池Recycler"></a>对象池Recycler</h2><p><img src="/../../../../image/netty7-1.png" alt="对象池接口"></p><p>Netty中每个被池化的对象中都会引用对象池的实例<code>RECYCLER</code></p><p>每个池化对象中都会包含一个<code>recyclerHandle</code>, 是池化对象在对象池中的句柄, 是由对象池在创建对象后传递进来的</p><ul><li>获取对象: <code>RECYCLER.get()</code></li><li>删除对象: <code>recyclerHandle.recycle(this)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Channel#write使用的缓存ChannelOutboundBuffer中保存的对象Entry</span></span><br><span class="line"><span class="comment">// 以Entry为例看一下如何使用对象池</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(handle -&gt; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(handle));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;Entry&gt; recyclerHandle;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Entry</span><span class="params">(Handle&lt;Entry&gt; recyclerHandle)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.recyclerHandle = recyclerHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请对象</span></span><br><span class="line">    <span class="keyword">static</span> Entry <span class="title function_">newInstance</span><span class="params">(Object msg, <span class="type">int</span> size, <span class="type">long</span> total, ChannelPromise promise)</span> &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> RECYCLER.get();</span><br><span class="line">        entry.msg = msg;</span><br><span class="line">        entry.pendingSize = size + CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD;</span><br><span class="line">        entry.total = total;</span><br><span class="line">        entry.promise = promise;</span><br><span class="line">        <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">        bufs = <span class="literal">null</span>;</span><br><span class="line">        buf = <span class="literal">null</span>;</span><br><span class="line">        msg = <span class="literal">null</span>;</span><br><span class="line">        promise = <span class="literal">null</span>;</span><br><span class="line">        progress = <span class="number">0</span>;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">        pendingSize = <span class="number">0</span>;</span><br><span class="line">        count = -<span class="number">1</span>;</span><br><span class="line">        cancelled = <span class="literal">false</span>;</span><br><span class="line">        handle.recycle(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Recycler总体设计"><a href="#Recycler总体设计" class="headerlink" title="Recycler总体设计"></a>Recycler总体设计</h2><p><img src="/../../../../image/netty7-2.png" alt="Recycler总体设计"></p><h3 id="获取对象无锁化设计"><a href="#获取对象无锁化设计" class="headerlink" title="获取对象无锁化设计"></a>获取对象无锁化设计</h3><p>每个线程拥有一个独立Stack, 这样当多个线程并发从对象池中获取对象时, 都是从自己线程中的Stack中获取, 全程无锁化运行, JVM的堆内存分配也是这样(TLAB), 但是JVM提供的堆外内存分配为了防止内存泄漏是全局加锁的(堆外不能自动GC)</p><h3 id="释放对象无锁化设计"><a href="#释放对象无锁化设计" class="headerlink" title="释放对象无锁化设计"></a>释放对象无锁化设计</h3><p>thread2释放thread1获取的对象, 就需要操作thread1的stack, 可能产生多线程冲突</p><p>引入<code>WeakOrderQueue</code>链表, 每个<code>WeakOrderQueue</code>表示一个其他线程回收的该线程的对象, 获取对象时取不到对象就去<code>WeakOrderQueue</code>取</p><p>对象池回收对象的一个原则就是对象由谁创建的, 最终就要被回收到创建线程对应的<code>Stack</code>结构中的数组栈中, 数组栈中存放的才是真正被回收的池化对象, 可以直接被取出复用, 回收线程只能将待回收对象暂时存放至创建线程对应的<code>Stack</code>结构中的<code>WeakOrderQueue</code>链表中, 当数组栈中没有对象时, 由创建线程将<code>WeakOrderQueue</code>链表中的待回收对象转移至数组栈中</p><p><code>WeakOrderQueue</code>链表, <code>创建线程</code>使用head指针获取可以被回收的对象, <code>回收线程</code>使用tail指针插入需要被回收的对象, Netty这里为了不引入多线程同步的开销, 只会保证待回收对象的最终可见性, 会存在线程可见性的问题(维护线程之间操作的原子性, 可见性都是需要开销的, netty为了提高多线程的运行效率, 避免引入不必要的同步开销)</p><h2 id="Recycler实现"><a href="#Recycler实现" class="headerlink" title="Recycler实现"></a>Recycler实现</h2><p>Handle是池化对象在对象池中的一个模型, 默认实现是DefaultHandle</p><p><code>stack</code>和<code>WeakOrderQueue</code>中存的就是handle</p><p>在创建对象池的时候, 需要通过<code>ObjectCreator#newObject</code>方法指定对象池创建对象的行为即<code>Handle</code></p><p><img src="/../../../../image/netty7-3.png" alt="创建ObjectPool"></p><h1 id="Netty发送数据流程"><a href="#Netty发送数据流程" class="headerlink" title="Netty发送数据流程"></a>Netty发送数据流程</h1><h2 id="write方法发送数据"><a href="#write方法发送数据" class="headerlink" title="write方法发送数据"></a>write方法发送数据</h2><p><img src="/../../../../image/netty8-1.png" alt="write事件传播流程"></p><ul><li><code>channelHandlerContext.write()</code>方法会从<code>当前ChannelHandler</code>开始在pipeline中向前传播write事件直到<code>HeadContext</code></li><li><code>channelHandlerContext.channel().write()</code>会从pipeline的尾结点<code>TailContext</code>开始在pipeline中向前传播write事件直到<code>HeadContext</code></li></ul><p>Netty的写操作是一个异步操作, 当我们在业务线程中调用<code>channelHandlerContext.write()</code>后, Netty会给我们返回一个<code>ChannelFuture</code>, 我们可以在这个<code>ChannelFutrue</code>中添加<code>ChannelFutureListener</code>, 这样要发送的数据发送到底层Socket中时, Netty会通过<code>ChannelFutureListener</code>通知我们写入结果</p><p>当异步事件在pipeline传播的过程中发生异常时就会停止传播。所以我们在日常开发中, 需要对写操作异常情况进行处理</p><h2 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h2><h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><h2 id="Socket写满16次未写完"><a href="#Socket写满16次未写完" class="headerlink" title="Socket写满16次未写完"></a>Socket写满16次未写完</h2><h2 id="处理OP-WRITE"><a href="#处理OP-WRITE" class="headerlink" title="处理OP_WRITE"></a>处理OP_WRITE</h2><h2 id="writeAndFlush"><a href="#writeAndFlush" class="headerlink" title="writeAndFlush"></a>writeAndFlush</h2><h1 id="Pipeline-详解所有-IO-事件的触发时机以及传播路径"><a href="#Pipeline-详解所有-IO-事件的触发时机以及传播路径" class="headerlink" title="Pipeline, 详解所有 IO 事件的触发时机以及传播路径"></a>Pipeline, 详解所有 IO 事件的触发时机以及传播路径</h1><h2 id="Pipeline的创建"><a href="#Pipeline的创建" class="headerlink" title="Pipeline的创建"></a>Pipeline的创建</h2><h3 id="HeadContext"><a href="#HeadContext" class="headerlink" title="HeadContext"></a>HeadContext</h3><h3 id="TailContext"><a href="#TailContext" class="headerlink" title="TailContext"></a>TailContext</h3><p><code>TailContext</code>作为一个<code>ChannelHandlerContext</code></p><p><code>TailContext</code>作为一个<code>ChannelInbondHandler</code></p><h2 id="Pipeline中的事件"><a href="#Pipeline中的事件" class="headerlink" title="Pipeline中的事件"></a>Pipeline中的事件</h2><h3 id="Inbond事件"><a href="#Inbond事件" class="headerlink" title="Inbond事件"></a>Inbond事件</h3><h3 id="OutBond事件"><a href="#OutBond事件" class="headerlink" title="OutBond事件"></a>OutBond事件</h3><h2 id="向Pipeline添加ChannelHandler"><a href="#向Pipeline添加ChannelHandler" class="headerlink" title="向Pipeline添加ChannelHandler"></a>向Pipeline添加ChannelHandler</h2><h2 id="ChannelHandlerContext的创建"><a href="#ChannelHandlerContext的创建" class="headerlink" title="ChannelHandlerContext的创建"></a>ChannelHandlerContext的创建</h2><h2 id="从pipeline删除ChannelHandler"><a href="#从pipeline删除ChannelHandler" class="headerlink" title="从pipeline删除ChannelHandler"></a>从pipeline删除ChannelHandler</h2><h2 id="初始化pipeline"><a href="#初始化pipeline" class="headerlink" title="初始化pipeline"></a>初始化pipeline</h2><h2 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h2><h1 id="Netty-如何处理-TCP-连接的正常关闭-异常关闭-半关闭场景"><a href="#Netty-如何处理-TCP-连接的正常关闭-异常关闭-半关闭场景" class="headerlink" title="Netty 如何处理 TCP 连接的正常关闭, 异常关闭, 半关闭场景"></a>Netty 如何处理 TCP 连接的正常关闭, 异常关闭, 半关闭场景</h1><h2 id="TCP连接正常关闭"><a href="#TCP连接正常关闭" class="headerlink" title="TCP连接正常关闭"></a>TCP连接正常关闭</h2><h2 id="Netty处理TCP连接正常关闭"><a href="#Netty处理TCP连接正常关闭" class="headerlink" title="Netty处理TCP连接正常关闭"></a>Netty处理TCP连接正常关闭</h2><h2 id="TCP连接异常关闭"><a href="#TCP连接异常关闭" class="headerlink" title="TCP连接异常关闭"></a>TCP连接异常关闭</h2><h2 id="Netty对RST包的处理"><a href="#Netty对RST包的处理" class="headerlink" title="Netty对RST包的处理"></a>Netty对RST包的处理</h2><h2 id="TCP连接半关闭HalfClosure"><a href="#TCP连接半关闭HalfClosure" class="headerlink" title="TCP连接半关闭HalfClosure"></a>TCP连接半关闭HalfClosure</h2><h2 id="主动关闭方发起TCP半关闭"><a href="#主动关闭方发起TCP半关闭" class="headerlink" title="主动关闭方发起TCP半关闭"></a>主动关闭方发起TCP半关闭</h2><h2 id="被动关闭放处理TCP半关闭"><a href="#被动关闭放处理TCP半关闭" class="headerlink" title="被动关闭放处理TCP半关闭"></a>被动关闭放处理TCP半关闭</h2><hr><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483737&idx=1&sn=7ef3afbb54289c6e839eed724bb8a9d6">聊聊Netty那些事儿之从内核角度看IO模型</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483907&idx=1&sn=084c470a8fe6234c2c9461b5f713ff30">聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484005&idx=1&sn=52f51269902a58f40d33208421109bc3">详细图解Netty Reactor启动全流程</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484087&idx=1&sn=0c065780e0f05c23c8e6465ede86cba0">一文聊透Netty核心引擎Reactor的运转架构</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484184&idx=1&sn=726877ce28cf6e5d2ac3225fae687f19">抓到Netty一个Bug, 聊一下Netty是如何高效接收网络连接的</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484244&idx=1&sn=831060fc38caa201d69f87305de7f86a">Netty如何高效接收网络数据？ByteBuffer动态自适应扩缩容机制</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484419&idx=1&sn=3a75a495f0f117cca1548da1e0f3e6e6">抓到Netty一个内存泄露Bug | 详解Recycler对象池的设计与实现</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484532&idx=1&sn=c3a8b37a2eb09509d9914494ef108c68">Netty发送数据全流程</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484823&idx=1&sn=9396fb0f5dbac5e32d0fa1129d385fbc">Netty IO 事件的编排利器 pipeline | 所有 IO 事件的触发时机以及传播路径</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247485060&idx=1&sn=736360af6eb3a4db496de2d6665ebd3c">Netty 如何应对 TCP 连接的正常关闭, 异常关闭, 半关闭场景</a></p>]]></content>
    
    
    <summary type="html">《聊聊Netty那些事》bin的技术小屋, 保留一些重要的内容和有很多形象的配图</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="Netty" scheme="https://hahahaha123567.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>处理HTTP接口上传文件大小超限异常</title>
    <link href="https://hahahaha123567.github.io/2022-05-13-HTTP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%B6%85%E9%99%90%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9EHTTP-body.html"/>
    <id>https://hahahaha123567.github.io/2022-05-13-HTTP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%B6%85%E9%99%90%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9EHTTP-body.html</id>
    <published>2022-05-12T16:00:00.000Z</published>
    <updated>2022-07-27T01:51:09.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一个上传文件的HTTP POST接口，传参使用form-data格式，后端Java服务使用<code>MultipartFile</code>接收，在上传大文件后接口返回nginx 413错误</p><p>测试环境浏览器的请求直接发到应用服务器，请求发到80端口后nginx根据不同前缀将请求转发到对应Java服务的监听端口</p><h1 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h1><h2 id="nginx限制"><a href="#nginx限制" class="headerlink" title="nginx限制"></a>nginx限制</h2><p>nginx限制请求的大小，配置<code>client_max_body_size</code>生效，判断HTTP请求的大小依据是header中的<code>Content-Length</code>值</p><ul><li>size &lt; client_body_buffer_size, 请求留在内存中</li><li>client_body_buffer_size &lt; size &lt; client_max_body_size, 请求保存在临时文件中</li><li>client_max_body_size &lt; size, 返回413 Request Entity Too Large错误</li></ul><p><a href="https://blog.51cto.com/tinywan/2867647">Nginx系列 | [转]Nginx 上传文件：client_max_body_size 、client_body_buffer_size_Tinywan的技术博客_51CTO博客</a></p><p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size">Module ngx_http_core_module client_body_buffer_size</a></p><p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">Module ngx_http_core_module client_max_body_size</a></p><p>调大<code>client_max_body_size</code>值后，请求成功发送到后端服务，但是返回的response body为空</p><h2 id="文件过大抛出异常"><a href="#文件过大抛出异常" class="headerlink" title="文件过大抛出异常"></a>文件过大抛出异常</h2><p>查看后端服务日志，系统抛出了异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.multipart.MaxUploadSizeExceededException: Maximum upload size of 104857600 bytes exceeded; nested exception is org.apache.commons.fileupload.FileUploadBase$SizeLimitExceededException: the request was rejected because its size (113107647) exceeds the configured maximum (104857600)</span><br><span class="line">at org.springframework.web.multipart.commons.CommonsMultipartResolver.parseRequest(CommonsMultipartResolver.java:162)</span><br><span class="line">at org.springframework.web.multipart.commons.CommonsMultipartResolver$1.initializeMultipart(CommonsMultipartResolver.java:134)</span><br><span class="line">at org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest.getMultipartFiles(AbstractMultipartHttpServletRequest.java:140)</span><br><span class="line">at org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest.getFiles(AbstractMultipartHttpServletRequest.java:92)</span><br><span class="line">Caused by: org.apache.commons.fileupload.FileUploadBase$SizeLimitExceededException: the request was rejected because its size (113107647) exceeds the configured maximum (104857600)</span><br><span class="line">at org.apache.commons.fileupload.FileUploadBase$FileItemIteratorImpl.&lt;init&gt;(FileUploadBase.java:968)</span><br><span class="line">at org.apache.commons.fileupload.FileUploadBase.getItemIterator(FileUploadBase.java:310)</span><br><span class="line">at org.apache.commons.fileupload.FileUploadBase.parseRequest(FileUploadBase.java:334)</span><br><span class="line">at org.apache.commons.fileupload.servlet.ServletFileUpload.parseRequest(ServletFileUpload.java:115)</span><br><span class="line">at org.springframework.web.multipart.commons.CommonsMultipartResolver.parseRequest(CommonsMultipartResolver.java:158)</span><br><span class="line">... 50 common frames omitted</span><br></pre></td></tr></table></figure><p>可以看到，spring-web使用commons-fileupload包处理文件上传，限制文件大小<code>FileUploadBase</code>的<code>sizeMax</code>，参考类<code>CommonsFileUploadSupport</code>的相关初始化逻辑和<code>DispatcherServletAutoConfiguration.DispatcherServletConfiguration</code>的<code>multipartResolver</code>的注入逻辑，可以自定义一个MultipartResolver设置size限制并注入框架</p><p>本系统自定义一个<code>multipartResolver</code>并<code>setMaxUploadSize(100 * 1024 * 1024)</code>，限制文件最大100M，文件过大就会抛出上面的<code>MaxUploadSizeExceededException</code>和<code>FileUploadBase$SizeLimitExceededException</code></p><p>因此我在自定义的<code>GlobalExceptionResolver</code>中加入对这两个exception的处理，打印日志并返回错误信息</p><p>上传大文件后在<strong>测试</strong>环境进行测试，该异常被捕获并执行了处理逻辑，但是前端收到的response依然没有HTTP body。奇怪的是，使用postman请求<strong>本地</strong>的后端服务可以正常返回错误信息</p><h2 id="跟踪写HTTP-response的过程"><a href="#跟踪写HTTP-response的过程" class="headerlink" title="跟踪写HTTP response的过程"></a>跟踪写HTTP response的过程</h2><p>初步排查思路是跟踪spring-web把对象写到http body中的过程，查找是哪一步出了问题</p><p>debug排查发现，我们在<code>DispatcherServlet</code>中处理的<code>HttpServletRequest request</code>实体是tomcat的<code>RequestFacade</code>，使用facade外观模式，核心是<code>org.apache.catalina.connector.Request request</code>的<code>org.apache.coyote.Request coyoteRequest</code></p><p>将对象写入http body的json序列化流程正常，但是我注意到本地环境的response header有一项<code>Transfer-Encoding: chunked</code>，测试环境的response header中没有这一项而多了<code>Connection: close</code>。body的写入使用outputStream，导致本地调试无法看到body值，header中的这个区别有可能就是导致测试环境异常的原因，因此我们开始检查是哪一步设置的connection&#x3D;close</p><p>跟踪调用栈：</p><ul><li>DispatcherServlet.doService()</li><li>DispatcherServlet.doDispatch()</li><li>DispatcherServlet.processDispatchResult()</li><li>DispatcherServlet.render()</li><li>AbstractView.render()</li><li>AbstractJackson2View.renderMergedOutputModel(), 从这里开始就是单纯的对象序列化为json字符串</li><li>AbstractJackson2View.writeContent()</li><li>com.fasterxml.jackson.databind.ObjectMapper.writeValue()</li><li>DefaultSerializerProvider.serializeValue()</li><li>DefaultSerializerProvider._serialize()</li><li>serialize()</li></ul><p>但是流程中观察到的对body流的写入都是正常的，各种字段类型的序列化也都使用了正确的序列化类，也没有找到设置connection的逻辑</p><h2 id="监测HTTP-header的写操作"><a href="#监测HTTP-header的写操作" class="headerlink" title="监测HTTP header的写操作"></a>监测HTTP header的写操作</h2><p>从序列化流程开始逐步跟踪没有找到修改时机，我们改为监控所有修改response header操作，找到目标后再根据调用栈查看修改操作的调用方</p><p>response header最终保存在<code>org.apache.coyote.Request coyoteRequest</code>的<code>headers</code>字段中，所以我们在<code>MimeHeaders</code>类的<code>addValue()</code>和<code>setValue()</code>中打断点观察，最终发现是tomcat的<code>Http11Processor</code>在返回response前对消息体进行了统一修改，以符合各种RFC协议的要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When committing the response, we have to validate the set of headers, as well as setup the response filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">entityBody</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    contentDelimitation = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    OutputFilter[] outputFilters = outputBuffer.getFilters();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http09 == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// HTTP/0.9</span></span><br><span class="line">        outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]);</span><br><span class="line">        outputBuffer.commit();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> response.getStatus();</span><br><span class="line">    <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode == <span class="number">204</span> || statusCode == <span class="number">205</span> ||</span><br><span class="line">            statusCode == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="comment">// No entity body</span></span><br><span class="line">        outputBuffer.addActiveFilter</span><br><span class="line">            (outputFilters[Constants.VOID_FILTER]);</span><br><span class="line">        entityBody = <span class="literal">false</span>;</span><br><span class="line">        contentDelimitation = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="number">205</span>) &#123;</span><br><span class="line">            <span class="comment">// RFC 7231 requires the server to explicitly signal an empty response in this case</span></span><br><span class="line">            response.setContentLength(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setContentLength(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for compression</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isCompressible</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">useCompression</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (entityBody &amp;&amp; (compressionLevel &gt; <span class="number">0</span>) &amp;&amp; sendfileData == <span class="literal">null</span>) &#123;</span><br><span class="line">        isCompressible = isCompressible();</span><br><span class="line">        <span class="keyword">if</span> (isCompressible) &#123;</span><br><span class="line">            useCompression = useCompression();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Change content-length to -1 to force chunking</span></span><br><span class="line">        <span class="keyword">if</span> (useCompression) &#123;</span><br><span class="line">            response.setContentLength(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">MimeHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> response.getMimeHeaders();</span><br><span class="line">    <span class="comment">// A SC_NO_CONTENT response may include entity headers</span></span><br><span class="line">    <span class="keyword">if</span> (entityBody || statusCode == HttpServletResponse.SC_NO_CONTENT) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> response.getContentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">            headers.setValue(<span class="string">&quot;Content-Type&quot;</span>).setString(contentType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentLanguage</span> <span class="operator">=</span> response.getContentLanguage();</span><br><span class="line">        <span class="keyword">if</span> (contentLanguage != <span class="literal">null</span>) &#123;</span><br><span class="line">            headers.setValue(<span class="string">&quot;Content-Language&quot;</span>)</span><br><span class="line">                .setString(contentLanguage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add date header unless application has already set one (e.g. in a Caching Filter)</span></span><br><span class="line">    <span class="keyword">if</span> (headers.getValue(<span class="string">&quot;Date&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        headers.addValue(<span class="string">&quot;Date&quot;</span>).setString(</span><br><span class="line">                FastHttpDateFormat.getCurrentDate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entityBody) &amp;&amp; (!contentDelimitation)) &#123;</span><br><span class="line">        <span class="comment">// Mark as close the connection after the request, and add the connection: close header</span></span><br><span class="line">        keepAlive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This may disabled keep-alive to check before working out the Connection header.</span></span><br><span class="line">    checkExpectationAndResponseStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know that the request is bad this early, add the Connection: close header.</span></span><br><span class="line">    <span class="keyword">if</span> (keepAlive &amp;&amp; statusDropsConnection(statusCode)) &#123;</span><br><span class="line">        keepAlive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!keepAlive) &#123;</span><br><span class="line">        <span class="comment">// Avoid adding the close header twice</span></span><br><span class="line">        <span class="keyword">if</span> (!connectionClosePresent) &#123;</span><br><span class="line">            headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!http11 &amp;&amp; !getErrorState().isError()) &#123;</span><br><span class="line">        headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outputBuffer.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么本地环境和测试环境的区别在哪里呢？在最后判断Connection为close还是keep-alive的时候，processor根据请求的http版本执行不同操作，本地环境读到的是HTTP1.1，而测试环境读到的是HTTP1.0，就设置为了close。在浏览器的控制台-network中看到的protocol明明是h2，为什么后端服务读取到的是1.0呢？</p><p><a href="https://www.zhihu.com/question/321943562">浏览器发起http请求时候，如何知道服务器支持什么http 版本？ - 知乎</a><br><a href="https://segmentfault.com/q/1010000010612052">HTTP的版本是什么决定的，浏览器，服务器？ - SegmentFault 思否</a></p><p>越过nginx直接指定端口请求测试环境的服务，正常返回response body，因此判断是浏览器客户端和服务器协商HTTP版本时由于nginx限制没有成功使用</p><p>nginx增加配置项<code>proxy_http_version 1.1;</code>后，测试环境接口返回成功</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在找到了设置header的代码后再看下之前为什么debug没有跟踪到，设置header的调用栈：</p><ul><li>UTF8JsonGenerator.flush()</li><li>CoyoteOutputStream.flush()</li><li>org.apache.catalina.connector.OutputBuffer.flush()</li><li>OutputBuffer.doFlush()</li><li>org.apache.coyote.Response.sendHeaders()</li><li>Response.action(), 这里的hook是<code>Http11Processor</code></li><li>AbstractProcessor.prepareResponse()</li><li>Http11Processor.prepareResponse()</li></ul><p>谁能想到名为<code>OutputStream</code>和<code>OutputBuffer</code>的类的flush方法竟然会执行这么多业务操作呢:(</p><p>POSTMAN不支持指定HTTP1.0，有这个需求可以导出curl指令后使用curl实现，增加<code>-0</code>参数</p><p><a href="https://community.postman.com/t/how-to-change-http-protocol-version-to-http-1-0/3963">How to change HTTP protocol version to HTTP 1.0 - Help - Postman</a></p><p>在网上看到其他人遇到的相似问题</p><p><a href="https://blog.csdn.net/qq_38531706/article/details/117448200">Nginx proxy_http_version默认值引发的问题__alone_的博客-CSDN博客_proxy_http_version</a></p>]]></content>
    
    
    <summary type="html">从HTTP接口上传文件大小超限异常查起，发现了当前业务系统存在的许多问题</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《凤凰架构》读书摘要</title>
    <link href="https://hahahaha123567.github.io/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hahahaha123567.github.io/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-05-13T02:46:06.618Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://icyfenix.cn/summary/">原文链接</a></p><h1 id="服务架构演进史"><a href="#服务架构演进史" class="headerlink" title="服务架构演进史"></a>服务架构演进史</h1><h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><blockquote><p>UNIX 的分布式设计哲学 保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要</p></blockquote><p>在 20 世纪 70 年代末期到 80 年代初，计算机科学刚经历了从以大型机为主向以微型机为主的蜕变，当时计算机硬件局促的运算处理能力，已直接妨碍到了在单台计算机上信息系统软件能够达到的最大规模</p><p>某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果</p><p>20 世纪 80 年代正是摩尔定律开始稳定发挥作用的黄金时期，信息系统进入了以单台或少量几台计算机即可作为服务器来支撑大型信息系统运作的单体时代</p><h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><blockquote><p>单体架构（Monolithic） “单体”只是表明系统中主要的过程调用都是进程内调用，不会发生进程间通信，仅此而已</p></blockquote><p>对于小型系统——即由单台机器就足以支撑其良好运行的系统，单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信（Inter-Process Communication，IPC），因此也是运行效率最高的一种架构风格</p><p><strong>优点</strong></p><ul><li><p>易于开发、易于测试、易于部署</p></li><li><p>由于所有代码都运行在同一个进程空间之内，所有模块、方法的调用都无须考虑网络分区、对象复制这些麻烦的事和性能损失</p></li></ul><p><strong>缺点</strong></p><ul><li><p>如果任何一部分代码出现了缺陷，过度消耗了进程空间内的资源，所造成的影响也是全局性的、难以隔离的。譬如内存泄漏、线程爆炸、阻塞、死循环等问题，都将会影响整个程序，而不仅仅是影响某一个功能、模块本身的正常运作。如果消耗的是某些更高层次的公共资源，譬如端口号或者数据库连接池泄漏，影响还将会波及整台机器，甚至是集群中其他单体副本的正常工作</p></li><li><p>由于所有代码都共享着同一个进程空间，不能隔离，也就无法（其实还是有办法的，譬如使用 OSGi 这种运行时模块化框架，但是很别扭、很复杂）做到单独停止、更新、升级某一部分代码，所以从可维护性来说，单体系统也是不占优势的</p></li><li><p>难以技术异构，每个模块的代码都通常需要使用一样的程序语言，乃至一样的编程框架去开发。单体系统的技术栈异构并非一定做不到，譬如 JNI 就可以让 Java 混用 C 或 C++，但这通常是迫不得已的，并不是优雅的选择</p></li><li><p>单体系统很难兼容“Phoenix”的特性。这种架构风格潜在的观念是希望系统的每一个部件，每一处代码都尽量可靠，靠不出或少出缺陷来构建可靠系统。然而战术层面再优秀，也很难弥补战略层面的不足，单体靠高质量来保证高可靠性的思路，在小规模软件上还能运作良好，但系统规模越大，交付一个可靠的单体系统就变得越来越具有挑战性</p></li></ul><h2 id="SOA时代"><a href="#SOA时代" class="headerlink" title="SOA时代"></a>SOA时代</h2><blockquote><p>SOA 架构（Service-Oriented Architecture） 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式</p></blockquote><ol><li>烟囱式架构, 完全不与其他相关信息系统进行互操作或者协调工作的设计模式</li><li>微内核架构（Microkernel Architecture）：也被称为插件式架构（Plug-in Architecture）将主数据，连同其他可能被各子系统使用到的公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心（Kernel），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样可提供可扩展的、灵活的、天然隔离的功能特性</li><li>事件驱动架构（Event-Driven Architecture）：在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去，如此，每一个消息的处理者都是独立的，高度解耦的，但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动</li></ol><ul><li>领导制定技术标准的组织 Open CSA</li><li>明确了采用 SOAP 作为远程调用的协议，依靠 SOAP 协议族（WSDL、UDDI 和一大票 WS-*协议）来完成服务的发布、发现和治理</li><li>利用一个被称为企业服务总线（的消息管道来实现各个子系统之间的通信交互</li><li>使用服务数据对象来访问和表示数据</li><li>使用服务组件架构来定义服务封装的形式和服务运行的容器</li></ul><p><strong>缺点</strong></p><p>过于严格的规范定义带来过度的复杂性。而构建在 SOAP 基础之上的 ESB、BPM、SCA、SDO 等诸多上层建筑，进一步加剧了这种复杂性</p><h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><blockquote><p>微服务架构（Microservices）<br>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</p></blockquote><p>微服务追求的是更加自由的架构风格，摒弃了几乎所有 SOA 里可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”</p><h2 id="后微服务时代"><a href="#后微服务时代" class="headerlink" title="后微服务时代"></a>后微服务时代</h2><blockquote><p>后微服务时代（Cloud Native）<br>从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”</p></blockquote><p>以 Docker Swarm、Apache Mesos 与 Kubernetes 为主要竞争者的“容器编排战争”终于有了明确的结果，Kubernetes 登基加冕是容器发展中一个时代的终章，也将是软件架构发展下一个纪元的开端</p><p>传统 Spring Cloud 与 Kubernetes 提供的解决方案对比</p><table><thead><tr><th>Kubernetes</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>弹性伸缩</td><td>Autoscaling N&#x2F;A</td></tr><tr><td>服务发现</td><td>KubeDNS, CoreDNS Spring Cloud Eureka</td></tr><tr><td>配置中心</td><td>ConfigMap, Secret Spring Cloud Config</td></tr><tr><td>服务网关</td><td>Ingress Controller Spring Cloud Zuul</td></tr><tr><td>负载均衡</td><td>Load Balancer Spring Cloud Ribbon</td></tr><tr><td>服务安全</td><td>RBAC API Spring Cloud Security</td></tr><tr><td>跟踪监控</td><td>Metrics API, Dashboard Spring Cloud Turbine</td></tr><tr><td>降级熔断</td><td>N&#x2F;A Spring Cloud Hystrix</td></tr></tbody></table><p>仅从功能上看，单纯的 Kubernetes 反而不如之前的 Spring Cloud 方案。这是因为有一些问题处于应用系统与基础设施的边缘，使得完全在基础设施层面中确实很难精细化地处理。通过 Spring Cloud 这类应用代码实现的微服务中并不难处理，既然是使用程序代码来解决问题，只要合乎逻辑，想要实现什么功能，只受限于开发人员的想象力与技术能力，但基础设施是针对整个容器来管理的，粒度相对粗旷，只能到容器层面，对单个远程服务就很难有效管控</p><p>为了解决这一类问题，虚拟化的基础设施很快完成了第二次进化，引入了今天被称为“服务网格”（Service Mesh）的“边车代理模式”（Sidecar Proxy）</p><p>由系统自动在服务容器（通常是指 Kubernetes 的 Pod）中注入一个通信代理服务器，以类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理</p><h2 id="无服务时代"><a href="#无服务时代" class="headerlink" title="无服务时代"></a>无服务时代</h2><blockquote><p>无服务架构（Serverless）如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布式”的云端系统这条路的起点</p></blockquote><p>只涉及两块内容：后端设施（Backend）和函数（Function）</p><ul><li>后端设施是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，无服务中称其为“后端即服务”（Backend as a Service，BaaS）</li><li>函数是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，不必考虑容量规划（从技术角度可以不考虑，从计费的角度你的钱包够不够用还是要掂量一下的），无服务中称其为“函数即服务”（Function as a Service，FaaS）</li></ul><p>无服务架构对一些适合的应用确实能够降低开发和运维环节的成本，譬如不需要交互的离线大规模计算，又譬如多数 Web 资讯类网站、小程序、公共 API 服务、移动应用服务端等都契合于无服务架构所擅长的短链接、无状态、适合事件驱动的交互形式；但另一方面，对于那些信息管理系统、网络游戏等应用，又或者说所有具有业务逻辑复杂，依赖服务端状态，响应速度要求较高，需要长链接等这些特征的应用，至少目前是相对并不适合的</p><p>顺序上笔者将“无服务”安排到了“微服务”和“云原生”时代之后，但它们两者并没有继承替代关系，笔者相信软件开发的未来不会只存在某一种“最先进的”架构风格，多种具针对性的架构风格同时并存，是软件产业更有生命力的形态</p><h1 id="架构师的视角"><a href="#架构师的视角" class="headerlink" title="架构师的视角"></a>架构师的视角</h1><h2 id="访问远程服务"><a href="#访问远程服务" class="headerlink" title="访问远程服务"></a>访问远程服务</h2><h3 id="远程服务调用"><a href="#远程服务调用" class="headerlink" title="远程服务调用"></a>远程服务调用</h3><h4 id="调用本地方法"><a href="#调用本地方法" class="headerlink" title="调用本地方法"></a>调用本地方法</h4><ol><li>传递方法参数</li><li>确定方法版本</li><li>执行被调方法</li><li>返回执行结果</li></ol><p>1&#x2F;4依赖栈内存, 2依赖程序语言定义</p><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ol><li>管道, 在进程间传递少量的字符流或字节流</li><li>信号, 通知目标进程有某种事件发生, kill即shell向进程发送信号</li><li>信号量, wait() notify()</li><li>共享内存</li><li>Socket, 支持远程</li></ol><h4 id="分布式计算的八宗罪"><a href="#分布式计算的八宗罪" class="headerlink" title="分布式计算的八宗罪"></a>分布式计算的八宗罪</h4><ol><li>The network is reliable —— 网络是可靠的</li><li>Latency is zero —— 延迟是不存在的</li><li>Bandwidth is infinite —— 带宽是无限的</li><li>The network is secure —— 网络是安全的</li><li>Topology doesn’t change —— 拓扑结构是一成不变的</li><li>There is one administrator —— 总会有一个管理员</li><li>Transport cost is zero —— 不必考虑传输成本</li><li>The network is homogeneous —— 网络是同质化的</li></ol><h4 id="RPC的三个基本问题"><a href="#RPC的三个基本问题" class="headerlink" title="RPC的三个基本问题"></a>RPC的三个基本问题</h4><ol><li>如何表示数据, 各种协议</li><li>如何传递数据, 除了传输层的UDP&#x2F;TCP, 还包括应用层的wire protocal, 异常、超时、安全、认证、授权、事务等</li><li>如何确定方法</li></ol><h4 id="RPC的发展方向"><a href="#RPC的发展方向" class="headerlink" title="RPC的发展方向"></a>RPC的发展方向</h4><ol><li>面向对象, 不满足于 RPC 将面向过程的编码方式带到分布式，希望在分布式系统中也能够进行跨进程的面向对象编程，代表为 RMI、.NET Remoting</li><li>性能, 代表为 gRPC 和 Thrift, 决定 RPC 性能的主要就两个因素：序列化效率和信息密度。序列化效率很好理解，序列化输出结果的容量越小，速度越快，效率自然越高；信息密度则取决于协议中有效荷载（Payload）所占总传输数据的比例大小，使用传输协议的层次越高，信息密度就越低，SOAP 使用 XML 拙劣的性能表现就是前车之鉴。gRPC 和 Thrift 都有自己优秀的专有序列化器，而传输协议方面，gRPC 是基于 HTTP&#x2F;2 的，支持多路复用和 Header 压缩，Thrift 则直接基于传输层的 TCP 协议来实现，省去了额外应用层协议的开销</li><li>简化, 代表为 JSON-RPC</li></ol><h3 id="REST-设计风格"><a href="#REST-设计风格" class="headerlink" title="REST 设计风格"></a>REST 设计风格</h3><p>表征状态转移</p><ul><li>面向过程编程时，为什么要以算法和处理过程为中心，输入数据，输出结果？是为了符合计算机世界中主流的交互方式</li><li>面向对象编程时，为什么要将数据和行为统一起来、封装成对象？是为了符合现实世界的主流的交互方式</li><li>面向资源编程时，为什么要将数据（资源）作为抽象的主体，把行为看作是统一的接口？是为了符合网络世界的主流的交互方式</li></ul><h4 id="REST六大原则"><a href="#REST六大原则" class="headerlink" title="REST六大原则"></a>REST六大原则</h4><ul><li>服务端与客户端分离</li><li>无状态</li><li>可缓存</li><li>分层系统</li><li>统一接口</li><li>按需代码</li></ul><h4 id="REST好处"><a href="#REST好处" class="headerlink" title="REST好处"></a>REST好处</h4><ol><li>降低的服务接口的学习成本</li><li>资源天然具有集合与层次结构</li><li>REST 绑定于 HTTP 协议</li></ol><h4 id="REST缺点"><a href="#REST缺点" class="headerlink" title="REST缺点"></a>REST缺点</h4><ol><li>REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中</li><li>REST 没有传输可靠性支持</li><li>REST 缺乏对资源进行“部分”和“批量”的处理能力</li></ol><p>一种理论上较优秀的可以解决以上这几类问题的方案是GraphQL，这是由 Facebook 提出并开源的一种面向资源 API 的数据查询语言。比起依赖 HTTP 无协议的 REST，GraphQL 可以说是另一种“有协议”的、更彻底地面向资源的服务方式。然而凡事都有两面，离开了 HTTP，它又面临着几乎所有 RPC 框架所遇到的那个如何推广交互接口的问题。</p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul><li>一致性（Consistency）系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾</li><li>原子性（Atomic）在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销</li><li>隔离性（Isolation）在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响</li><li>持久性（Durability）事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据</li></ul><p>A、I、D 是手段，C 是目的</p><p>当一个服务只使用一个数据源时，通过 A、I、D 来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为__内部一致性__</p><p>当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，问题就变得相对困难了许多。此时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为__外部一致性__</p><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>直接依赖于数据源本身提供的事务能力来工作的，在程序代码层面，最多只能对事务接口做一层标准化的包装（如 JDBC 接口），与后续介绍的 XA、TCC、SAGA 等主要靠应用程序代码来实现的事务有着十分明显的区别</p><h4 id="实现原子性和隔离性"><a href="#实现原子性和隔离性" class="headerlink" title="实现原子性和隔离性"></a>实现原子性和隔离性</h4><p>写入中间状态与崩溃都不可能消除，所以如果不做额外保障措施的话，将内存中的数据写入磁盘，并不能保证原子性与持久性</p><p>使用 <strong>Commit Logging</strong> 实现</p><p>Commit Logging基于ARIES理论</p><p>将修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等，以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化</p><p>Write-Ahead Logging, 当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除</p><h4 id="实现隔离性"><a href="#实现隔离性" class="headerlink" title="实现隔离性"></a>实现隔离性</h4><p>现代数据库均提供了以下三种锁</p><ul><li>写锁（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）</li><li>读锁（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）</li><li>范围锁（Range Lock）, 在MySQL中实现为gap lock</li></ul><p>四个隔离级别</p><table><thead><tr><th>隔离级别</th><th>使用的锁</th><th>存在问题</th></tr></thead><tbody><tr><td>读未提交(Read Uncommitted)</td><td>写锁持续至事务结束,无读锁</td><td>脏读:在事务执行过程中,一个事务读取到了另一个事务未提交的数据(读数据不需要加读锁,写锁就限制不了读操作了)</td></tr><tr><td>读已提交(Read Committed)</td><td>写锁持续至事务结束,读锁在操作完成后马上释放</td><td>不可重复读:在事务执行过程中,对同一行数据的两次查询得到了不同的结果,即读到了另一个事务已提交的数据(写锁释放太早,限制不到其他事务加读锁)</td></tr><tr><td>可重复读(Repeatable Read)</td><td>写锁、读锁持续至事务结束</td><td>幻读:在事务执行过程中,两个完全相同的范围查询得到了不同的结果集,没有范围锁来禁止在该范围内插入新的数据</td></tr><tr><td>可串行化(Serializable)</td><td>写锁、读锁、范围所持续至事务结束</td><td>-</td></tr></tbody></table><h4 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h4><p>幻读、不可重复读、脏读等问题都是由于一个事务在读数据过程中，受另外一个写数据的事务影响而破坏了隔离性，针对这种“一个事务读+另一个事务写”的隔离问题，近年来有一种名为“多版本并发控制”（Multi-Version Concurrency Control，MVCC）的无锁优化方案被主流的商业数据库广泛采用。MVCC 是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的</p><h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><p>单个服务使用多个数据源场景</p><p>X&#x2F;Open组织（后来并入了The Open Group）提出了一套名为X&#x2F;Open XA（XA 是 eXtended Architecture 的缩写）的处理事务架构，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口</p><p>Java 中专门定义了JSR 907 Java Transaction API，基于 XA 模式在 Java 语言中的实现了全局事务处理的标准，这也就是我们现在所熟知的 JTA。JTA 最主要的两个接口是：</p><ol><li>事务管理器的接口：javax.transaction.TransactionManager。这套接口是给 Java EE 服务器提供容器事务（由容器自动负责事务管理）使用的，还提供了另外一套javax.transaction.UserTransaction接口，用于通过程序代码手动开启、提交和回滚事务。</li><li>满足 XA 规范的资源定义接口：javax.transaction.xa.XAResource，任何资源（JDBC、JMS 等等）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可</li></ol><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>XA 将事务提交拆分成为两阶段过程，“两段式提交”（2 Phase Commit，2PC）协议，协调者、参与者都是可以由数据库自己来扮演的，不需要应用程序介入。协调者一般是在参与者之间选举产生的，而应用程序相对于数据库来说只扮演客户端的角色</p><ol><li><p>准备阶段：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态</p></li><li><p>提交阶段：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作</p></li></ol><p>2PC的前提条件: </p><ol><li><p>必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息</p></li><li><p>必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态，当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，并向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作</p></li></ol><p>2PC的缺点:</p><ol><li><p>单点问题：协调者</p></li><li><p>性能问题：要经过两次远程服务调用，三次数据持久化</p></li><li><p>一致性风险：需要前提条件</p></li></ol><h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ol><li>canCommit，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成</li><li>preCommit</li><li>doCommit，未收到协调者返回，参与者默认的操作策略将是提交事务</li></ol><p>将2PC的prepare阶段分成两部分，增加了评估阶段，在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的，但在事务能够正常提交的场景中，两者的性能都依然很差，甚至三段式因为多了一次询问，还要稍微更差一些</p><p>缺点：单点问题、性能问题优于2PC，一致性风险大于2PC</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>多个服务同时访问多个数据源</p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>一个分布式的系统中，涉及共享数据问题时，以下三个特性最多只能同时满足其中两个：</p><ol><li><p>一致性（Consistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的</p></li><li><p>可用性（Availability）：代表系统不间断地提供服务的能力，可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A&#x3D;MTBF&#x2F;（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999%可用，即代表平均年故障修复时间为 32 秒</p></li><li><p>分区容忍性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力</p></li></ol><p>CAP舍弃其中一个:</p><ol><li><p>CA，不追求分区容忍性即认为节点之间通信永远可靠，不是分布式系统</p></li><li><p>CP，网络分区后服务不可用，退化为全局事务，使用2PC&#x2F;3PC，用于对数据要求很高的系统，HBase</p></li><li><p>AP，网络分区后服务可用但不同实例返回的数据可能不同，大部分nosql系统和分布式缓存</p></li></ol><h4 id="可靠事件队列-BASE"><a href="#可靠事件队列-BASE" class="headerlink" title="可靠事件队列 BASE"></a>可靠事件队列 BASE</h4><h4 id="TCC-事务"><a href="#TCC-事务" class="headerlink" title="TCC 事务"></a>TCC 事务</h4><h4 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h4><h2 id="透明多级分流系统"><a href="#透明多级分流系统" class="headerlink" title="透明多级分流系统"></a>透明多级分流系统</h2><p>系统中不同的组件:</p><ul><li>有一些部件位于客户端或网络的边缘，能够迅速响应用户的请求，避免给后方的 I&#x2F;O 与 CPU 带来压力，典型如本地缓存、内容分发网络、反向代理等。</li><li>有一些部件的处理能力能够线性拓展，易于伸缩，可以使用较小的代价堆叠机器来获得与用户数量相匹配的并发性能，应尽量作为业务逻辑的主要载体，典型如集群中能够自动扩缩的服务节点。</li><li>有一些部件稳定服务对系统运行有全局性的影响，要时刻保持着容错备份，维护着高可用性，典型如服务注册中心、配置中心。</li><li>有一些设施是天生的单点部件，只能依靠升级机器本身的网络、存储和运算性能来提升处理能力，如位于系统入口的路由、网关或者负载均衡器（它们都可以做集群，但一次网络请求中无可避免至少有一个是单点的部件）、位于请求调用链末端的传统关系数据库等</li></ul><p>两条原则:</p><ol><li><p>尽可能减少单点部件</p></li><li><p>奥卡姆剃刀原则</p></li></ol><p>几种优化:</p><ul><li>客户端缓存</li><li>域名解析</li><li>传输链路</li><li>内容分发网络</li><li>负载均衡</li><li><a href="http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cache-middleware.html">服务端缓存</a>, 介绍了传统意义上缓存的各个方面</li></ul><h2 id="架构安全性"><a href="#架构安全性" class="headerlink" title="架构安全性"></a>架构安全性</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><ul><li>RBAC, user&#x2F;role&#x2F;authority&#x2F;permission&#x2F;resource</li><li>OAuth2, 解决第三方应用的认证授权协议</li></ul><h3 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h3><ul><li>Cookie-Session, 受制于CAP理论</li><li>JWT, header+payload+sign</li></ul><h3 id="保密"><a href="#保密" class="headerlink" title="保密"></a>保密</h3><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h1 id="分布式的基石"><a href="#分布式的基石" class="headerlink" title="分布式的基石"></a>分布式的基石</h1><h2 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>Multi Paxos 对 Basic Paxos 的核心改进是增加了“选主”的过程</p><p>Raft 算法: 分布式系统中如何对某个值达成一致</p><ol><li>如何选主（Leader Election）</li><li>如何把数据复制到各个节点上（Entity Replication）</li><li>如何保证过程是安全的（Safety）</li></ol><p>Raft 是 Etcd、LogCabin、Consul 等重要分布式程序的实现基础, ZooKeeper 的 ZAB 算法与 Raft 的思路也非常类似，这些算法都被认为是 Multi Paxos 的等价派生实现。</p><h3 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h3><ul><li>强一致性, 尽管系统内部节点可以存在不一致的状态，但从系统外部看来不一致的情况并不会被观察到，所以整体上看系统是强一致性的, Paxos、Raft、ZAB</li><li>最终一致性, 系统中不一致的状态有可能会在一定时间内被外部直接观察到, DNS, Gossip</li></ul><h2 id="从类库到服务"><a href="#从类库到服务" class="headerlink" title="从类库到服务"></a>从类库到服务</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>实现</p><ol><li>全限定名(定位到主机)</li><li>端口号(tcp&#x2F;udp服务)</li><li>服务标识(具体接口)</li></ol><p>功能</p><ol><li>服务注册</li><li>服务维护</li><li>服务发现</li></ol><p>服务注册中心一旦崩溃，整个系统都不再可用，因此必须尽最大努力保证服务发现的可用性</p><p>CAP矛盾</p><ul><li>Eureka，AP，客户端拿到了已经发生变动的错误地址依赖故障转移（Failover）或者快速失败（Failfast）</li><li>Consul，CP</li></ul><p>选择AP&#x2F;CP</p><blockquote><p>假设系统形成了 A、B 两个网络分区后，A 区的服务只能从区域内的服务发现节点获取到 A 区的服务坐标，B 区的服务只能取到在 B 区的服务坐标，这对你的系统会有什么影响？</p></blockquote><ul><li>没有影响，AP</li><li>影响非常之大，甚至可能带来比整个系统宕机更坏的结果，CP</li></ul><p>实现方式</p><ul><li>在分布式 K&#x2F;V 存储框架上自己开发, ZooKeeper(CP), Etcd(CP), Redis(AP)</li><li>以基础设施（主要是指 DNS 服务器）来实现服务发现, SkyDNS、CoreDNS, AP&#x2F;CP取决于怎样实现</li><li>专门用于服务发现的框架和工具, Eureka(AP)、Consul(CP) 和 Nacos(AP&#x2F;CP)</li></ul><h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><p>网关 &#x3D; 路由器（基础职能） + 过滤器（可选职能）</p><p>网关是网络访问中的单点, 地址具有唯一性不能像服务中心一样做集群</p><h4 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h4><p>[以买饭为例]</p><ul><li>同步IO(Synchronous I&#x2F;O)<ul><li>阻塞IO(Blocking I&#x2F;O), 节省 CPU 资源(Java传统IO模型)</li><li>非阻塞IO(Non-Blocking I&#x2F;O), 浪费 CPU 资源(Java的NIO)</li><li>多路复用IO(Multiplexing I&#x2F;O), 主流(通过NIO实现的Reactor模式)</li><li>信号驱动IO(Signal-Driven I&#x2F;O), 需要自己从缓冲区获取数据</li></ul></li><li>异步IO(Asynchronous I&#x2F;O)(通过AIO实现的Proactor模式)</li></ul><h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p>请求的完整路径</p><ol><li>服务发现</li><li>网关路由</li><li>负载均衡</li><li>服务容错</li></ol><p>客户端指集群内部发起服务的进程</p><ul><li>Java, Netflix Ribbon, Spring Cloud Load Balancer</li><li>其他, 代理均衡器</li></ul><h2 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h2><p>服务降级</p><ul><li>出错后弥补</li><li>主动降级</li></ul><h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><p>失败如何弥补</p><ul><li>故障转移, 重试, 服务具备幂等性, 如果调用的服务器出现故障, 自动切换到其他副本</li><li>快速失败, 非幂等的服务, 拒绝重试, 抛出异常</li><li>安全失败, 不影响核心业务的旁路逻辑失败的话返回默认值</li><li>沉默失败, 当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响</li><li>故障恢复, 异步的故障转移<br>调用之前尽量获得最大的成功概率</li><li>并行调用, 同时调用多个副本, 返回一个成功即可</li><li>广播调用, 同时调用多个副本, 必须全部返回成功, 刷新分布式缓存</li></ul><table><thead><tr><th>容错策略</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>故障转移</td><td>系统自动处理，调用者对失败的信息不可见</td><td>增加调用时间，额外的资源开销</td><td>调用幂等服务, 对调用时间不敏感的场景</td></tr><tr><td>快速失败</td><td>调用者有对失败的处理完全控制权, 不依赖服务的幂等性</td><td>调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩</td><td>调用非幂等的服务, 超时阈值较低的场景</td></tr><tr><td>安全失败</td><td>不影响主路逻辑</td><td>只适用于旁路调用</td><td>调用链中的旁路服务</td></tr><tr><td>静默失败</td><td>控制错误不影响全局</td><td>出错的地方将在一段时间内不可用</td><td>频繁超时的服务</td></tr><tr><td>故障恢复</td><td>调用失败后自动重试，也不影响主路逻辑</td><td>重试任务可能产生堆积，重试仍然可能失败</td><td>调用链中的旁路服务, 对实时性要求不高的主路逻辑也可以使用</td></tr><tr><td>并行调用</td><td>尽可能在最短时间内获得最高的成功率</td><td>额外消耗机器资源，大部分调用可能都是无用功</td><td>资源充足且对失败容忍度低的场景</td></tr><tr><td>广播调用</td><td>支持同时对批量的服务提供者发起调用</td><td>资源消耗大，失败概率高</td><td>只适用于批量操作的场景</td></tr></tbody></table><h4 id="容错设计模式"><a href="#容错设计模式" class="headerlink" title="容错设计模式"></a>容错设计模式</h4><ul><li>断路器模式, 快速失败</li><li>舱壁隔离模式, 静默失败<ul><li>局部的线程池来控制服务, 缺点增加了 CPU 的开销, 增加请求延时</li><li>信号量机制, 为每个远程服务维护一个线程安全的计数器</li></ul></li><li>重试模式, 故障转移, 故障恢复<ul><li>仅在主路逻辑的关键服务上进行同步的重试, 尤其不该进行同步重试</li><li>仅对由瞬时故障导致的失败进行重试, 例如用http状态码来判断</li><li>仅对具备幂等性的服务进行重试</li><li>重试必须有明确的终止条件<ul><li>超时</li><li>次数限制</li></ul></li></ul></li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量统计指标</p><ul><li>TPS</li><li>HPS</li><li>QPS</li><li>流量, 登录用户数等</li></ul><p>限流设计模式</p><ul><li>流量计数器, 针对时间点进行离散的统计</li><li>滑动时间窗, 只适用于否决式限流，超过阈值的流量就必须强制失败或降级，很难进行阻塞等待处理</li><li>漏桶, 首先在缓冲区中暂存，然后再在控制算法的调节下均匀地发送这些被缓冲的报文, 不支持支持变动请求处理速率</li><li>令牌桶, 请求获取令牌</li></ul><p>分布式限流</p><ul><li>单机限流模式+各主机共享信息, 网络开销大</li><li>单机限流模式+本地缓存部分信息, 网络开销小, 不准确</li></ul><h3 id="可靠通讯"><a href="#可靠通讯" class="headerlink" title="可靠通讯"></a>可靠通讯</h3><p>基于边界的安全模型: 把网络划分为不同的区域，不同的区域对应于不同风险级别和允许访问的网络资源权限，将安全防护措施集中部署在各个区域的边界之上，重点关注跨区域的网络流量<br>零信任安全模型: 除非明确得到了能代表请求来源的身份凭证，否则一律不会有默认的信任关系</p><h4 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h4><ul><li>日志, Elasticsearch, Logstash(Fluentd), Kibana</li><li>追踪</li><li>度量, Java的JMX(单机), Kubernetes的Prometheus, Zabbix</li></ul><h1 id="不可变基础设施"><a href="#不可变基础设施" class="headerlink" title="不可变基础设施"></a>不可变基础设施</h1><p>云原生: 微服务, 容器网格, 不可变基础设施, 声明式API</p><p>软件兼容性</p><ul><li>ISA兼容: 机器指令集, x86&#x2F;ARM</li><li>ABI兼容: 操作系统或二进制库, Windows&#x2F;Linux, DirectX9&#x2F;DirectX12</li><li>环境兼容: 配置文件等</li></ul><p>虚拟化技术</p><ul><li>指令集虚拟化, 软件模拟指令集</li><li>硬件抽象层虚拟化, 以软件或者直接通过硬件来模拟处理器、芯片组、内存、磁盘控制器、显卡等设备, 虚拟机, VMware ESXi和Hyper-V</li><li>操作系统层虚拟化, 容器化, 只能提供操作系统内核以上的部分 ABI 兼容性与完整的环境兼容性</li><li>运行库虚拟化, 以一个独立进程来代替操作系统内核来提供目标软件运行所需的全部能力, WINE, WSL1</li><li>语言层虚拟化, 由虚拟机将高级语言生成的中间代码转换为目标机器可以直接执行的指令，Java 的 JVM 和.NET 的 CLR</li></ul><h2 id="虚拟化容器"><a href="#虚拟化容器" class="headerlink" title="虚拟化容器"></a>虚拟化容器</h2><p>容器的最初目的: 隔离资源</p><ul><li>隔离文件: chroot, 当某个进程经过chroot操作之后，它或者它的子进程将不能再访问和操作该目录之外的其他文件</li><li>隔离访问：namespaces, 由内核直接提供的全局资源封装，是内核针对进程设计的访问隔离机制, 不仅文件系统是独立的，还有着独立的 PID 编号、UID&#x2F;GID 编号、网络</li><li>隔离资源：cgroups, 由内核提供的功能，用于隔离或者说分配并限制某个进程组能够使用的资源配额，包括处理器时间、内存大小、磁盘 I&#x2F;O 速度等</li><li>封装系统：LXC, LXC封装系统, Docker封装应用</li><li>封装应用：Docker</li><li>封装集群：Kubernetes, Docker Engine 经历从不可或缺、默认依赖、可选择、直到淘汰是大概率事件</li></ul><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Docker 提倡单个容器封装单进程应用, 因为 Docker 只能通过监视 PID 为 1 的进程（即由 ENTRYPOINT 启动的进程）的运行状态来判断容器的工作状态是否正常</p><p>Docker Compose 可以设置不同的容器共享volume, 共享 IPC 名称空间</p><p>容器的本质是对 cgroups 和 namespaces 所提供的隔离能力的一种封装，然而 Linux 的 cgroups 和 namespaces 原本都是针对进程组而不仅仅是单个进程来设计的，同一个进程组中的多个进程天然就可以共享着相同的访问权限与资源配额, Kubernetes 里的 Pod</p><p>容器协作</p><ul><li>普通非亲密的容器, 以网络交互方式（其他譬如共享分布式存储来交换信息也算跨网络）</li><li>亲密协作的容器，被调度到同一个集群节点上，可以通过共享本地磁盘等方式协作</li><li>超亲密的协作, 特指多个容器位于同一个 Pod, 共享: UTS 名称空间, 网络名称空间, IPC 名称空间, 时间名称空间</li></ul><p>Kubernetes 将一切皆视为资源，不同资源之间依靠层级关系相互组合协作</p><ul><li>container, 延续了自 Docker 以来一个容器封装一个应用进程的理念，是镜像管理的最小单位</li><li>Pod, 补充了容器化后缺失的与进程组对应的“容器组”的概念，是资源调度的最小单位</li><li>Node, 对应于集群中的单台机器，这里的机器即可以是生产环境中的物理机，也可以是云计算环境中的虚拟节点，节点是处理器和内存等资源的资源池，是硬件单元的最小单位</li><li>Cluster, 当你要部署应用的时候，只需要通过声明式 API 将你的意图写成一份元数据, 是处理元数据的最小单位</li></ul><p>资源附加上了期望状态与实际状态两项属性，用户要想使用这些资源来实现某种需求，并不提倡像平常编程那样去调用某个或某一组方法来达成目的，而是通过描述清楚这些资源的期望状态，由 Kubernetes 中对应监视这些资源的控制器来驱动资源的实际状态逐渐向期望状态靠拢，这种交互风格被称为是 Kubernetes 的声明式 API</p><p>以应用(集群)为中心的封装</p><ul><li>Kustomize, 根据环境来生成不同的部署配置</li><li>Helm, Chart, 应用商店与包管理工具, 无法很好地管理这种有状态的依赖关系</li><li>Operator, CRD, 要求开发者自己实现一个专门针对该自定义资源的控制器，在控制器中维护自定义资源的期望状态</li><li>开放应用模型</li></ul><h2 id="容器间网络"><a href="#容器间网络" class="headerlink" title="容器间网络"></a>容器间网络</h2><h3 id="Linux网络虚拟化"><a href="#Linux网络虚拟化" class="headerlink" title="Linux网络虚拟化"></a>Linux网络虚拟化</h3><h4 id="网络通信模型"><a href="#网络通信模型" class="headerlink" title="网络通信模型"></a>网络通信模型</h4><h4 id="干预网络通信"><a href="#干预网络通信" class="headerlink" title="干预网络通信"></a>干预网络通信</h4><h4 id="虚拟化网络设备"><a href="#虚拟化网络设备" class="headerlink" title="虚拟化网络设备"></a>虚拟化网络设备</h4><h4 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h4><h3 id="容器网络与生态"><a href="#容器网络与生态" class="headerlink" title="容器网络与生态"></a>容器网络与生态</h3><h4 id="CNM-与-CNI"><a href="#CNM-与-CNI" class="headerlink" title="CNM 与 CNI"></a>CNM 与 CNI</h4><h4 id="网络插件生态"><a href="#网络插件生态" class="headerlink" title="网络插件生态"></a>网络插件生态</h4><h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><h3 id="Kubernetes-存储设计"><a href="#Kubernetes-存储设计" class="headerlink" title="Kubernetes 存储设计"></a>Kubernetes 存储设计</h3><h4 id="Mount-和-Volume"><a href="#Mount-和-Volume" class="headerlink" title="Mount 和 Volume"></a>Mount 和 Volume</h4><h4 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h4><h4 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h4><h3 id="容器存储与生态"><a href="#容器存储与生态" class="headerlink" title="容器存储与生态"></a>容器存储与生态</h3><h4 id="Kubernetes-存储架构"><a href="#Kubernetes-存储架构" class="headerlink" title="Kubernetes 存储架构"></a>Kubernetes 存储架构</h4><h4 id="FlexVolume-与-CSI"><a href="#FlexVolume-与-CSI" class="headerlink" title="FlexVolume 与 CSI"></a>FlexVolume 与 CSI</h4><h4 id="从-In-Tree-到-Out-of-Tree"><a href="#从-In-Tree-到-Out-of-Tree" class="headerlink" title="从 In-Tree 到 Out-of-Tree"></a>从 In-Tree 到 Out-of-Tree</h4><h4 id="容器插件生态"><a href="#容器插件生态" class="headerlink" title="容器插件生态"></a>容器插件生态</h4><h2 id="资源与调度"><a href="#资源与调度" class="headerlink" title="资源与调度"></a>资源与调度</h2><h3 id="资源模型"><a href="#资源模型" class="headerlink" title="资源模型"></a>资源模型</h3><h3 id="服务质量与优先级"><a href="#服务质量与优先级" class="headerlink" title="服务质量与优先级"></a>服务质量与优先级</h3><h3 id="驱逐机制"><a href="#驱逐机制" class="headerlink" title="驱逐机制"></a>驱逐机制</h3><h3 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h3><h2 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h2><h3 id="透明通信的涅槃"><a href="#透明通信的涅槃" class="headerlink" title="透明通信的涅槃"></a>透明通信的涅槃</h3><h4 id="通信的成本"><a href="#通信的成本" class="headerlink" title="通信的成本"></a>通信的成本</h4><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><h4 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h4><h3 id="服务网格与生态"><a href="#服务网格与生态" class="headerlink" title="服务网格与生态"></a>服务网格与生态</h3><h4 id="服务网格接口"><a href="#服务网格接口" class="headerlink" title="服务网格接口"></a>服务网格接口</h4><h4 id="通用数据平面-API"><a href="#通用数据平面-API" class="headerlink" title="通用数据平面 API"></a>通用数据平面 API</h4><h4 id="服务网格生态"><a href="#服务网格生态" class="headerlink" title="服务网格生态"></a>服务网格生态</h4><h1 id="技术方法论"><a href="#技术方法论" class="headerlink" title="技术方法论"></a>技术方法论</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的目的是有效的拆分应用，实现敏捷开发和部署</p><p>前提条件</p><ol><li>决策者与执行者都能意识到康威定律在软件设计中的关键作用(系统的架构趋同于组织的沟通结构)</li><li>组织中具备一些对微服务有充分理解、有一定实践经验的技术专家</li><li>系统应具有以自治为目标的自动化与监控度量能力</li><li>复杂性已经成为制约生产力的主要矛盾</li></ol><p>微服务的粒度: 领域驱动设计, DDD</p><ul><li>能够独立发布、独立部署、独立运行与独立测试</li><li>强相关的功能与数据在同一个服务中处理</li><li>一个服务包含至少一项业务实体与对应的完整操作</li><li>一个 2 Pizza Team (6-12) 能够在一个研发周期内完成的全部需求范围</li></ul><p>系统复杂性来源</p><ul><li>认知负担, 微服务&gt;单体服务</li><li>合作成本, 随人数的上升而上升, 单体服务上升比例远大于微服务</li></ul><p>架构腐化</p><blockquote><p>项目在开始的时候，团队会花很多时间去决策该选择用什么技术体系、哪种架构、怎样的平台框架、甚至具体到开发、测试和持续集成工具。此时就像小孩子们在选择自己所钟爱的玩具，笔者相信无论决策的结果如何，团队都会欣然选择他们所选择的，并且坚信他们的选择是正确的。事实也确实如此，团队选择的解决方案通常能够解决技术选型时就能预料到的那部分困难。但真正困难的地方在于，随着时间的流逝，团队对该项目质量的持续保持能力会逐渐下降，一方面是高级技术专家不可能持续参与软件稳定之后的迭代过程，反过来，如果持续绑定在同一个达到稳定之后的项目上，也很难培养出技术专家。老人的退出新人的加入使得团队总是需要理解旧代码的同时完成新功能，技术专家偶尔来评审一下或救一救火，充其量只能算临时抱佛脚；另一方面是代码会逐渐失控，时间长了一定会有某些并不适合放进最初设计中的需求出现，工期紧任务重业务复杂代码不熟悉都会成为欠下一笔技术债的妥协理由，原则底线每一次被细微地突破，都可能被破窗效应撕裂放大成触目惊心的血痕，最终累积到每个新人到来就马上能嗅出老朽腐臭味道的程度。</p></blockquote><p>架构腐化是软件动态发展中出现的问题，任何静态的治理方案都只能延缓，不能根治，唯一有效的办法是演进式的设计</p>]]></content>
    
    
    <summary type="html">周志明的关于构建一个大规模但依然可靠的软件系统的架构讨论与代码实践</summary>
    
    
    
    
    <category term="读书笔记" scheme="https://hahahaha123567.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>位运算计算大于等于给定数字a的最小二次幂</title>
    <link href="https://hahahaha123567.github.io/2022-01-07-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97a%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E6%AC%A1%E5%B9%82.html"/>
    <id>https://hahahaha123567.github.io/2022-01-07-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97a%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E6%AC%A1%E5%B9%82.html</id>
    <published>2022-01-06T16:00:00.000Z</published>
    <updated>2022-01-07T08:06:21.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a href="https://zh.wikipedia.org/wiki/2%E7%9A%84%E5%B9%82">二次幂</a> 是指底数为2且指数为整数n的幂, 如2, 4, 8, 16等</p><p><code>大于等于给定数字a的最小二次幂</code> 即输入[5, 8]的数均输出8, 输入[9, 16]的数均输出16</p><p>在Java的HashMap中, 为了方便计算hash值、减少hash碰撞, hash的范围都是二次幂, 在初始化map和map扩容时需要根据给定的初始值计算<code>大于等于给定数字a的最小二次幂</code>, 即 <code>HashMap.java</code> 中的 <code>int tableSizeFor(int cap)</code></p><p>Java中int的最大值为2^31-1, 即<code>0x7fffffff</code>, 即<code>01111111 11111111 11111111 11111111</code></p><p>HashMap的capacity最大值为2^30, 即<code>1 &lt;&lt; 30</code>, 即<code>0x40000000</code>, 即<code>01000000 00000000 00000000 00000000</code></p><h1 id="Java8中的实现"><a href="#Java8中的实现" class="headerlink" title="Java8中的实现"></a>Java8中的实现</h1><p>看二进制的数, <code>大于给定数字a的最小二次幂</code>即从左到右数第一个值为1的位, 再左一位为1其他为0</p><p>5-&gt;8  0101-&gt;1000</p><p>7-&gt;8  0111-&gt;1000</p><p>目标值减1的数, 即从第一个值为1的位开始所有位的值均为1</p><p>5-&gt;7  0101-&gt;0111</p><p>7-&gt;7  0111-&gt;0111</p><p>考虑到输入即为二次幂的情况, 先将输入减1, 再计算从第一个值为1的位开始所有位的值均为1, 不需要考虑等于的情况, 最后得到的数再加1</p><p>0010 1001-&gt;0011 1111 即 41-&gt;63, 输出64</p><p>如何将一个数最高位1后面的1全部置为1呢? 使用右移+取或, 例如<code>0100</code>右移1位并和自身取或<code>0100 | 0010 = 0110</code>就将最高位的后一位置为了1, 不断重复这个过程</p><p>输入的最大值为<code>1 &lt;&lt; 30</code>即<code>01000000 00000000 00000000 00000000</code></p><p>减1后为<code>00111111 11111111 11111111 11111111</code>, 不断右移取或后还是自己, 加1后为<code>01000000 00000000 00000000 00000000</code></p><p>假设输入<code>1 &lt;&lt; 29 + 1</code>即<code>00100000 00000000 00000000 00000001</code></p><p>右移1位后和自己取或<code>00110000 00000000 00000000 00000000</code></p><p>右移2位后和自己取或<code>00111100 00000000 00000000 00000000</code></p><p>右移4位后和自己取或<code>00111111 11000000 00000000 00000000</code></p><p>右移8位后和自己取或<code>00111111 11111111 11000000 00000000</code></p><p>右移16位后和自己取或<code>00111111 11111111 11111111 11111111</code></p><p>加1后为<code>01000000 00000000 00000000 00000001</code>即<code>1 &lt;&lt; 30</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java11中的实现"><a href="#Java11中的实现" class="headerlink" title="Java11中的实现"></a>Java11中的实现</h1><p>目标同样是将最高位1后面的0计算出前导0的个数, 最后加1</p><p>先求出a前导0的数量, 使用比较和移位求出, 然后直接将-1 <code>0xffffffff</code>进行无符号右移</p><p>其中<code>numberOfLeadingZeros()</code>方法在OracleJDK中含注解<code>@IntrinsicCandidate</code>, OpenJDK中含注解<code>@HotSpotIntrinsicCandidate</code>, 均表示HotspotJVM会根据当前处理器平台对运算进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Integer.numberOfLeadingZeros()</code>的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Count leading 0&#x27;s</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java里HashMap的两种实现</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="算法" scheme="https://hahahaha123567.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中几种常用的异步工具</title>
    <link href="https://hahahaha123567.github.io/2021-11-05-Java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E5%B7%A5%E5%85%B7.html"/>
    <id>https://hahahaha123567.github.io/2021-11-05-Java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E5%B7%A5%E5%85%B7.html</id>
    <published>2021-11-04T16:00:00.000Z</published>
    <updated>2022-12-16T03:01:30.928Z</updated>
    
    <content type="html"><![CDATA[<p>几种异步工具的演化</p><ul><li>new线程, <code>Runnable</code> &#x2F; <code>Callable</code></li><li>线程池, <code>Executor</code> &#x2F; <code>ExecutorService</code> + <code>Future</code> &#x2F; <code>FutureTask</code></li><li>ForkJoin, <code>ForkJoinPool</code></li><li>CompletableFuture</li></ul><p>使用自定义的forkJoinPool运行parallelStream<br>new ForkJoinPool(16).submit(() -&gt; list.parallelStream())</p><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>new线程</td><td></td><td>线程创建和销毁消耗资源</td><td></td></tr><tr><td>线程池</td><td>降低线程创建和销毁的资源消耗, 统一管理线程</td><td></td><td></td></tr><tr><td>forkjoin</td><td>使用worksteal算法, 效率高于普通线程池</td><td></td><td>数据集大且可拆分, 并行的子集逻辑相对独立, CPU密集</td></tr><tr><td>CompletableFuture</td><td>链式写法, 支持自定义线程池</td><td></td><td>多个调用有逻辑依赖关系</td></tr><tr><td>RxJava</td><td>链式写法, 性能比CompletableFuture高, 支持back_pressure</td><td>学习成本高</td><td></td></tr></tbody></table><p><a href="https://v2ex.com/t/811364">发现了个很奇怪的现象，关于 parallelStream 的 - V2EX</a></p><p><a href="https://hahahaha123567.github.io/2018-08-13-java-util-concurrent.html">java.util.concurrent | hahahaha123567’s Blog</a></p><p><a href="https://mp.weixin.qq.com/s/tS0U7NzsZ4MA-mg-2ZgAxw">来，带你鸟瞰 Java 中的并发框架！</a></p>]]></content>
    
    
    <summary type="html">线程池, ForkJoin, CompletableFuture的关系</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="异步" scheme="https://hahahaha123567.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>阅读Spring源码(1) - 上下文启动</title>
    <link href="https://hahahaha123567.github.io/2021-07-22-%E9%98%85%E8%AF%BBSpring%E6%BA%90%E7%A0%811.html"/>
    <id>https://hahahaha123567.github.io/2021-07-22-%E9%98%85%E8%AF%BBSpring%E6%BA%90%E7%A0%811.html</id>
    <published>2021-07-21T16:00:00.000Z</published>
    <updated>2021-08-05T09:32:04.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring的整体架构和环境搭建"><a href="#Spring的整体架构和环境搭建" class="headerlink" title="Spring的整体架构和环境搭建"></a>Spring的整体架构和环境搭建</h1><p><a href="https://www.cnblogs.com/java-chen-hao/p/11046190.html">spring5 源码深度解析—–Spring的整体架构和环境搭建 - chen_hao - 博客园</a></p><p>Spring的整体架构</p><ul><li>Core Container<ul><li>Core</li><li>Beans</li><li>Context</li><li>SpEL</li></ul></li><li>AOP</li><li>Aspect</li><li>Instrumentation</li><li>Messaging</li><li>Web<ul><li>Web</li><li>Servlet</li><li>Websocket</li><li>Portlet</li></ul></li><li>Data Access&#x2F;Integration<ul><li>JDBC</li><li>ORM</li><li>OXM</li><li>JMS</li><li>Transactions</li></ul></li><li>Test</li></ul><p>阅读步骤</p><ol><li>安装gradle</li><li>下载源码</li><li>build项目</li><li>创建测试模块并debug</li></ol><h1 id="IOC注册"><a href="#IOC注册" class="headerlink" title="IOC注册"></a>IOC注册</h1><p><a href="https://www.cnblogs.com/java-chen-hao/p/11113340.html">spring5 源码深度解析—– IOC 之 容器的基本实现 - chen_hao - 博客园</a></p><p><a href="https://www.cnblogs.com/java-chen-hao/p/11115300.html">spring5 源码深度解析—– IOC 之 默认标签解析（上） - chen_hao - 博客园</a></p><p><a href="https://www.cnblogs.com/java-chen-hao/p/11120677.html">spring5 源码深度解析—– IOC 之 默认标签解析（下） - chen_hao - 博客园</a></p><p>ClassPathResource, Resource 配置资源的抽象</p><p>示例使用 XmlBeanFactory</p><blockquote><p>BeanFactoryAware&#x2F;ApplicationContextAware 在构建BeanFactory的时候就进行了相关配置</p></blockquote><p>XmlBeanDefinitionReader 解析XML文件, 返回 <code>org.w3c.dom.Document</code></p><p>BeanDefinitionDocumentReader 使用 BeanDefinitionParserDelegate 解析Document, 包含defaultElement&#x2F;customElement, 返回 <code>BeanDefinitionHolder</code> (包含 <code>GenericBeanDefinition</code>)</p><p>BeanDefinitionDocumentReader 将 &lt;beanName, beanDefinition&gt; 注册到 <code>BeanDefinitionRegistry</code>(beanFactory), 实际使用 <code>DefaultListableBeanFactory</code> 的 <code>registerBeanDefinition</code>, 映射关系保存在一个ConcurrentHashMap中</p><h1 id="IOC注入-BeanFactory"><a href="#IOC注入-BeanFactory" class="headerlink" title="IOC注入(BeanFactory)"></a>IOC注入(BeanFactory)</h1><p><a href="https://www.cnblogs.com/java-chen-hao/p/11137571.html">spring5 源码深度解析—– IOC 之 开启 bean 的加载 - chen_hao - 博客园</a></p><p><strong>BeanFactory</strong></p><p><img src="/../../../../image/bean_factory.png" alt="BeanFactory类图"></p><p><code>BeanFactory</code> 和 <code>FactoryBean</code> 的区别:</p><ul><li>BeanFactory, 访问 Spring bean 容器的根接口, 是应用程序组件的中央注册表</li><li>FactoryBean, 如果一个 bean 实现了这个接口，它就被用作一个对象暴露的工厂</li></ul><h2 id="获取bean名称"><a href="#获取bean名称" class="headerlink" title="获取bean名称"></a>获取bean名称</h2><p><code>AbstractBeanFactory</code> 的 <code>transformedBeanName</code></p><ol><li>FactoryBean的&amp;名称解引用</li><li>alias转换</li></ol><h2 id="获取单例缓存sharedInstance"><a href="#获取单例缓存sharedInstance" class="headerlink" title="获取单例缓存sharedInstance"></a>获取单例缓存sharedInstance</h2><p><code>DefaultSingletonBeanRegistry</code> 的 <code>getSingleton()</code></p><p>几个缓存(使用时不加锁的是ConcurrentHashMap, 使用时加锁的是HashMap)</p><ul><li>singletonObjects:用于保存BeanName和创建bean实例之间的关系，beanName–&gt;bean Instance</li><li>singletonFactories:用于保存BeanName和创建bean的工厂之间的关系，banName–&gt;ObjectFactory</li><li>earlySingletonObjects:也是保存BeanName和创建bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例bean被放到这里面后，那么当bean还在创建过程中，就可以通过getBean方法获取到了，其目的是用来检测循环引用</li></ul><p>如果有单例缓存, 则使用单例缓存获取bean</p><p>如果单例缓存不是FactoryBean则说明为bean直接返回</p><p>如果单例缓存是FactoryBean则调用getBean, <code>DefaultSingletonBeanRegistry</code> 的 <code>beforeSingletonCreation</code> <code>afterSingletonCreation</code> 继续使用缓存判断是否创建中(检测循环引用), <code>postProcessObjectFromFactoryBean</code> 调用bean的 <code>BeanPostProcessors</code> 方法</p><h2 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h2><p><a href="https://www.cnblogs.com/java-chen-hao/p/11139157.html">spring5 源码深度解析—– IOC 之 bean 创建 - chen_hao - 博客园</a></p><p>未获取到单例缓存的话就要创建bean</p><p>入口 <code>AbstractBeanFactory</code> 的 <code>doGetBean()</code></p><h3 id="scope-x3D-singleton"><a href="#scope-x3D-singleton" class="headerlink" title="scope&#x3D;singleton"></a>scope&#x3D;singleton</h3><ol><li>synchronized全局锁</li><li>检查缓存</li><li>beforeSingletonCreation()</li><li>createBean()</li><li>afterSingletonCreation()</li><li>加入缓存</li></ol><h3 id="scope-x3D-prototype"><a href="#scope-x3D-prototype" class="headerlink" title="scope&#x3D;prototype"></a>scope&#x3D;prototype</h3><ol><li>beforeSingletonCreation()</li><li>createBean()</li><li>afterSingletonCreation()</li><li>getObjectForBeanInstance()</li></ol><h3 id="scope-x3D-other"><a href="#scope-x3D-other" class="headerlink" title="scope&#x3D;other"></a>scope&#x3D;other</h3><ol><li>beforeSingletonCreation()</li><li>scope.get() -&gt; createBean()</li><li>afterSingletonCreation()</li><li>getObjectForBeanInstance()</li></ol><h3 id="实现的方法createBean"><a href="#实现的方法createBean" class="headerlink" title="实现的方法createBean()"></a>实现的方法createBean()</h3><p><code>AbstractAutowireCapableBeanFactory</code> 的 <code>createBean()</code></p>]]></content>
    
    
    <summary type="html">跟着其他人的博客看源码</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://hahahaha123567.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java各版本更新介绍</title>
    <link href="https://hahahaha123567.github.io/2021-07-01-Java%E5%90%84%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D.html"/>
    <id>https://hahahaha123567.github.io/2021-07-01-Java%E5%90%84%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D.html</id>
    <published>2021-06-30T16:00:00.000Z</published>
    <updated>2022-12-14T10:46:44.024Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xie.infoq.cn/article/655943e5f85e6f79ffbd03047">新时代背景下的Java语法特性(9-14) - InfoQ 写作平台</a></p><p><a href="https://xie.infoq.cn/article/92ba88c7926b5f5c6fbc11830">剖析Java15新语法特性 - InfoQ 写作平台</a></p><p><a href="https://xie.infoq.cn/article/8304c894c4e38318d38ceb116">实操 | 剖析 Java16 新语法特性 - InfoQ 写作平台</a></p><hr><p>2022-12-14更新</p><p><a href="https://mp.weixin.qq.com/s/IaUQrkxvaeEjujDe5-DVfA">一文详解｜从JDK8飞升到JDK17，再到未来的JDK21</a></p>]]></content>
    
    
    <summary type="html">受限于自己贫乏的项目经验和语言理解,不再自己记录日志或翻译更新文档,收录dalao的文章</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>IDEA将文件标记为文本文件及取消</title>
    <link href="https://hahahaha123567.github.io/2021-06-28-IDEA%E5%B0%86%E6%96%87%E4%BB%B6%E6%A0%87%E8%AE%B0%E4%B8%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%8F%8A%E5%8F%96%E6%B6%88.html"/>
    <id>https://hahahaha123567.github.io/2021-06-28-IDEA%E5%B0%86%E6%96%87%E4%BB%B6%E6%A0%87%E8%AE%B0%E4%B8%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%8F%8A%E5%8F%96%E6%B6%88.html</id>
    <published>2021-06-27T16:00:00.000Z</published>
    <updated>2021-06-28T09:56:23.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用IDEA编辑文件时，在修改文件名时有时会修改文件后缀，此时IDE会弹出 <code>Register New File Type Association</code> 让你设置一些文件后缀的识别规则</p><p>这个时候我经常没看清楚误触导致IDE不再智能识别某种特定后缀的文件，编辑起来很不舒服</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="以前"><a href="#以前" class="headerlink" title="以前"></a>以前</h2><p>在文件上右键，选择 <code>mark as plain text</code> 或相反的选项</p><p>但是最近IDEA似乎移除了这个选项</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p><code>Preferences</code> -&gt; <code>Editor</code> -&gt; <code>File Types</code> 这里可以任意修改文件后缀的识别规则，包括 <code>Recognized</code> 和 <code>Ignored</code></p>]]></content>
    
    
    <summary type="html">经常在重构时误触导致文件不能正常识别与提示</summary>
    
    
    
    
    <category term="IDEA" scheme="https://hahahaha123567.github.io/tags/IDEA/"/>
    
    <category term="工具" scheme="https://hahahaha123567.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud的一些常用组件</title>
    <link href="https://hahahaha123567.github.io/2021-06-25-SpringCloud%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html"/>
    <id>https://hahahaha123567.github.io/2021-06-25-SpringCloud%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-07-01T08:09:59.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务组成"><a href="#服务组成" class="headerlink" title="服务组成"></a>服务组成</h1><p><img src="/../../../../image/spring_cloud_architecture_highlights.svg" alt="spring_cloud_architecture_highlights"></p><h2 id="service-discovery-服务发现"><a href="#service-discovery-服务发现" class="headerlink" title="service discovery 服务发现"></a>service discovery 服务发现</h2><ul><li>Eureka (netflix)</li><li>Consul</li><li>Zookeeper</li><li>Kubernetes</li><li>nacos (alibaba)</li></ul><h2 id="API-gateway-API网关"><a href="#API-gateway-API网关" class="headerlink" title="API gateway API网关"></a>API gateway API网关</h2><ul><li>spring cloud gateway</li></ul><h2 id="cloud-configuration-云配置"><a href="#cloud-configuration-云配置" class="headerlink" title="cloud configuration 云配置"></a>cloud configuration 云配置</h2><ul><li>spring cloud config</li><li>nacos (alibaba)</li></ul><h2 id="circuit-breaker-服务熔断"><a href="#circuit-breaker-服务熔断" class="headerlink" title="circuit breaker 服务熔断"></a>circuit breaker 服务熔断</h2><ul><li>Hystrix (netflix)</li><li>Resilience4J</li><li>Sentinel (alibaba)</li><li>Spring Retry</li></ul><h2 id="tracing-链路跟踪"><a href="#tracing-链路跟踪" class="headerlink" title="tracing 链路跟踪"></a>tracing 链路跟踪</h2><ul><li>Spring Cloud Sleuth</li><li>zipkin</li></ul><h2 id="test-测试"><a href="#test-测试" class="headerlink" title="test 测试"></a>test 测试</h2><ul><li>Spring Cloud Contract</li></ul><h2 id="others-其他"><a href="#others-其他" class="headerlink" title="others 其他"></a>others 其他</h2><h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><ul><li>Kafka</li><li>RabbitMQ</li><li>Feign</li></ul><h3 id="Distributed-Transaction"><a href="#Distributed-Transaction" class="headerlink" title="Distributed Transaction"></a>Distributed Transaction</h3><ul><li>Seata</li></ul><h1 id="套件"><a href="#套件" class="headerlink" title="套件"></a>套件</h1><h2 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h2><p>原组件</p><ul><li>Hystrix(熔断器)</li><li>Hystrix Dashboard(监控)</li><li>Ribbon(客户端负载均衡)</li><li>Zuul(网关)</li><li>Archaius(云配置)</li></ul><p>现在项目内只有Eureka</p><h2 id="Netflix替代"><a href="#Netflix替代" class="headerlink" title="Netflix替代"></a>Netflix替代</h2><p>Spring Cloud 2020.0.0版本彻底删除掉了Netflix除Eureka外的所有组件, 推荐的替代品如下</p><ul><li>Resilience4j</li><li>Micrometer + Monitoring System</li><li>Spring Cloud Loadbalancer</li><li>Spring Cloud Gateway</li><li>Spring Cloud Config</li></ul><p>Feign从Netflix转交给OpenFeign, 当前可以使用Spring Cloud Loadbalancer作为http-client实现</p><hr><p><strong>reference</strong></p><p><a href="https://spring.io/cloud">Spring | Cloud</a></p><p><a href="https://incoder.org/2020/11/11/microservices-alibaba1/#SpringCloud-VS-SpringCloud-Alibaba">微服务架构 - Alibaba 生态整合（一） | BladeCode</a></p>]]></content>
    
    
    <summary type="html">SpringCloud的一些常用组件</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://hahahaha123567.github.io/tags/Spring/"/>
    
    <category term="SpringCloud" scheme="https://hahahaha123567.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Java实现gRPC的部分进阶功能</title>
    <link href="https://hahahaha123567.github.io/2021-06-24-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E9%83%A8%E5%88%86%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD.html"/>
    <id>https://hahahaha123567.github.io/2021-06-24-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E9%83%A8%E5%88%86%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD.html</id>
    <published>2021-06-23T16:00:00.000Z</published>
    <updated>2021-06-24T09:27:43.210Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章内容均基于gRPC<a href="https://grpc.io/docs/languages/java/quickstart/">官方文档</a>提供的<a href="https://github.com/grpc/grpc-java/archive/v1.38.0.zip">代码示例v1.38.0</a></p><p>你也可以直接看<a href="https://github.com/grpc/grpc-java/tree/master/examples">github上的最新版本</a></p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p><code>StatusException</code> gRPC常用的异常类型, 扩展自 <code>Exception</code> , 包含状态信息 <code>Status status</code> 和扩展信息 <code>Metadata trailers</code></p><p><code>StatusRuntimeException</code> gRPC常用的异常类型, 扩展自 <code>RuntimeException</code> , 包含状态信息 <code>Status status</code> 和扩展信息 <code>Metadata trailers</code></p><h2 id="服务端返回错误"><a href="#服务端返回错误" class="headerlink" title="服务端返回错误"></a>服务端返回错误</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误扩展信息key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Metadata.Key&lt;DebugInfo&gt; DEBUG_INFO_TRAILER_KEY = ProtoUtils.keyForProto(DebugInfo.getDefaultInstance());</span><br><span class="line"><span class="comment">// 错误扩展信息value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DebugInfo</span> <span class="variable">DEBUG_INFO</span> <span class="operator">=</span> DebugInfo.newBuilder()</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_1&quot;</span>)</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_2&quot;</span>)</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_3&quot;</span>)</span><br><span class="line">                                                    .setDetail(<span class="string">&quot;detailed error info.&quot;</span>).build();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;</span><br><span class="line">    <span class="comment">// 错误扩展信息</span></span><br><span class="line">    <span class="type">Metadata</span> <span class="variable">trailers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Metadata</span>();</span><br><span class="line">    trailers.put(DEBUG_INFO_TRAILER_KEY, DEBUG_INFO);</span><br><span class="line">    <span class="comment">// 返回错误</span></span><br><span class="line">    responseObserver.onError(</span><br><span class="line">        Status.INTERNAL.withDescription(DEBUG_DESC).asRuntimeException(trailers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端处理错误"><a href="#客户端处理错误" class="headerlink" title="客户端处理错误"></a>客户端处理错误</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Metadata.Key&lt;DebugInfo&gt; DEBUG_INFO_TRAILER_KEY = ProtoUtils.keyForProto(DebugInfo.getDefaultInstance());</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> Status.fromThrowable(t);</span><br><span class="line">    <span class="type">Metadata</span> <span class="variable">trailers</span> <span class="operator">=</span> Status.trailersFromThrowable(t);</span><br><span class="line">    <span class="comment">// 不符合条件则抛出VerifyException</span></span><br><span class="line">    Verify.verify(status.getCode() == Status.Code.INTERNAL);</span><br><span class="line">    Verify.verify(trailers.containsKey(DEBUG_INFO_TRAILER_KEY));</span><br><span class="line">    Verify.verify(status.getDescription().contains(<span class="string">&quot;Overbite&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端请求重试"><a href="#客户端请求重试" class="headerlink" title="客户端请求重试"></a>客户端请求重试</h2><p>配置重试参数需要在构建channel时传入配置, 具体参数等可以参考 <code>ManagedChannelServiceConfig</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重试参数</span></span><br><span class="line">Map&lt;String, Object&gt; name0 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">name0.put(<span class="string">&quot;service&quot;</span>, <span class="string">&quot;helloworld.Greeter&quot;</span>);</span><br><span class="line">name0.put(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;SayHello&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; retryPolicies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">retryPolicies.put(<span class="string">&quot;backoffMultiplier&quot;</span>, <span class="number">2.0</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;maxAttempts&quot;</span>, <span class="number">5.0</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;initialBackoff&quot;</span>, <span class="string">&quot;0.5s&quot;</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;maxBackoff&quot;</span>, <span class="string">&quot;30s&quot;</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;retryableStatusCodes&quot;</span>, Arrays.stream(Status.Code.values()).filter(code -&gt; !Status.Code.OK.equals(code)).map(Enum::name).collect(Collectors.toList()));</span><br><span class="line">Map&lt;String, Object&gt; methodConfig0 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">methodConfig0.put(<span class="string">&quot;name&quot;</span>, Collections.singletonList(name0));</span><br><span class="line">methodConfig0.put(<span class="string">&quot;retryPolicy&quot;</span>, retryPolicies);</span><br><span class="line">Map&lt;String, Object&gt; defaultServiceConfig = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">defaultServiceConfig.put(<span class="string">&quot;methodConfig&quot;</span>, Collections.singletonList(methodConfig0));</span><br><span class="line"><span class="comment">// 构建channel</span></span><br><span class="line">helloWorldChannel = ManagedChannelBuilder.forTarget(<span class="string">&quot;localhost:50051&quot;</span>)</span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .enableRetry()</span><br><span class="line">        .defaultServiceConfig(defaultServiceConfig)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>以上为Java代码方式构造参数, 官方提供的是使用json配置文件+gson解析的方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;methodConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;helloworld.Greeter&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SayHello&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;retryPolicy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;maxAttempts&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;initialBackoff&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.5s&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;maxBackoff&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30s&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;backoffMultiplier&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;retryableStatusCodes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;UNAVAILABLE&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">JsonReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(RetryingHelloWorldClient.class.getResourceAsStream(<span class="string">&quot;retrying_service_config.json&quot;</span>), UTF_8)),Map.class);</span><br></pre></td></tr></table></figure><h2 id="服务端拦截器"><a href="#服务端拦截器" class="headerlink" title="服务端拦截器"></a>服务端拦截器</h2><p>gRPC支持服务端设置拦截器链</p><p>继承 <code>ServerInterceptor</code> 接口并实现 <code>interceptCall</code> 方法, 在创建 <code>server</code> 时进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LatencyInjectionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ServerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;HelloRequestT, HelloReplyT&gt; Listener&lt;HelloRequestT&gt; <span class="title function_">interceptCall</span><span class="params">(ServerCall&lt;HelloRequestT, HelloReplyT&gt; call, Metadata headers, ServerCallHandler&lt;HelloRequestT, HelloReplyT&gt; next)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个Interceptor制造了长尾延迟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (random &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            delay = <span class="number">10_000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (random &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            delay = <span class="number">5_000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (random &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            delay = <span class="number">2_000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(delay);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next.startCall(call, headers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> ServerBuilder.forPort(port)</span><br><span class="line">        .addService(<span class="keyword">new</span> <span class="title class_">GreeterImpl</span>())</span><br><span class="line">        .intercept(<span class="keyword">new</span> <span class="title class_">LatencyInjectionInterceptor</span>())</span><br><span class="line">        .build()</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure><h2 id="请求对冲"><a href="#请求对冲" class="headerlink" title="请求对冲"></a>请求对冲</h2><p><code>对冲请求</code> 是一种优化 <code>长尾延迟</code> 的方法, 参考 <a href="https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577">Hedged requests — Tackling tail latency | by Ricardo Linck | The Startup | Medium</a></p><p>gRPC自带对冲请求的支持, 类似上面的重试请求, 需要在构造channel时进行配置, 配置粒度精确到方法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;helloworld.Greeter&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SayHello&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hedgingPolicy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;maxAttempts&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;hedgingDelay&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;retryThrottling&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;maxTokens&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tokenRatio&quot;</span><span class="punctuation">:</span> <span class="number">0.1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>gRPC提供的示例还包括</p><ul><li>client自定义请求头</li><li>server自定义请求头</li><li>请求压缩</li><li>响应压缩</li><li>client自定义序列化反序列化逻辑</li><li>server自定义序列化反序列化逻辑</li><li>背压流量控制</li><li>TLS</li><li>ALTS(Google’s Application Layer Transport Security)</li><li>jwt</li></ul>]]></content>
    
    
    <summary type="html">本篇文章内容均基于gRPC官方文档提供的代码示例</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="gRPC" scheme="https://hahahaha123567.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Java实现gRPC的服务端和客户端</title>
    <link href="https://hahahaha123567.github.io/2021-06-23-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF.html"/>
    <id>https://hahahaha123567.github.io/2021-06-23-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF.html</id>
    <published>2021-06-22T16:00:00.000Z</published>
    <updated>2021-06-24T03:45:17.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gRPC简介"><a href="#gRPC简介" class="headerlink" title="gRPC简介"></a>gRPC简介</h1><p>gRPC是一种 <a href="https://hahahaha123567.github.io/2020/04/17/2020-04-17-RPC%E6%A6%82%E5%BF%B5/">RPC</a> 框架,特点:</p><ol><li>序列化&#x2F;反序列化使用Protocol Buffers,比起json等格式更高效</li><li>支持多种语言编写服务端&#x2F;客户端</li></ol><p><a href="https://grpc.io/">gRPC官网</a></p><h1 id="Java开发gRPC流程"><a href="#Java开发gRPC流程" class="headerlink" title="Java开发gRPC流程"></a>Java开发gRPC流程</h1><p>本章节内容基于 <a href="https://grpc.io/docs/languages/java/basics/">Basics tutorial | Java | gRPC</a></p><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><p>protocol buffer使用proto文件定义接口,参考 <a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3)  |  Protocol Buffers  |  Google Developers</a></p><p>以下为示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 协议版本</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">// 编译后是否生成多个Java类</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">// 编译后生成Java类的package路径</span><br><span class="line">option java_package = &quot;idol.elie.grpc.routeguide.protobuf&quot;;</span><br><span class="line">// 编译后生成的配置基类名</span><br><span class="line">option java_outer_classname = &quot;RouteGuideProto&quot;;</span><br><span class="line"></span><br><span class="line">// proto内部使用的package</span><br><span class="line">package routeguide;</span><br><span class="line"></span><br><span class="line">// 接口</span><br><span class="line">service RouteGuide &#123;</span><br><span class="line">    // 客户端同步请求,服务端单次返回</span><br><span class="line">    rpc GetFeature(Point) returns (Feature) &#123;&#125;;</span><br><span class="line">    // 客户端同步请求,服务端流式返回</span><br><span class="line">    rpc ListFeatures(Rectangle) returns (stream Feature);</span><br><span class="line">    // 客户端流式异步请求,服务端单次返回</span><br><span class="line">    rpc RecordRoute(stream Point) returns (RouteSummary);</span><br><span class="line">    // 客户端流式异步请求,服务端流式返回</span><br><span class="line">    rpc RouteChat(stream RouteNote) returns (stream RouteNote);</span><br><span class="line">&#125;</span><br><span class="line">// 数据类</span><br><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude = 1;</span><br><span class="line">  int32 longitude = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Rectangle &#123;</span><br><span class="line">  Point p1 = 1;</span><br><span class="line">  Point p2 = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Feature &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  Point location = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FeatureDatabase &#123;</span><br><span class="line">  repeated Feature features = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RouteNote &#123;</span><br><span class="line">  Point location = 1;</span><br><span class="line">  string message = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">  int32 point_count = 1;</span><br><span class="line">  int32 feature_count = 2;</span><br><span class="line">  int32 distance = 3;</span><br><span class="line">  int32 elapsed_time = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="proto编译生成Java类"><a href="#proto编译生成Java类" class="headerlink" title="proto编译生成Java类"></a>proto编译生成Java类</h2><p>Java版本推荐使用maven插件进行编译,<code>os-maven-plugin</code>判断当前运行平台,<code>protobuf-maven-plugin</code>使用对应平台的protoc进行编译</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">protoc.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">protoc.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protoc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:$&#123;grpc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将编译生成的类复制到src的对应目录下即可开始正式进行开发</p><h2 id="编写服务代码"><a href="#编写服务代码" class="headerlink" title="编写服务代码"></a>编写服务代码</h2><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  RouteGuideGrpc为编译生成的基础配置类, 我们需要继承并实现RouteGuideImplBase</span></span><br><span class="line"><span class="comment">  没有被继承实现的方法被调用后会向客户端报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteGuideImpl</span> <span class="keyword">extends</span> <span class="title class_">RouteGuideGrpc</span>.RouteGuideImplBase &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建web服务并监听</span></span><br><span class="line"><span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> ServerBuilder</span><br><span class="line">                .forPort(port)</span><br><span class="line">                .addService(<span class="keyword">new</span> <span class="title class_">RouteGuideImpl</span>())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">server.awaitTermination();</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteGuideClient</span> &#123;</span><br><span class="line"><span class="comment">// 同步调用stub</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteGuideGrpc.RouteGuideBlockingStub blockingStub;</span><br><span class="line"><span class="comment">// 异步调用stub</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteGuideGrpc.RouteGuideStub stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RouteGuideClient</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        blockingStub = RouteGuideGrpc.newBlockingStub(channel);</span><br><span class="line">        stub = RouteGuideGrpc.newStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ManagedChannel</span> <span class="variable">routeGuideChannel</span> <span class="operator">=</span> ManagedChannelBuilder</span><br><span class="line">.forTarget(<span class="string">&quot;localhost:25252&quot;</span>) <span class="comment">// target server</span></span><br><span class="line">                .usePlaintext() <span class="comment">// not ssl</span></span><br><span class="line">                .build();</span><br><span class="line"><span class="type">RouteGuideClient</span> <span class="variable">routeGuideClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteGuideClient</span>(routeGuideChannel);</span><br></pre></td></tr></table></figure><h3 id="客户端同步请求-服务端单次返回"><a href="#客户端同步请求-服务端单次返回" class="headerlink" title="客户端同步请求,服务端单次返回"></a>客户端同步请求,服务端单次返回</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFeature</span><span class="params">(Point request, StreamObserver&lt;Feature&gt; responseObserver)</span> &#123;</span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line">responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line"><span class="comment">// 处理完成</span></span><br><span class="line">responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFeature</span><span class="params">(<span class="type">int</span> latitude, <span class="type">int</span> longitude)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 使用阻塞stub直接调用</span></span><br><span class="line"><span class="type">Feature</span> <span class="variable">feature</span> <span class="operator">=</span> blockingStub.getFeature(Point.newBuilder().build());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.log(Level.WARNING, <span class="string">&quot;getFeature error&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端同步请求-服务端流式返回"><a href="#客户端同步请求-服务端流式返回" class="headerlink" title="客户端同步请求,服务端流式返回"></a>客户端同步请求,服务端流式返回</h3><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFeatures</span><span class="params">(Rectangle request, StreamObserver&lt;Feature&gt; responseObserver)</span> &#123;</span><br><span class="line"><span class="comment">// 返回流式响应</span></span><br><span class="line">responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line">responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line">responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFeatures</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Iterator&lt;Feature&gt; featureIterator = blockingStub.listFeatures(Rectangle.newBuilder().build());</span><br><span class="line"><span class="comment">// 用Iterator读取流式数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; featureIterator.hasNext(); ++i) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.log(Level.WARNING, <span class="string">&quot;listFeatures error&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端流式异步请求-服务端单次返回"><a href="#客户端流式异步请求-服务端单次返回" class="headerlink" title="客户端流式异步请求,服务端单次返回"></a>客户端流式异步请求,服务端单次返回</h3><h4 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StreamObserver&lt;Point&gt; <span class="title function_">recordRoute</span><span class="params">(StreamObserver&lt;RouteSummary&gt; responseObserver)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Point value)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 返回响应</span></span><br><span class="line">            responseObserver.onNext(RouteSummary.newBuilder().build());</span><br><span class="line">responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordRoute</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">// 异步响应处理</span></span><br><span class="line">StreamObserver&lt;RouteSummary&gt; responseObserver = <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteSummary value)</span> &#123;</span><br><span class="line"><span class="comment">// 处理返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用响应处理器生成请求</span></span><br><span class="line">StreamObserver&lt;Point&gt; requestObserver = stub.recordRoute(responseObserver);</span><br><span class="line"><span class="comment">// 流式请求</span></span><br><span class="line">requestObserver.onNext(Point.newBuilder().build());</span><br><span class="line">requestObserver.onNext(Point.newBuilder().build());</span><br><span class="line">requestObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端流式异步请求-服务端流式返回"><a href="#客户端流式异步请求-服务端流式返回" class="headerlink" title="客户端流式异步请求,服务端流式返回"></a>客户端流式异步请求,服务端流式返回</h3><h4 id="服务端-4"><a href="#服务端-4" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StreamObserver&lt;RouteNote&gt; <span class="title function_">routeChat</span><span class="params">(StreamObserver&lt;RouteNote&gt; responseObserver)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteNote value)</span> &#123;</span><br><span class="line"><span class="comment">// 流式返回</span></span><br><span class="line">responseObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理服务器返回的响应</span></span><br><span class="line">StreamObserver&lt;RouteNote&gt; responseStreamObserver = <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteNote value)</span> &#123;</span><br><span class="line">logger.info(value.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">StreamObserver&lt;RouteNote&gt; requestStreamObserver = stub.routeChat(responseStreamObserver);</span><br><span class="line"><span class="comment">// 流式请求</span></span><br><span class="line">requestStreamObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">requestStreamObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">requestStreamObserver.onCompleted();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">按照官方文档实践之后的流程梳理</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="gRPC" scheme="https://hahahaha123567.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>一个redis-session的错误使用示例</title>
    <link href="https://hahahaha123567.github.io/2021-06-01-%E4%B8%80%E4%B8%AAredis-session%E7%9A%84%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"/>
    <id>https://hahahaha123567.github.io/2021-06-01-%E4%B8%80%E4%B8%AAredis-session%E7%9A%84%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</id>
    <published>2021-05-31T16:00:00.000Z</published>
    <updated>2022-04-06T02:24:36.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>某个模块的几个子服务上线后会定时出现如下的异常日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">14:56:00.009 [ing-scheduled-1] [FJNJFVNG] ERROR o.s.s.s.TaskUtils$LoggingErrorHandler    - Unexpected error occurred in scheduled task </span><br><span class="line">org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:84)</span><br><span class="line">at org.springframework.data.redis.serializer.SerializationUtils.deserializeValues(SerializationUtils.java:54)</span><br><span class="line">at org.springframework.data.redis.serializer.SerializationUtils.deserialize(SerializationUtils.java:62)</span><br><span class="line">at org.springframework.data.redis.core.AbstractOperations.deserializeValues(AbstractOperations.java:223)</span><br><span class="line">at org.springframework.data.redis.core.DefaultSetOperations.members(DefaultSetOperations.java:216)</span><br><span class="line">at org.springframework.data.redis.core.DefaultBoundSetOperations.members(DefaultBoundSetOperations.java:152)</span><br><span class="line">at org.springframework.session.data.redis.RedisSessionExpirationPolicy.cleanExpiredSessions(RedisSessionExpirationPolicy.java:129)</span><br><span class="line">at org.springframework.session.data.redis.RedisIndexedSessionRepository.cleanupExpiredSessions(RedisIndexedSessionRepository.java:407)</span><br><span class="line">at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54)</span><br><span class="line">at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:93)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:78)</span><br><span class="line">at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:36)</span><br><span class="line">at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:82)</span><br><span class="line">... 16 common frames omitted</span><br><span class="line">Caused by: java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:937)</span><br><span class="line">at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:395)</span><br><span class="line">at org.springframework.core.ConfigurableObjectInputStream.&lt;init&gt;(ConfigurableObjectInputStream.java:65)</span><br><span class="line">at org.springframework.core.ConfigurableObjectInputStream.&lt;init&gt;(ConfigurableObjectInputStream.java:51)</span><br><span class="line">at org.springframework.core.serializer.DefaultDeserializer.deserialize(DefaultDeserializer.java:70)</span><br><span class="line">at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:73)</span><br><span class="line">... 18 common frames omitted</span><br></pre></td></tr></table></figure><h1 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h1><p>根据异常栈底的类名<code>DeserializingConverter</code>大概可以知道是反序列化的问题，但是什么反序列化会定时执行并抛出异常呢？</p><p>这个时候我们要看第一个异常栈，从栈底开始，忽略<code>ThreadPoolExecutor</code>等没有逻辑特征的类，往下看</p><p>首先是<code>ReschedulingRunnable</code>，是spring定时任务的默认接口，服务中用到定时任务的地方不算多，但是我们不能以此为依据，因为springboot本身也包含很多定时任务</p><p>接下来我们看<code>RedisIndexedSessionRepository</code>，找到异常栈中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanupExpiredSessions</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.expirationPolicy.cleanExpiredSessions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是服务在清理过期的session，继续往下debug可以看到服务使用代码里默认的<code>JdkSerializationRedisSerializer</code>执行redis的member操作检查过期key时产生的反序列化异常</p><p>再从异常栈顶往下跟踪，看看哪一步开始可以修改默认的serializer。要注意idea不支持外部库的变量引用查询，在跟踪字段的时候需要文件内搜索</p><p>发现在<code>RedisHttpSessionConfiguration</code>中调用了<code>RedisIndexedSessionRepository</code>的<code>setDefaultSerializer()</code>，Configuration在配置类中提供了serializer的注入方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;springSessionDefaultRedisSerializer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDefaultRedisSerializer</span><span class="params">(RedisSerializer&lt;Object&gt; defaultRedisSerializer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaultRedisSerializer = defaultRedisSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在spring配置中注入名为<code>springSessionDefaultRedisSerializer</code>的自定义serializer即可</p><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p>spring-session-data-redis和spring-data-redis相对独立，redis客户端的serializer等需要独立配置</p><p>RedisHttpSessionConfiguration 本身是一个 Spring 配置类, 会向 Spring 容器注册 sessionRepository, redisMessageListenerContainer 等实例</p><p>RedisHttpSessionConfiguration 会注册 Redis 消息监听器容器 RedisMessageListenerContainer, 并将 RedisIndexedSessionRepository 作为 Redis 消息订阅的监听器, 因为它实现了 MessageListener 接口。当 Redis 中 key 过期或销毁时, 会通知将 RedisIndexedSessionRepository 调用其onMessage() 方法来处理消息</p><p><a href="https://juejin.cn/post/6844904159091621901">Spring Session Data Redis 源码解析</a></p><p>排查问题的时候要灵活阅读异常栈的信息</p>]]></content>
    
    
    <summary type="html">服务里定时出现的神秘异常</summary>
    
    
    
    
    <category term="Java" scheme="https://hahahaha123567.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://hahahaha123567.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
