<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/snowman-32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/snowman-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/snowman-16.ico">
  <link rel="mask-icon" href="/images/snowman-32.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hahahaha123567.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="niconiconi">
<meta property="og:type" content="website">
<meta property="og:title" content="hahahaha123567">
<meta property="og:url" content="https://hahahaha123567.github.io/index.html">
<meta property="og:site_name" content="hahahaha123567">
<meta property="og:description" content="niconiconi">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hahahaha123567">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hahahaha123567.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>hahahaha123567</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">hahahaha123567</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hahahaha123567</p>
  <div class="site-description" itemprop="description">niconiconi</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hahahaha123567" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hahahaha123567" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://bangumi.tv/user/hahahaha123567" title="Bangumi → http:&#x2F;&#x2F;bangumi.tv&#x2F;user&#x2F;hahahaha123567" rel="noopener" target="_blank">Bangumi</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://lovelive.ws/" title="https:&#x2F;&#x2F;lovelive.ws&#x2F;" rel="noopener" target="_blank">μ's</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2077-01-01-%E6%94%B6%E8%97%8F%E5%A4%B9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2077-01-01-%E6%94%B6%E8%97%8F%E5%A4%B9.html" class="post-title-link" itemprop="url">收藏夹</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2077-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2077-01-01T00:00:00+08:00">2077-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-15 10:53:37" itemprop="dateModified" datetime="2022-06-15T10:53:37+08:00">2022-06-15</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

            <div class="post-description">不要让知识在收藏夹里沉睡</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">Java锁事</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/n2cZxqHqaMJM2mh9Tk13Bg">一文带你吃透线程池</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践 - 美团技术团队</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/4e7d9aa65a94aea3dc4a5cb8f">Java踩坑记系列之线程池 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ea8c896d893243e49fe867b0c">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1605149">腾讯面试官：线程池要设置多大 - 云+社区 - 腾讯云</a></p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aA1eDYIUHuIfigTw2ffouw">咱们从头到尾说一次 Java 垃圾回收</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/b37b289ef91bad11ce2d37b86">JVM-技术专题-GCViewer调优GC - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/632322582f697268a7fe77b35">常用JVM调优参数 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/f690ad8b57b7cfba4e29d24f0">YGC问题排查 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_tWm2G57vLgomvpNNHKAMA">系统运行缓慢，CPU 100%，以及Full GC次数过多问题的排查思路</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mkpq5t6K4sFejfqqKD2AmQ">了解Java中的内存泄漏</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java中9种常见的CMS GC问题分析与解决 - 美团技术团队</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/HA7LLvSEyuaVp6NZpEXr">新一代垃圾回收器ZGC的探索与实践 - InfoQ</a></p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/1b4307c8fc0e2d67b075d98f5">CRUD搬砖两三年了，怎么阅读Spring源码？ - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/c3e190cb6e9d080d2c505a640">16张图解锁Spring的整体脉络_Java_4ye_InfoQ写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mOb8-fv_B6R32vmAvYT4-Q">SpringBoot 应用程序启动过程揭秘</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/17b66e6390fd">面试被问烂的 Spring IOC(求求你别再问了) - 简书</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e18fd44964eb">面试问烂的 Spring AOP 原理、SpringMVC 过程 - 简书</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LjVR3ycYiVI_Mt2Krhd31g">深入聊一聊 Spring AOP 实现机制</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/fuzhengwei/small-spring">fuzhengwei&#x2F;small-spring</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/zhangxufeng/blog/1935556">Spring事务用法示例与实现原理 - charming丶的个人空间 - OSCHINA - 中文开源技术交流社区</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/1tsAPsP_X-liOH8FI2T5Ig">Spring的统一事务模型</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eXa4SXI53KNS73ru-ePUWg">Spring的声明式事务模型</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20597727/article/details/84868035">spring源码阅读--@Transactional实现原理_一撸向北的博客-CSDN博客_@transactional注解</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3d4yeg3CIuFEa-4gkelObQ">几行烂代码，用错 Transactional，我赔了16万</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ad4e275263e1729e986c51ca1">创建spring boot starter - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kzD7wY9toto8c1CzcZRHYg">高级java开发必须掌握的Spring接口——SmartLifecycle</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wLy5ef3YkF7GstVyV5qU5Q">研究优雅停机时的一点思考</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zFzUZPJ-ib2zbDYWN26iuA">Spring Boot 最流行的 16 条实践解读！</a></p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/ssj234/netty-source/433211">Netty源码笔记 · 看云</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/tag/netty/">netty - 标签 - duanxz - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007282628">源码之下无秘密 ── 做最好的 Netty 源码分析教程 - SegmentFault 思否</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2MzU3Mjc3Ng==&action=getalbum&album_id=2217816582418956300">bin的技术小屋</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HxaSNqrQP2V35Q1IM2mRpg">记一次 Netty 堆外内存泄露排查过程</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/10/18/netty-direct-memory-screening.html">Netty堆外内存泄露排查盛宴 - 美团技术团队</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/v-WpOgEQkoWOuAurMFJfdg">Netty 实现长连接服务的难点和优化点</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/T6Av8yRLhis4oGCZtEUKcg">从线上偶发的宕机事件看Netty流量控制</a></p>
<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/bFeVH3-j9n3poZ-Nz7s7IQ">35 个 Java 代码优化细节</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/8114fba36dae232639f1c6efa">一文说透”静态代理”与”动态代理” - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/93aae8b4ca45bebf727921b87">面试官问你MyBatis SQL是如何执行的？把这篇文章甩给他 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/x509eBHiDuasGmJupJKVow">进击的 Java ，云原生时代的蜕变</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tS0U7NzsZ4MA-mg-2ZgAxw">来，带你鸟瞰 Java 中的并发框架！</a></p>
<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40820574">mysql索引简明教程</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qHJiTjpvDikFcdl9SRL97Q">深入理解 MySQL 索引底层原理</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9tmSxQ-EUzZYibLAMPaFZg">InnoDB一棵B+树可以存放多少行数据？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/S6I2HL89I0NfTw0I_Lr5PQ">Mysql Replication 简明教程</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/8076617eff6ab380de5232fc0">一条SQL语句执行得很慢的原因盘点 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MVh9c_kIV1NSvM54lAnDSw">如何诊断Java代码中常见的数据库性能热点问题？</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904135964229646">没内鬼，来点干货！SQL优化和诊断</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/b9251e9e3c28fbfaeb1c30528">MySQL“被动”性能优化汇总！ - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006158186">MySQL大表优化方案</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html">大众点评订单系统分库分表实践 - 美团技术团队</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yjmyzz/p/12149737.html">分表分页&#x2F;跨库分页为什么这么难？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mL_9HJmBfey_kJDjfNTtlw">分库分表技术演进&amp;最佳实践</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MqFsz1BcLPq9DJ3up2ZSyw">分库分表&amp;百亿级数据迁移</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系 - 美团技术团队</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hollischuang/p/15522907.html">MySQL 默认隔离级别是RR，为什么大厂会改成RC？ - HollisChuang - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zejin2008/p/5262751.html">Mysql并发时经典常见的死锁原因及解决方法 - 泽锦 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NoR1bEm8gs4YmkxxHUuNpA">Mysql可重复读（1） —— 快照何时创建</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O_Efr9acyz2y52ESVJ0zPw">Mysql可重复读（2） —— 快照真的就是快照吗</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/liughDevelop/blog/1631006">自己手写一个Mybatis框架(简化)</a></p>
<h1 id="Redis和缓存"><a href="#Redis和缓存" class="headerlink" title="Redis和缓存"></a>Redis和缓存</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linianhui/p/what-problem-does-redis-solve.html">Redis解决了哪些问题？</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/liughDevelop/blog/2236771">Redis为何这么快–数据存储角度</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/redis-io-multiplexing/">Redis 和 I&#x2F;O 多路复用</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903651182542856">缓存三大问题及解决方案</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chang384915878/article/details/86756463">如何保证缓存与数据库的双写一致性？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DNraZpi_00MeDw7fTjgJlQ">深入浅出分布式缓存的通用方法</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yGh9hI-bz_yyrIdBFwwyqA">后端缓存的23个关键关注点</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TPJwulKmZmJjGSxLDwiPhQ">浅析 Redis 分布式锁解决方案-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://susan.net.cn/post/2/2005/">redis分布式锁的8大坑</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040177140">Redis 实战篇：巧用 Bitmap 实现亿级数据统计 - SegmentFault 思否</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aMp0xoGPlY0XmJORzTmUZw">如何判断一个元素在亿级数据中是否存在？</a></p>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6HviLSsQqdo0B4zwZJB5tQ">ApacheRocketMQ 101</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7b77723d4f96">Kafka简明教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/51XSHW2opSmakhHmtth8">你可能用错了kafka的重试机制-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ce0507f41cfbe82baec09b128">消息队列之推还是拉，RocketMQ 和 Kafka 是如何做的？ - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/a3f9ed5b4f758a0bf430e4bb7">7张图揭晓RocketMQ存储设计的奥妙_RocketMQ_中间件兴趣圈_InfoQ写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/24b51de341d66de6d1e737d65">Kafka和RocketMQ底层存储之那些你不知道的事 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/49bc80d683c373db93d017a99">聊聊 Kafka： Kafka 为啥这么快？_签约计划第二季_老周聊架构_InfoQ写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/4uhJGtqKy5BZJ1EqUPT8">快手基于 RocketMQ 的在线消息系统建设实践-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OHmS00ax_Yf2p9xRjUeDJg">金融行业消息队列选型及实践</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FuUICaNihx1PPKfxRTN1Fg">万亿级数据洪峰下的分布式消息引擎</a></p>
<h1 id="其他中间件"><a href="#其他中间件" class="headerlink" title="其他中间件"></a>其他中间件</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qStIOFcynQCiYw-WppAebg">MongoDB 全方位知识图谱</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nwBaChd-PQvKHzVtE6GcSw">Clickhouse 在腾讯的应用实践</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI2NDExNTk5Mg==&mid=2247490796&idx=1&sn=ea9ff9bd3e244ad1eac47e083c54b983">DB与ES混合之应用系统场景分析探讨</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/lTtyNrJRdrHZxWq44cTQ">从MongoDB迁移到ES后，我们减少了80%的服务器 - InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1ad810427783">学学Elasticsearch：Term查询和全文查询，一文详解 - 简书</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luxiaoxun/p/13025019.html">LSM树和Elasticsearch的索引写入机制 - 阿凡卢 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/323288">LevelDB vs. RocksDB - 墨天轮</a></p>
<h1 id="network"><a href="#network" class="headerlink" title="network"></a>network</h1><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/170d6f8626853a79fbf6d99d0">从linux源码看socket的阻塞和非阻塞 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上） | 酷 壳 - CoolShell</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下） | 酷 壳 - CoolShell</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/9a880969fb8a72f366d4cac7b">Nginx16连环问 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/495e11547cc63794f693c1e73">两万字长文50+张趣图带你领悟网络编程的内功心法 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/p0I0Ny27iuUKKOtXopkM">HTTP客户端演进之路_语言 &amp; 开发_尼先_InfoQ精选文章</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kingszelda/p/8988505.html">Http持久连接与HttpClient连接池 - kingszelda - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/V62VYS8KFNKxJxfzMYefrw">腾讯HTTPS性能优化实践</a></p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zdy0_2004/article/details/52760404">分布式系统互斥性与幂等性问题的分析与解决</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/7c9c58931e121ffdfc3a14ab9">两天，我把分布式事务搞完了 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/bj9LZYVL02TwixVTr1e8">如何通过事务消息保障抢购业务的分布式一致性？-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aQq02jLLwBzF8bJZNpqVxA">很短 | 图解 Raft 算法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/us5GJQQZ8bMbEHa25Io0">从Paxos到Raft，分布式一致性算法解析-InfoQ</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/35dded4a7bfccda45135b8106">设计模式前传——为什么要学设计模式 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hwaggLee/p/4510687.html">Spring 框架用到的 9 个设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.crazyant.net/2022.html">Mybatis 使用的 9 种设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/03/19/design-pattern-practice-in-marketing.html">设计模式在外卖营销业务中的实践 - 美团技术团队</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Vt1OpvD-3NL8KxpfBYTArA">观察者模式 vs 发布订阅模式</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/f842296000c0266b25c9f1425">代码优化和实时重构</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VBGeI308sbTn8qNY-wASjQ">互联网架构：屡试不爽的架构三马车</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/87JWlUoc03UZy2ar3p4NlA">互联网架构三板斧之并发</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/fb329544ccb204706e2057674">应对高并发系统有没有通用的解决方案呢？ - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangyingsheng/p/13744422.html">服务端性能优化–最大QPS推算及验证 - huangyingsheng - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://weibo.com/1667773473/LslU6zRcd">QPS和延时的乘积是常量</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/625a2409d41032c89ec07bd21">调度算法20张图 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://www.v2ex.com/t/770751">不懂就问：如何正确设计一个订单号？ - V2EX</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/JxlQYZL7egaTCBkOolq9">维护几十种语言和站点，爱奇艺国际站WEB端网页优化实践-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/8kwSM0CaUVYW1EzeO7GT">Hadoop 怎么了，大数据路在何方 - InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/5iS20POTfqLEQviCAcSW">到达率99.9%：闲鱼消息在高速上换引擎（集大成）-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/8XjjcmepU8gBHsQfV3b9">我看阿里双11技术架构：用有限的资源解决更多的问题-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/8b0d678eef570078f56a35da9">“攻城狮”实用指南之Linux CPU性能优化 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/6698c4b668dafb9e3229bc0d9">常用注册中心原理及比较 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zWKipzcmZqQHG3psahiwVQ">QPS 相比 Nginx 提升60%，阿里 Tengine 负载均衡算法揭秘</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.openacid.com/algo/paxos/">可靠分布式系统-paxos的直观解释 - OpenACID Blog</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/jiangyi/3772035">最终一致性和实时一致性是什么？在架构设计中，我们应该选择哪种方式？_我爱娃哈哈的技术博客_51CTO博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/GymHAbqVRO214qo44jHD">石墨文档Websocket百万长连接技术实践_产品_杜旻翔_InfoQ精选文章</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3F5lwv5LtOqBa7S0Owf4XQ">虽然难用，但12306面临的业务场景复杂度可能是世界之最</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/29779732/answer/45791817">端游、手游服务端常用的架构是什么样的？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hMD-IS__4JE5_nQhYPYSTg">四步构建异地多活</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/kevingo/system-design-primer-zh-tw/blob/master/README-zh-Hans.md">system-design-primer-zh-tw</a></p>
<h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AtPvdNPG3jECO0UZxwhsgw">出了bug怎么办</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5PfaaWBFCw5-MuAnR7ABiQ">技术大牛养成指南，一篇不鸡汤的成功学实践</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nKJy66zWiXeWVdYDaXt1gQ">技术人最重要的能力是什么？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nUtUu6e_bXHvb_06Pf_05g">阿里毕玄现身说法：程序员成长路线</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XIwfj_AdZqX_vHM4VIq9EA">万字详文阐释程序员修炼之道</a></p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d187c7fe51d4577523f23d0">构建安全可靠、最小化的 Docker 镜像 - 掘金</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/97355a6e7ac01bce8532d5ff5">Docker 网络模式详解及容器间网络通信 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/a05ee3274903e974b0cb2e436">Docker映射详解，没问题了！ - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/KCLh8SPcVsQxrW2tTV2w">从零开始入门 K8s：深入剖析 Linux 容器-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/eULlQ4A3RcaLLQeImQy9">不要把大型JAR包放进Docker镜像-InfoQ</a></p>
<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><p><a target="_blank" rel="noopener" href="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/">Build web application with Golang</a></p>
<p><a target="_blank" rel="noopener" href="https://gobyexample-cn.github.io/">Go by Example 中文版</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/">Go 语言设计与实现 | Go 语言设计与实现</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/QXD7a37pFvYiY8bHy1Ut">如何写出优雅的 Golang 代码-InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WjaHJHE7ZPbgo7QwIDwZzQ">程序员开发效率神器汇总！</a></p>
<h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697270253&idx=2&sn=d323c28476904caaeae1195debcec70d">干货 | 携程AI应用的推理性能优化</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/j7Hs9dGt5YLVgUTY-K9B">干货|基于CPU的深度学习推理部署优化实践 - InfoQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/0PKOlHjfs3CQWkqTAQ6T">从软件开发到AI领域工程师：模型训练篇 - InfoQ</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/31f421e0bfa2c182c07a7326f">C++ 借来的资源，如何还的潇洒？ - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012999985/article/details/48791641">C++按格式接收输入字符_Jerish的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/c7045d48ccb28872277445ff8">百度C++工程师的那些极限优化（并发篇） - InfoQ 写作平台</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2022-07-07-%E3%80%8A%E8%81%8A%E8%81%8ANetty%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-07-%E3%80%8A%E8%81%8A%E8%81%8ANetty%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html" class="post-title-link" itemprop="url">《聊聊Netty那些事》阅读笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-07T00:00:00+08:00">2022-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-25 15:22:51" itemprop="dateModified" datetime="2022-07-25T15:22:51+08:00">2022-07-25</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

            <div class="post-description">《聊聊Netty那些事》bin的技术小屋, 保留一些重要的内容和有很多形象的配图</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内核IO模型"><a href="#内核IO模型" class="headerlink" title="内核IO模型"></a>内核IO模型</h1><h2 id="网络包接收流程"><a href="#网络包接收流程" class="headerlink" title="网络包接收流程"></a>网络包接收流程</h2><p>接收网络数据包的详细开销</p>
<ul>
<li>从<code>网卡</code>DMA拷贝网络数据包到<code>内存</code>中的开销(DMA指网卡可以在没有CPU参与的情况下独立写内存)</li>
<li>CPU收到<code>硬中断</code>后调用网卡驱动进行响应的开销</li>
<li>OS的内核线程<code>ksoftirqd</code>响应<code>软中断</code>的开销</li>
<li>应用程序通过系统调用从<code>用户态</code>转为<code>内核态</code>的开销, 系统调用返回时从<code>内核态</code>转为<code>用户态</code>的开销</li>
<li>网络数据从<code>内存</code>的<code>内核空间</code>通过CPU拷贝到<code>用户空间</code>的开销</li>
</ul>
<p><img src="/../../../../image/netty1-1.png" alt="网络包接收过程"></p>
<p><img src="/../../../../image/netty1-2.png" alt="网络包发送过程"></p>
<h2 id="同步与异步-阻塞与非阻塞"><a href="#同步与异步-阻塞与非阻塞" class="headerlink" title="同步与异步, 阻塞与非阻塞"></a>同步与异步, 阻塞与非阻塞</h2><p>接收网络数据包的2个流程</p>
<ul>
<li>数据准备阶段:  在这个阶段, 网络数据包到达<code>网卡</code>, 通过<code>DMA</code>的方式将数据包拷贝到<code>内存</code>中, 然后经过<code>硬中断</code>, <code>软中断</code>, 接着通过内核线程<code>ksoftirqd</code>经过内核协议栈的处理, 最终将数据发送到<code>内核Socket的接收缓冲区</code>中</li>
<li>数据拷贝阶段:  当数据到达内核Socket的接收缓冲区中时, 此时数据存在于<code>内核空间</code>中, 需要将数据拷贝到<code>用户空间</code>中, 才能够被应用程序读取</li>
</ul>
<p>参考<a href="https://hahahaha123567.github.io/2022-01-14-feng-huang-jia-gou-du-shu-bi-ji-copy.html">《凤凰架构》读书摘要</a>的<code>网络IO模型</code>一节</p>
<p><a target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/connect/service-routing.html">网关路由 | 凤凰架构</a></p>
<ul>
<li>同步IO(Synchronous I&#x2F;O)<ul>
<li>阻塞IO(Blocking I&#x2F;O), 节省 CPU 资源(Java传统IO模型)</li>
<li>非阻塞IO(Non-Blocking I&#x2F;O), 浪费 CPU 资源(Java的NIO)</li>
<li>多路复用IO(Multiplexing I&#x2F;O), 主流(通过NIO实现的Reactor模式)</li>
<li>信号驱动IO(Signal-Driven I&#x2F;O), 需要自己从缓冲区获取数据</li>
</ul>
</li>
<li>异步IO(Asynchronous I&#x2F;O)(通过AIO实现的Proactor模式)</li>
</ul>
<p>阻塞与非阻塞的区别主要发生在第一阶段: 数据准备阶段</p>
<ul>
<li>阻塞模式, 当Socket的接收缓冲区中没有数据的时候, 应用线程会一直等待</li>
<li>非阻塞模式, 应用线程不会等待, 系统调用直接返回错误标志<code>EWOULDBLOCK</code></li>
</ul>
<p>同步与异步主要的区别发生在第二阶段: 数据拷贝阶段</p>
<ul>
<li>同步模式在数据准备好后, 是由用户线程的内核态来执行第二阶段, 所以应用程序会在第二阶段发生阻塞, 直到数据从内核空间拷贝到用户空间, 系统调用才会返回</li>
<li>异步模式下是由内核来执行第二阶段的数据拷贝操作, 当内核执行完第二阶段, 会通知用户线程IO操作已经完成, 并将数据回调给用户线程</li>
</ul>
<h2 id="IO多路复用-TODO"><a href="#IO多路复用-TODO" class="headerlink" title="IO多路复用 TODO"></a>IO多路复用 TODO</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><img src="/../../../../image/netty1-3.png" alt="select"></p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="/../../../../image/netty1-4.png" alt="epoll"></p>
<p>在Netty中实现的<code>EpollSocketChannel</code>默认的就是边缘触发模式, JDK的NIO默认是水平触发模式</p>
<p>epoll对select, poll的优化</p>
<ol>
<li><p>epoll在内核中通过红黑树管理海量的连接, 所以在调用<code>epoll_wait</code>获取IO就绪的socket时, 不需要传入监听的socket文件描述符, 从而避免了海量的文件描述符集合在用户空间和内核空间中来回复制</p>
</li>
<li><p>epoll仅会通知IO就绪的socket, 避免了在用户空间遍历的开销</p>
</li>
<li><p>epoll通过在socket的等待队列上注册回调函数<code>ep_poll_callback</code>通知用户程序IO就绪的socket, 避免了在内核中轮询的开销</p>
</li>
</ol>
<h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p><code>Reactor</code>基于<code>NIO</code>, <code>Proactor</code>基于<code>AIO</code></p>
<ul>
<li>单Reactor单线程<ul>
<li>单Reactor意味着只有一个epoll对象, 监听所有的事件, 包括连接事件, 读写事件</li>
<li>单线程意味着只有一个线程来执行<code>epoll_wait</code>获取IO就绪的Socket, 然后对这些就绪的Socket执行读写, 后续的业务处理也依然是这个线程</li>
</ul>
</li>
<li>单Reactor多线程<ul>
<li>只有一个epoll对象来监听所有的IO事件, 一个线程来调用<code>epoll_wait</code>获取IO就绪的Socket</li>
<li>当IO就绪事件产生时, 这些IO事件对应处理的业务Handler, 我们是通过线程池来执行, 这样相比单Reactor单线程模型提高了执行效率, 充分发挥了多核CPU的优势</li>
</ul>
</li>
<li>主从Reactor多线程<ul>
<li><code>主Reactor</code>处理连接事件</li>
<li>当创建好连接, 建立好对应的socket后, 在acceptor中将需要监听的read事件注册到<code>从Reactor</code>中, 由<code>从Reactor</code>来监听socket上的读写事件</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置单Reactor单线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(eventGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置多Reactor线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(eventGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置主从Reactor多线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>

<h2 id="Netty对Reactor模型的实现"><a href="#Netty对Reactor模型的实现" class="headerlink" title="Netty对Reactor模型的实现"></a>Netty对Reactor模型的实现</h2><p><img src="/../../../../image/netty1.png" alt="Netty中的reactor"></p>
<p>Reactor在netty中是以group的形式出现的, netty中将Reactor分为两组, 一组是<code>主ReactorGroup</code>也就是<code>bossGroup</code>, 另一组是<code>从ReactorGroup</code>也就是<code>workerGroup</code></p>
<h3 id="主ReactorGroup"><a href="#主ReactorGroup" class="headerlink" title="主ReactorGroup"></a>主ReactorGroup</h3><p><code>主ReactorGroup</code>中通常只有一个Reactor, 专门负责监听<code>连接accept事件</code>, 当有连接事件产生时, 在acceptor中创建相应的<code>NioSocketChannel</code>(代表一个Socket连接), 然后以负载均衡的方式在<code>从ReactorGroup</code>中选一个Reactor, 注册监听<code>Read事件</code></p>
<p><code>主ReactorGroup</code>中只有一个Reactor, 因为通常我们服务端程序只会绑定监听一个端口, 如果要绑定监听多个端口, 就会配置多个Reactor</p>
<h3 id="从ReactorGroup"><a href="#从ReactorGroup" class="headerlink" title="从ReactorGroup"></a>从ReactorGroup</h3><p><code>从ReactorGroup</code>中有多个Reactor, 具体Reactor的个数可以由系统参数指定, 默认的Reactor的个数为<code>CPU核数 * 2</code>, <code>从ReactorGroup</code>中的Reactor主要负责监听读写事件, 每一个Reactor负责监听一组socket连接</p>
<p>Socket连接在创建后就被固定的分配给一个Reactor, 所以一个Socket连接也只会被一个固定的IO线程执行, 这种无锁串行化的设计的目的是为了防止多线程并发执行同一个socket连接上的IO逻辑处理, 防止出现线程安全问题</p>
<ol>
<li>轮询IO就绪事件</li>
<li>处理IO事件</li>
<li>执行异步任务</li>
</ol>
<p>由于每个Reactor中只有一个IO线程, <code>ChannelHandler</code>中执行的逻辑不能耗时太长, 尽量将耗时的业务逻辑处理放入单独的业务线程池中处理, 否则会影响其他连接的IO读写, 从而影响整个服务程序的IO吞吐</p>
<h1 id="Reactor在Netty中的实现-创建"><a href="#Reactor在Netty中的实现-创建" class="headerlink" title="Reactor在Netty中的实现(创建)"></a>Reactor在Netty中的实现(创建)</h1><h2 id="Netty服务端代码模板"><a href="#Netty服务端代码模板" class="headerlink" title="Netty服务端代码模板"></a>Netty服务端代码模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Echoes back any received data from a client.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        <span class="comment">//创建主从Reactor线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">EchoServerHandler</span> <span class="variable">serverHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup) <span class="comment">// 配置主从Reactor</span></span><br><span class="line">             .channel(NioServerSocketChannel.class) <span class="comment">// 配置主Reactor中的channel类型</span></span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>) <span class="comment">// 设置主Reactor中channel的option选项</span></span><br><span class="line">             .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">// 设置主Reactor中Channel-&gt;pipline-&gt;handler</span></span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="comment">// 设置从Reactor中注册channel的pipeline</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                     <span class="comment">// p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口启动服务, 开始监听accept事件</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建<code>主从ReactorGroup</code>, 在Netty中<code>EventLoopGroup</code>就是<code>ReactorGroup</code>的实现类, <code>EventLoop</code>就是<code>Reactor</code>的实现类</p>
<p>SocketChannel</p>
<ul>
<li><code>NioServerSocketChannel</code>, 监听Socket, 负责listen和bind, 使用<code>ServerBootstrapAcceptor</code>创建<code>NioSocketChannel</code></li>
<li><code>NioSocketChannel</code>, 客户端连接socket, 负责与客户端之间的网络通信</li>
</ul>
<p>serverBootstrap.handler设置的是服务端NioServerSocketChannel PipeLine中的ChannelHandler, ServerBootstrap启动类方法带有child前缀的均是设置客户端NioSocketChannel属性的</p>
<h2 id="创建用于启动EventLoop线程的executor"><a href="#创建用于启动EventLoop线程的executor" class="headerlink" title="创建用于启动EventLoop线程的executor"></a>创建用于启动EventLoop线程的executor</h2><p><code>ThreadPerTaskExecutor</code>, 来一个任务就创建一个线程执行, EventLoop线程的核心就是一个死循环不停的轮询IO就绪事件, 处理IO事件, 执行异步任务</p>
<h2 id="创建EventLoop"><a href="#创建EventLoop" class="headerlink" title="创建EventLoop"></a>创建EventLoop</h2><p><img src="/../../../../image/netty2.png" alt="EventLoop结构"></p>
<p>EventLoop线程组<code>NioEventLoopGroup</code>包含多个<code>EventLoop</code>, 存放于<code>private final EventExecutor[] children</code>中</p>
<p>EventLoop的核心是使用IO多路复用模型来对客户端连接上的IO事件进行监听, 所以最重要的事情是创建Selector</p>
<p>openSelector是NioEventLoop类中用于创建IO多路复用的Selector, 并对创建出来的JDK NIO原生的Selector进行性能优化: </p>
<ol>
<li>将<code>SelectorImpl</code>中存放可用socket的<code>HashSet</code>使用反射修改为<code>SelectedSelectionKeySet</code>, 底层实现从<code>HashMap</code>变为<code>数组</code>, 优化遍历、插入性能, 利用cpu cache</li>
<li>使用代理模式, 用<code>SelectedSelectionKeySetSelector</code>代理selector的真实实现类, 在每次遍历结束后清空SelectedSelectionKeySet的内容</li>
</ol>
<p>EventLoop内的异步任务队列的类型为<code>MpscQueue</code>,它是由<code>JCTools</code>提供的一个高性能无锁队列, 从命名前缀Mpsc可以看出, 它适用于多生产者单消费者的场景</p>
<p>EventLoop负责执行的异步任务分为三类: </p>
<ul>
<li>普通任务: 这是Netty最主要执行的异步任务, 存放在普通任务队列taskQueue中, 在<code>NioEventLoop</code>构造函数中创建</li>
<li>定时任务: 存放在优先级队列中</li>
<li>尾部任务: 存放于尾部任务队列tailTasks中, 尾部任务一般不常用, 在普通任务执行完后 EventLoop线程会执行尾部任务, 比如对Netty的运行状态做一些统计数据, 例如任务循环的耗时、占用物理内存的大小等等都可以向尾部队列添加一个收尾任务完成统计数据的实时更新</li>
</ul>
<h2 id="创建Channel到EventLoop的绑定策略"><a href="#创建Channel到EventLoop的绑定策略" class="headerlink" title="创建Channel到EventLoop的绑定策略"></a>创建Channel到EventLoop的绑定策略</h2><p>无论是Netty服务端<code>NioServerSocketChannel</code>关注的<code>OP_ACCEPT</code>事件, 还是Netty客户端<code>NioSocketChannel</code>关注的<code>OP_READ</code>和<code>OP_WRITE</code>事件, 都需要先注册到EventLoop上, EventLoop才能监听Channel上关注的IO事件实现IO多路复用</p>
<p><code>MultithreadEventExecutorGroup</code>类的构造器参数<code>EventExecutorChooserFactory</code>负责创建Channel到EventLoop的绑定策略, 默认为round-robin轮询, 如果EventLoop数量为2的次幂可以用移位快速计算</p>
<h1 id="Netty启动流程"><a href="#Netty启动流程" class="headerlink" title="Netty启动流程"></a>Netty启动流程</h1><p><img src="/../../../../image/netty3-1.png" alt="EventLoop启动流程图"></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>不管是服务端用到的<code>NioServerSocketChannel</code>还是客户端用到的<code>NioSocketChannel</code>, 每个Channel实例都会有一个Pipeline, Pipeline中有多个<code>ChannelHandler</code>用于编排处理对应Channel上感兴趣的IO事件</p>
<p>向<code>NioServerSocketChannel</code>中的Pipeline添加<code>ChannelHandler</code>分为两种方式</p>
<ol>
<li>显式添加: 用户通过<code>ServerBootstrap#handler</code>添加, 如果需要添加多个<code>ChannelHandler</code>, 则可以通过<code>ChannelInitializer</code>向pipeline中进行添加</li>
<li>隐式添加: 隐式添加主要添加的就是<code>MainEventLoopGroup</code>的核心组件, 也就是图中的acceptor, Netty中的实现为<code>ServerBootstrapAcceptor</code>, 本质上也是一种<code>ChannelHandler</code>, 主要负责在客户端连接建立好后, 初始化客户端<code>NioSocketChannel</code>, 在从EventLoop线程组中选取一个<code>SubEventLoop</code>, 将客户端<code>NioSocketChannel</code>注册到<code>SubEventLoop</code>中的selector上</li>
</ol>
<p><img src="/../../../../image/netty3.png" alt="EventLoopGroup结构"></p>
<p>由于在Netty的IO线程模型中, 是由单个<code>SubEventLoop</code>线程负责执行客户端<code>NioSocketChannel</code>中的Pipeline, 一个<code>SubEventLoop</code>线程负责处理多个<code>NioSocketChannel</code>上的IO事件, 如果Pipeline中的<code>ChannelHandler</code>添加的太多, 就会影响<code>SubEventLoop</code>线程执行其他<code>NioSocketChannel</code>上的Pipeline, 从而降低IO处理效率, 降低吞吐量</p>
<p>所以Pipeline中的<code>ChannelHandler</code>不易添加过多, 并且不能在<code>ChannelHandler</code>中执行耗时的业务处理任务</p>
<h2 id="Netty服务端的启动"><a href="#Netty服务端的启动" class="headerlink" title="Netty服务端的启动"></a>Netty服务端的启动</h2><p><img src="/../../../../image/netty9.png" alt="EventLoop启动后的结构"></p>
<p>Netty服务端的启动流程总体如下: </p>
<ol>
<li>创建服务端<code>NioServerSocketChannel</code>并初始化</li>
<li>将服务端<code>NioServerSocketChannel</code>注册到<code>主EventLoopGroup</code>中</li>
<li>注册成功后, 开始初始化<code>NioServerSocketChannel</code>中的pipeline, 然后在pipeline中触发<code>ChannelRegister</code>事件</li>
<li>随后由<code>NioServerSocketChannel</code>绑定端口地址</li>
<li>绑定端口地址成功后, 向<code>NioServerSocketChannel</code>对应的Pipeline中触发传播<code>ChannelActive</code>事件, 在事件回调中向<code>MainEventLoop</code>注册<code>OP_ACCEPT</code>事件, 开始等待客户端连接, 服务端启动完成</li>
</ol>
<p>代码执行流程:</p>
<ol>
<li>创建<code>NioServerSocketChannel</code></li>
<li>初始化<code>NioServerSocketChannel</code></li>
<li>向<code>MainEventLoop</code>注册<code>NioServerSocketChannel</code><ol>
<li><code>MainEventLoopGroup</code>中选取一个<code>MainEventLoop</code>进行注册</li>
<li>向绑定后的<code>MainEventLoop</code>进行注册</li>
<li><code>MainEventLoop</code>的启动</li>
<li>startThread</li>
<li>register0, 封装为异步任务</li>
<li>doRegister(), 添加Acceptor封装为异步任务</li>
<li><code>HandlerAdded</code>事件回调中初始化ChannelPipeline</li>
<li>回调regFuture的<code>ChannelFutureListener</code></li>
</ol>
</li>
<li>doBind0, 封装为异步任务</li>
<li>绑定端口地址<ol>
<li>HeadContext</li>
<li><code>channelActive</code>事件处理, 封装为异步任务</li>
<li>beginRead</li>
</ol>
</li>
</ol>
<p><code>Unsafe</code>为<code>Channel</code>接口的一个内部接口, 用于定义实现对Channel底层的各种操作, Unsafe接口定义的操作行为只能由Netty框架的Reactor线程调用, 用户线程禁止调用</p>
<p>Netty自定义的<code>SocketChannel</code>类型均继承<code>AttributeMap</code>接口以及<code>DefaultAttributeMap</code>类, 正是它们定义了<code>ChannelAttributes</code>, 用于向Channel添加用户自定义的一些信息</p>
<p>初始化<code>NioServerSocketChannel</code>中pipeline的时机是: 当<code>NioServerSocketChannel</code>注册到<code>MainEventLoop</code>之后, 绑定端口地址之前</p>
<p><code>MainEventLoop</code>线程是在提交第一个异步任务的时候启动的, 在用户程序(Main线程)提交用于注册<code>NioServerSocketChannel</code>的异步任务时开始启动</p>
<h1 id="Reactor的架构"><a href="#Reactor的架构" class="headerlink" title="Reactor的架构"></a>Reactor的架构</h1><h2 id="Reactor线程的整个运行框架"><a href="#Reactor线程的整个运行框架" class="headerlink" title="Reactor线程的整个运行框架"></a>Reactor线程的整个运行框架</h2><p>Netty中的Reactor线程主要干三件事情: </p>
<ul>
<li>轮询注册在<code>EventLoop</code>上的所有Channel感兴趣的IO就绪事件</li>
<li>处理Channel上的IO就绪事件</li>
<li>执行Netty中的异步任务</li>
</ul>
<p><code>EventLoop</code>线程其实执行的就是一个死循环, 在死循环中不断的通过Selector去轮询IO就绪事件, 如果发生IO就绪事件则从Selector系统调用中返回并处理IO就绪事件, 如果没有发生IO就绪事件则一直阻塞在Selector系统调用上, 直到满足Selector唤醒条件:</p>
<ol>
<li>当Selector轮询到有IO活跃事件发生时</li>
<li>当<code>EventLoop</code>线程需要执行的定时任务到达任务执行时间deadline时</li>
<li>当有异步任务提交给<code>EventLoop</code>时, <code>EventLoop</code>线程需要从Selector上被唤醒, 这样才能及时的去执行异步任务</li>
</ol>
<p><img src="/../../../../image/netty5.png" alt="EventLoop工作流程图"></p>
<h2 id="Reactor线程轮询IO就绪事件"><a href="#Reactor线程轮询IO就绪事件" class="headerlink" title="Reactor线程轮询IO就绪事件"></a>Reactor线程轮询IO就绪事件</h2><p>在Reactor线程的轮询工作开始之前, 需要首先判断下当前是否有异步任务需要执行, 判断依据就是查看Reactor中的异步任务队列taskQueue和用于统计信息任务用的尾部队列tailTask是否有异步任务</p>
<p>如果Reactor中有异步任务需要执行, 那么Reactor线程需要立即执行, 不能阻塞在Selector上, 在返回前需要再顺带调用<code>selectNow()</code>非阻塞查看一下当前是否有IO就绪事件发生, 如果有, 那么正好可以和异步任务一起被处理, 如果没有, 则及时地处理异步任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSelectStrategy</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="type">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reactor线程要保证及时的执行异步任务</span></span><br><span class="line"><span class="comment">     * 1: 如果有异步任务等待执行, 则马上执行selectNow()非阻塞轮询一次IO就绪事件</span></span><br><span class="line"><span class="comment">     * 2: 没有异步任务, 则跳到switch select分支</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">IntSupplier</span> <span class="variable">selectNowSupplier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntSupplier</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">return</span> selector.selectNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>NioEventLoop</code>是<code>ScheduledExecutorService</code>的子类, 支持执行定时任务, 在阻塞轮询IO任务之前通过<code>AbstractScheduledEventExecutor</code>的<code>nextScheduledTaskDeadlineNanos</code>获取到下个定时任务执行的时间作为阻塞超时时间</p>
<p>异步任务在被提交后希望立马得到执行, 那么就在提交异步任务的时候去唤醒正在阻塞轮询的Reactor线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">        strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 执行到这里说明EventLoop已经从Selector上被唤醒了</span></span><br><span class="line">    <span class="comment">// 设置EventLoop的状态为苏醒状态AWAKE</span></span><br><span class="line">    <span class="comment">// lazySet优化不必要的volatile操作, 不使用内存屏障, 不保证写操作的可见性（单线程不需要保证）</span></span><br><span class="line">    nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reactor处理IO与处理异步任务的时间比例分配"><a href="#Reactor处理IO与处理异步任务的时间比例分配" class="headerlink" title="Reactor处理IO与处理异步任务的时间比例分配"></a>Reactor处理IO与处理异步任务的时间比例分配</h2><p>Netty通过ioRatio变量来调配<code>EventLoop</code>线程在处理IO事件和执行异步任务之间的CPU时间分配比例, 防止<code>EventLoop</code>线程处理异步任务时间过长而导致I&#x2F;O 事件得不到及时地处理</p>
<p><code>ioRatio / 100 = 执行异步任务时间 / (执行异步任务时间 + 轮询IO事件时间)</code>, 默认50</p>
<h2 id="Reactor线程处理IO就绪事件"><a href="#Reactor线程处理IO就绪事件" class="headerlink" title="Reactor线程处理IO就绪事件"></a>Reactor线程处理IO就绪事件</h2><ol>
<li><code>processSelectedKeysPlain</code>, JDK实现<ol>
<li>获取IO就绪的Channel</li>
<li>处理Channel上的IO事件<ol>
<li>处理Connect事件</li>
<li>处理Write事件</li>
<li>处理Read事件或者Accept事件</li>
</ol>
</li>
<li>从Selector中移除失效的<code>SelectionKey</code>, 为了保证Selector中所有KeySet的有效性, 需要在Channel取消个数达到256时, 触发一次selectNow, 目的是清除无效的<code>SelectionKey</code></li>
</ol>
</li>
<li><code>processSelectedKeysOptimized</code>, Netty实现<ol>
<li>数组需要手动做清除</li>
</ol>
</li>
</ol>
<p>服务端<code>NioServerSocketChannel</code>中的Read方法处理的是Accept事件, 客户端<code>NioSocketChannel</code>中的Read方法处理的是Read事件</p>
<h2 id="Reactor线程处理异步任务"><a href="#Reactor线程处理异步任务" class="headerlink" title="Reactor线程处理异步任务"></a>Reactor线程处理异步任务</h2><p><code>EventLoop</code>线程执行异步任务的核心逻辑:</p>
<ol>
<li>先将到期的定时任务从定时任务队列<code>scheduledTaskQueue</code>中全部取出并转存到普通任务队列taskQueue中</li>
<li>由<code>EventLoop</code>线程统一从普通任务队列taskQueue中取出任务执行</li>
<li>在<code>EventLoop</code>线程执行完定时任务和普通任务后, 开始执行存储于尾部任务队列tailTasks中的尾部任务</li>
</ol>
<h2 id="规避JDK-Epoll空轮询bug"><a href="#规避JDK-Epoll空轮询bug" class="headerlink" title="规避JDK Epoll空轮询bug"></a>规避JDK Epoll空轮询bug</h2><p>JDK NIO Epoll的空轮询BUG会导致<code>EventLoop</code>线程在没有任何事情可做的情况下被意外唤醒, 导致CPU空转</p>
<p>既没有IO就绪事件, 也没有异步任务, <code>EventLoop</code>线程从Selector上被异常唤醒, 发生512次之后认为已触发bug, 则重建Selector(将之前注册的所有Channel重新注册到新的Selector上并关闭旧的Selector), selectCnt计数归0</p>
<h1 id="Netty接收网络连接"><a href="#Netty接收网络连接" class="headerlink" title="Netty接收网络连接"></a>Netty接收网络连接</h1><h2 id="MainReactor处理OP-ACCEPT事件"><a href="#MainReactor处理OP-ACCEPT事件" class="headerlink" title="MainReactor处理OP_ACCEPT事件"></a>MainReactor处理OP_ACCEPT事件</h2><p>Netty将<code>OP_ACCEPT</code>事件处理的入口函数封装在<code>NioServerSocketChannel</code>里的底层操作类Unsafe的read方法中</p>
<p><img src="/../../../../image/netty6.png" alt="接收客户端连接"></p>
<p>main reactor线程是在一个无限循环read loop中不断的调用JDK NIO <code>serverSocketChannel.accept()</code>方法来接收完成三次握手的客户端连接<code>NioSocketChannel</code>的, 并将接收到的<code>NioSocketChannel</code>临时保存在<code>List&lt;Object&gt; readBuf</code>集合中, 后续在<code>NioServerSocketChannel</code>的pipeline中通过<code>ChannelRead</code>事件来传递, 最终会在<code>ServerBootstrapAcceptor</code>这个ChannelHandler中被处理初始化, 并将其注册到<code>SubEventLoop</code>中</p>
<p>这里的read loop循环会被限定只能读取16次, 当<code>MainEventLoop</code>从<code>NioServerSocketChannel</code>中读取客户端连接<code>NioSocketChannel</code>的次数达到16次之后, 无论此时是否还有客户端连接都不能在继续读取了, 因为还需要分配时间去执行异步任务, 不能因为无限制的接收客户端连接而耽误了异步任务的执行</p>
<h2 id="doReadMessages接收客户端连接"><a href="#doReadMessages接收客户端连接" class="headerlink" title="doReadMessages接收客户端连接"></a>doReadMessages接收客户端连接</h2><p>根据<code>ServerSocketChannel</code>的accept方法获取到JDK NIO 原生的<code>SocketChannel</code>(用于底层真正与客户端通信的Channel), 来创建Netty中的<code>NioSocketChannel</code></p>
<p><code>NioServerSocketChannel</code>与<code>NioSocketChannel</code>的不同</p>
<ol>
<li><code>NioServerSocketChannel</code>在<code>EventLoop</code>启动过程中创建, <code>NioSocketChannel</code>在<code>EventLoop</code>接收连接时被<code>NioServerSocketChannel</code>创建</li>
<li><code>NioServerSocketChannel</code>向<code>MainEventLoop</code>注册<code>OP_ACCEPT</code>事件, <code>NioSocketChannel</code>向<code>SubEventLoop</code>注册<code>OP_READ</code>事件</li>
<li><code>NioServerSocketChannel</code>继承<code>AbstractNioMessageChannel</code>, 输出的Message指的是<code>SocketChannel</code>客户端连接; <code>NioSocketChannel</code>继承的是<code>AbstractNioByteChannel</code>, 输出的是网络数据Byte</li>
</ol>
<p><img src="/../../../../image/netty8.png" alt="NioSocketChannel结构"></p>
<h2 id="ChannelRead事件的响应"><a href="#ChannelRead事件的响应" class="headerlink" title="ChannelRead事件的响应"></a>ChannelRead事件的响应</h2><p><code>ServerBootstrapAcceptor</code>主要的作用就是初始化客户端<code>NioSocketChannel</code>, 并将客户端<code>NioSocketChannel</code>注册到<code>从ReactorGroup</code>中, 并监听OP_READ事件</p>
<h2 id="向从ReactorGroup注册NioSocketChannel"><a href="#向从ReactorGroup注册NioSocketChannel" class="headerlink" title="向从ReactorGroup注册NioSocketChannel"></a>向从ReactorGroup注册NioSocketChannel</h2><ol>
<li>从<code>从ReactorGroup</code>中选取一个<code>从Reactor</code>进行绑定</li>
<li>向绑定的<code>从Reactor</code>上注册<code>NioSocketChannel</code></li>
<li>register0</li>
</ol>
<h1 id="Netty接收网络数据"><a href="#Netty接收网络数据" class="headerlink" title="Netty接收网络数据"></a>Netty接收网络数据</h1><h2 id="SubReactor处理OP-READ事件流程总览"><a href="#SubReactor处理OP-READ事件流程总览" class="headerlink" title="SubReactor处理OP_READ事件流程总览"></a>SubReactor处理OP_READ事件流程总览</h2><p>当网络数据到达服务端的网卡并经过内核协议栈的处理, 最终数据到达Socket的接收缓冲区之后, <code>SubEventLoop</code>轮询到<code>NioSocketChannel</code>上的<code>OP_READ</code>事件就绪, 随后<code>SubEventLoop</code>线程就会从JDK Selector上的阻塞轮询API<code>selector.select(timeoutMillis)</code>调用中返回, 转而去处理<code>NioSocketChannel</code>上的<code>OP_READ</code>事件</p>
<p><code>SubEventLoop</code>在处理Channel上的IO事件入口函数为<code>NioEventLoop#processSelectedKey</code></p>
<h2 id="Netty接收网络数据流程总览"><a href="#Netty接收网络数据流程总览" class="headerlink" title="Netty接收网络数据流程总览"></a>Netty接收网络数据流程总览</h2><p><img src="/../../../../image/netty10.png" alt="Netty接收网络数据流程"></p>
<p><code>NioSocketChannel</code>读取连接数据的read loop中受最大读取次数的限制, 默认配置最多只能读取16次, 超过16次无论此时<code>NioSocketChannel</code>中是否还有可读数据都不能在进行读取了</p>
<ul>
<li>lastBytesRead &lt; 0: 表示客户端主动发起了连接关闭流程, Netty开始连接关闭处理流程</li>
<li>lastBytesRead &#x3D; 0: 表示当前<code>NioSocketChannel</code>上的数据已经全部读取完毕, 没有数据可读, 本次<code>OP_READ</code>事件处理完毕</li>
<li>lastBytesRead &gt; 0: 表示在本次read loop中从<code>NioSocketChannel</code>中读取到了数据, 会在<code>NioSocketChannel</code>的pipeline中触发<code>ChannelRead</code>事件, 进而在pipeline中负责IO处理的<code>ChannelHandelr</code>中响应, 处理网络请求</li>
</ul>
<h2 id="ChannelRead和ChannelReadComplete的区别"><a href="#ChannelRead和ChannelReadComplete的区别" class="headerlink" title="ChannelRead和ChannelReadComplete的区别"></a>ChannelRead和ChannelReadComplete的区别</h2><ul>
<li><code>ChanneRead</code>事件: 一次循环读取一次数据, 就触发一次ChannelRead事件, 本次最多读取在read loop循环开始分配的<code>DirectByteBuffer</code>容量大小</li>
<li><code>ChannelReadComplete</code>事件: 当读取不到数据或者不满足continueReading的任意一个条件就会退出read loop, 这时就会触发<code>ChannelReadComplete</code>事件</li>
</ul>
<p>触发<code>ChannelReadComplete</code>事件并不代表<code>NioSocketChannel</code>中的数据已经读取完了, 只能说明本次<code>OP_READ</code>事件处理完毕, 因为有可能是客户端发送的数据太多, Netty读了16次还没读完, 那就只能等到下次<code>OP_READ</code>事件到来的时候在进行读取了</p>
<h2 id="源码核心框架总览"><a href="#源码核心框架总览" class="headerlink" title="源码核心框架总览"></a>源码核心框架总览</h2><h3 id="分配DirectByteBuffer接收网络数据"><a href="#分配DirectByteBuffer接收网络数据" class="headerlink" title="分配DirectByteBuffer接收网络数据"></a>分配DirectByteBuffer接收网络数据</h3><p><code>NioSocketChannel</code>的2个<code>ByteBufAllocator</code></p>
<ul>
<li><code>ByteBufAllocator</code>是一个<code>PooledByteBufAllocator</code>的实例, 内存池, 用来管理堆外内存<code>DirectByteBuffer</code></li>
<li><code>RecvByteBufAllocator</code>是一个<code>AdaptiveRecvByteBufAllocator</code>类的实例, 可以动态调整ByteBuffer的容量, 初始为2048</li>
</ul>
<p><code>RecvByteBufAllocator</code>计算大小, 然后<code>ByteBufAllocator</code>进行内存分配</p>
<h2 id="ByteBuffer动态自适应括缩容机制"><a href="#ByteBuffer动态自适应括缩容机制" class="headerlink" title="ByteBuffer动态自适应括缩容机制"></a>ByteBuffer动态自适应括缩容机制</h2><p>容量索引表</p>
<ol>
<li>当索引容量小于512时, 容量索引从16开始按16递增</li>
<li>当索引容量大于512时, 容量索引按前一个索引容量的2倍递增</li>
</ol>
<p><code>AdaptiveRecvByteBufAllocator</code>类中定义的扩容步长<code>INDEX_INCREMENT = 4</code>, 缩容步长<code>INDEX_DECREMENT = 1</code></p>
<ul>
<li>扩容: 取容量索引向后走4步对应的size</li>
<li>缩容: 取容量索引向前走1步对应的size, 满足两次缩容条件才会进行缩容</li>
</ul>
<h2 id="使用堆外内存为ByteBuffer分配内存"><a href="#使用堆外内存为ByteBuffer分配内存" class="headerlink" title="使用堆外内存为ByteBuffer分配内存"></a>使用堆外内存为ByteBuffer分配内存</h2><p>JDK接收请求的拷贝次数</p>
<ol>
<li><code>网卡</code> -&gt; <code>内核空间</code>, 使用DMA</li>
<li><code>内核空间</code> -&gt; <code>用户空间</code>, 系统调用触发</li>
<li><code>堆外内存</code> -&gt; <code>堆内存</code>, JVM拷贝</li>
</ol>
<p>Netty使用堆外内存的好处</p>
<ol>
<li>减少一次拷贝</li>
<li>手动引用计数维护内存可以减少FGC</li>
</ol>
<h1 id="Recycler对象池"><a href="#Recycler对象池" class="headerlink" title="Recycler对象池"></a>Recycler对象池</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Netty选择使用堆外内存存储网络通信数据</p>
<ol>
<li>在JVM堆中创建一个用于引用native memory的引用对象<code>DirectByteBuffer</code></li>
<li>使用native方法<code>unsafe.allocateMemory</code>通过底层<code>malloc</code>系统调用申请一块堆外内存, 然后被<code>DirectByteBuffer</code>引用</li>
</ol>
<p>Netty面对的高并发网络通信场景下, 申请堆外内存是一个非常频繁的操作, 这种大量频繁的内存申请释放操作对程序的性能影响是巨大的, 所以Netty就引入了内存池对内存相关的操作进行统一的管理</p>
<h2 id="对象在JVM中创建和回收开销"><a href="#对象在JVM中创建和回收开销" class="headerlink" title="对象在JVM中创建和回收开销"></a>对象在JVM中创建和回收开销</h2><p>略过</p>
<h2 id="对象池Recycler"><a href="#对象池Recycler" class="headerlink" title="对象池Recycler"></a>对象池Recycler</h2><p><img src="/../../../../image/netty7-1.png" alt="对象池接口"></p>
<p>Netty中每个被池化的对象中都会引用对象池的实例<code>RECYCLER</code></p>
<p>每个池化对象中都会包含一个<code>recyclerHandle</code>, 是池化对象在对象池中的句柄, 是由对象池在创建对象后传递进来的</p>
<ul>
<li>获取对象: <code>RECYCLER.get()</code></li>
<li>删除对象: <code>recyclerHandle.recycle(this)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Channel#write使用的缓存ChannelOutboundBuffer中保存的对象Entry</span></span><br><span class="line"><span class="comment">// 以Entry为例看一下如何使用对象池</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(handle -&gt; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(handle));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;Entry&gt; recyclerHandle;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Entry</span><span class="params">(Handle&lt;Entry&gt; recyclerHandle)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.recyclerHandle = recyclerHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请对象</span></span><br><span class="line">    <span class="keyword">static</span> Entry <span class="title function_">newInstance</span><span class="params">(Object msg, <span class="type">int</span> size, <span class="type">long</span> total, ChannelPromise promise)</span> &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> RECYCLER.get();</span><br><span class="line">        entry.msg = msg;</span><br><span class="line">        entry.pendingSize = size + CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD;</span><br><span class="line">        entry.total = total;</span><br><span class="line">        entry.promise = promise;</span><br><span class="line">        <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">        bufs = <span class="literal">null</span>;</span><br><span class="line">        buf = <span class="literal">null</span>;</span><br><span class="line">        msg = <span class="literal">null</span>;</span><br><span class="line">        promise = <span class="literal">null</span>;</span><br><span class="line">        progress = <span class="number">0</span>;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">        pendingSize = <span class="number">0</span>;</span><br><span class="line">        count = -<span class="number">1</span>;</span><br><span class="line">        cancelled = <span class="literal">false</span>;</span><br><span class="line">        handle.recycle(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Recycler总体设计"><a href="#Recycler总体设计" class="headerlink" title="Recycler总体设计"></a>Recycler总体设计</h2><p><img src="/../../../../image/netty7-2.png" alt="Recycler总体设计"></p>
<h3 id="获取对象无锁化设计"><a href="#获取对象无锁化设计" class="headerlink" title="获取对象无锁化设计"></a>获取对象无锁化设计</h3><p>每个线程拥有一个独立Stack, 这样当多个线程并发从对象池中获取对象时, 都是从自己线程中的Stack中获取, 全程无锁化运行, JVM的堆内存分配也是这样(TLAB), 但是JVM提供的堆外内存分配为了防止内存泄漏是全局加锁的(堆外不能自动GC)</p>
<h3 id="释放对象无锁化设计"><a href="#释放对象无锁化设计" class="headerlink" title="释放对象无锁化设计"></a>释放对象无锁化设计</h3><p>thread2释放thread1获取的对象, 就需要操作thread1的stack, 可能产生多线程冲突</p>
<p>引入<code>WeakOrderQueue</code>链表, 每个<code>WeakOrderQueue</code>表示一个其他线程回收的该线程的对象, 获取对象时取不到对象就去<code>WeakOrderQueue</code>取</p>
<p>对象池回收对象的一个原则就是对象由谁创建的, 最终就要被回收到创建线程对应的<code>Stack</code>结构中的数组栈中, 数组栈中存放的才是真正被回收的池化对象, 可以直接被取出复用, 回收线程只能将待回收对象暂时存放至创建线程对应的<code>Stack</code>结构中的<code>WeakOrderQueue</code>链表中, 当数组栈中没有对象时, 由创建线程将<code>WeakOrderQueue</code>链表中的待回收对象转移至数组栈中</p>
<p><code>WeakOrderQueue</code>链表, <code>创建线程</code>使用head指针获取可以被回收的对象, <code>回收线程</code>使用tail指针插入需要被回收的对象, Netty这里为了不引入多线程同步的开销, 只会保证待回收对象的最终可见性, 会存在线程可见性的问题(维护线程之间操作的原子性, 可见性都是需要开销的, netty为了提高多线程的运行效率, 避免引入不必要的同步开销)</p>
<h2 id="Recycler实现"><a href="#Recycler实现" class="headerlink" title="Recycler实现"></a>Recycler实现</h2><p>Handle是池化对象在对象池中的一个模型, 默认实现是DefaultHandle</p>
<p><code>stack</code>和<code>WeakOrderQueue</code>中存的就是handle</p>
<p>在创建对象池的时候, 需要通过<code>ObjectCreator#newObject</code>方法指定对象池创建对象的行为即<code>Handle</code></p>
<p><img src="/../../../../image/netty7-3.png" alt="创建ObjectPool"></p>
<h1 id="Netty发送数据流程"><a href="#Netty发送数据流程" class="headerlink" title="Netty发送数据流程"></a>Netty发送数据流程</h1><h2 id="write方法发送数据"><a href="#write方法发送数据" class="headerlink" title="write方法发送数据"></a>write方法发送数据</h2><p><img src="/../../../../image/netty8-1.png" alt="write事件传播流程"></p>
<ul>
<li><code>channelHandlerContext.write()</code>方法会从<code>当前ChannelHandler</code>开始在pipeline中向前传播write事件直到<code>HeadContext</code></li>
<li><code>channelHandlerContext.channel().write()</code>会从pipeline的尾结点<code>TailContext</code>开始在pipeline中向前传播write事件直到<code>HeadContext</code></li>
</ul>
<p>Netty的写操作是一个异步操作, 当我们在业务线程中调用<code>channelHandlerContext.write()</code>后, Netty会给我们返回一个<code>ChannelFuture</code>, 我们可以在这个<code>ChannelFutrue</code>中添加<code>ChannelFutureListener</code>, 这样要发送的数据发送到底层Socket中时, Netty会通过<code>ChannelFutureListener</code>通知我们写入结果</p>
<p>当异步事件在pipeline传播的过程中发生异常时就会停止传播。所以我们在日常开发中, 需要对写操作异常情况进行处理</p>
<h1 id="Pipeline-详解所有-IO-事件的触发时机以及传播路径"><a href="#Pipeline-详解所有-IO-事件的触发时机以及传播路径" class="headerlink" title="Pipeline, 详解所有 IO 事件的触发时机以及传播路径"></a>Pipeline, 详解所有 IO 事件的触发时机以及传播路径</h1><h1 id="Netty-如何处理-TCP-连接的正常关闭-异常关闭-半关闭场景"><a href="#Netty-如何处理-TCP-连接的正常关闭-异常关闭-半关闭场景" class="headerlink" title="Netty 如何处理 TCP 连接的正常关闭, 异常关闭, 半关闭场景"></a>Netty 如何处理 TCP 连接的正常关闭, 异常关闭, 半关闭场景</h1><hr>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483737&idx=1&sn=7ef3afbb54289c6e839eed724bb8a9d6">聊聊Netty那些事儿之从内核角度看IO模型</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483907&idx=1&sn=084c470a8fe6234c2c9461b5f713ff30">聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484005&idx=1&sn=52f51269902a58f40d33208421109bc3">详细图解Netty Reactor启动全流程</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484087&idx=1&sn=0c065780e0f05c23c8e6465ede86cba0">一文聊透Netty核心引擎Reactor的运转架构</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484184&idx=1&sn=726877ce28cf6e5d2ac3225fae687f19">抓到Netty一个Bug, 聊一下Netty是如何高效接收网络连接的</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484244&idx=1&sn=831060fc38caa201d69f87305de7f86a">Netty如何高效接收网络数据？ByteBuffer动态自适应扩缩容机制</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484419&idx=1&sn=3a75a495f0f117cca1548da1e0f3e6e6">抓到Netty一个内存泄露Bug | 详解Recycler对象池的设计与实现</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484532&idx=1&sn=c3a8b37a2eb09509d9914494ef108c68">Netty发送数据全流程</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484823&idx=1&sn=9396fb0f5dbac5e32d0fa1129d385fbc">Netty IO 事件的编排利器 pipeline | 所有 IO 事件的触发时机以及传播路径</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247485060&idx=1&sn=736360af6eb3a4db496de2d6665ebd3c">Netty 如何应对 TCP 连接的正常关闭, 异常关闭, 半关闭场景</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2022-05-13-HTTP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%B6%85%E9%99%90%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9EHTTP-body%20copy.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-05-13-HTTP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%B6%85%E9%99%90%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9EHTTP-body%20copy.html" class="post-title-link" itemprop="url">处理HTTP接口上传文件大小超限异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-13 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-13T00:00:00+08:00">2022-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-07 20:29:22" itemprop="dateModified" datetime="2022-07-07T20:29:22+08:00">2022-07-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

            <div class="post-description">从HTTP接口上传文件大小超限异常查起，发现了当前业务系统存在的许多问题</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一个上传文件的HTTP POST接口，传参使用form-data格式，后端Java服务使用<code>MultipartFile</code>接收，在上传大文件后接口返回nginx 413错误</p>
<p>测试环境浏览器的请求直接发到应用服务器，请求发到80端口后nginx根据不同前缀将请求转发到对应Java服务的监听端口</p>
<h1 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h1><h2 id="nginx限制"><a href="#nginx限制" class="headerlink" title="nginx限制"></a>nginx限制</h2><p>nginx限制请求的大小，配置<code>client_max_body_size</code>生效，判断HTTP请求的大小依据是header中的<code>Content-Length</code>值</p>
<ul>
<li>size &lt; client_body_buffer_size, 请求留在内存中</li>
<li>client_body_buffer_size &lt; size &lt; client_max_body_size, 请求保存在临时文件中</li>
<li>client_max_body_size &lt; size, 返回413 Request Entity Too Large错误</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/tinywan/2867647">Nginx系列 | [转]Nginx 上传文件：client_max_body_size 、client_body_buffer_size_Tinywan的技术博客_51CTO博客</a></p>
<p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size">Module ngx_http_core_module client_body_buffer_size</a></p>
<p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">Module ngx_http_core_module client_max_body_size</a></p>
<p>调大<code>client_max_body_size</code>值后，请求成功发送到后端服务，但是返回的response body为空</p>
<h2 id="文件过大抛出异常"><a href="#文件过大抛出异常" class="headerlink" title="文件过大抛出异常"></a>文件过大抛出异常</h2><p>查看后端服务日志，系统抛出了异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.multipart.MaxUploadSizeExceededException: Maximum upload size of 104857600 bytes exceeded; nested exception is org.apache.commons.fileupload.FileUploadBase$SizeLimitExceededException: the request was rejected because its size (113107647) exceeds the configured maximum (104857600)</span><br><span class="line">	at org.springframework.web.multipart.commons.CommonsMultipartResolver.parseRequest(CommonsMultipartResolver.java:162)</span><br><span class="line">	at org.springframework.web.multipart.commons.CommonsMultipartResolver$1.initializeMultipart(CommonsMultipartResolver.java:134)</span><br><span class="line">	at org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest.getMultipartFiles(AbstractMultipartHttpServletRequest.java:140)</span><br><span class="line">	at org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest.getFiles(AbstractMultipartHttpServletRequest.java:92)</span><br><span class="line">Caused by: org.apache.commons.fileupload.FileUploadBase$SizeLimitExceededException: the request was rejected because its size (113107647) exceeds the configured maximum (104857600)</span><br><span class="line">	at org.apache.commons.fileupload.FileUploadBase$FileItemIteratorImpl.&lt;init&gt;(FileUploadBase.java:968)</span><br><span class="line">	at org.apache.commons.fileupload.FileUploadBase.getItemIterator(FileUploadBase.java:310)</span><br><span class="line">	at org.apache.commons.fileupload.FileUploadBase.parseRequest(FileUploadBase.java:334)</span><br><span class="line">	at org.apache.commons.fileupload.servlet.ServletFileUpload.parseRequest(ServletFileUpload.java:115)</span><br><span class="line">	at org.springframework.web.multipart.commons.CommonsMultipartResolver.parseRequest(CommonsMultipartResolver.java:158)</span><br><span class="line">	... 50 common frames omitted</span><br></pre></td></tr></table></figure>

<p>可以看到，spring-web使用commons-fileupload包处理文件上传，限制文件大小<code>FileUploadBase</code>的<code>sizeMax</code>，参考类<code>CommonsFileUploadSupport</code>的相关初始化逻辑和<code>DispatcherServletAutoConfiguration.DispatcherServletConfiguration</code>的<code>multipartResolver</code>的注入逻辑，可以自定义一个MultipartResolver设置size限制并注入框架</p>
<p>本系统自定义一个<code>multipartResolver</code>并<code>setMaxUploadSize(100 * 1024 * 1024)</code>，限制文件最大100M，文件过大就会抛出上面的<code>MaxUploadSizeExceededException</code>和<code>FileUploadBase$SizeLimitExceededException</code></p>
<p>因此我在自定义的<code>GlobalExceptionResolver</code>中加入对这两个exception的处理，打印日志并返回错误信息</p>
<p>上传大文件后在<strong>测试</strong>环境进行测试，该异常被捕获并执行了处理逻辑，但是前端收到的response依然没有HTTP body。奇怪的是，使用postman请求<strong>本地</strong>的后端服务可以正常返回错误信息</p>
<h2 id="跟踪写HTTP-response的过程"><a href="#跟踪写HTTP-response的过程" class="headerlink" title="跟踪写HTTP response的过程"></a>跟踪写HTTP response的过程</h2><p>初步排查思路是跟踪spring-web把对象写到http body中的过程，查找是哪一步出了问题</p>
<p>debug排查发现，我们在<code>DispatcherServlet</code>中处理的<code>HttpServletRequest request</code>实体是tomcat的<code>RequestFacade</code>，使用facade外观模式，核心是<code>org.apache.catalina.connector.Request request</code>的<code>org.apache.coyote.Request coyoteRequest</code></p>
<p>将对象写入http body的json序列化流程正常，但是我注意到本地环境的response header有一项<code>Transfer-Encoding: chunked</code>，测试环境的response header中没有这一项而多了<code>Connection: close</code>。body的写入使用outputStream，导致本地调试无法看到body值，header中的这个区别有可能就是导致测试环境异常的原因，因此我们开始检查是哪一步设置的connection&#x3D;close</p>
<p>跟踪调用栈：</p>
<ul>
<li>DispatcherServlet.doService()</li>
<li>DispatcherServlet.doDispatch()</li>
<li>DispatcherServlet.processDispatchResult()</li>
<li>DispatcherServlet.render()</li>
<li>AbstractView.render()</li>
<li>AbstractJackson2View.renderMergedOutputModel(), 从这里开始就是单纯的对象序列化为json字符串</li>
<li>AbstractJackson2View.writeContent()</li>
<li>com.fasterxml.jackson.databind.ObjectMapper.writeValue()</li>
<li>DefaultSerializerProvider.serializeValue()</li>
<li>DefaultSerializerProvider._serialize()</li>
<li>serialize()</li>
</ul>
<p>但是流程中观察到的对body流的写入都是正常的，各种字段类型的序列化也都使用了正确的序列化类，也没有找到设置connection的逻辑</p>
<h2 id="监测HTTP-header的写操作"><a href="#监测HTTP-header的写操作" class="headerlink" title="监测HTTP header的写操作"></a>监测HTTP header的写操作</h2><p>从序列化流程开始逐步跟踪没有找到修改时机，我们改为监控所有修改response header操作，找到目标后再根据调用栈查看修改操作的调用方</p>
<p>response header最终保存在<code>org.apache.coyote.Request coyoteRequest</code>的<code>headers</code>字段中，所以我们在<code>MimeHeaders</code>类的<code>addValue()</code>和<code>setValue()</code>中打断点观察，最终发现是tomcat的<code>Http11Processor</code>在返回response前对消息体进行了统一修改，以符合各种RFC协议的要求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When committing the response, we have to validate the set of headers, as well as setup the response filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">entityBody</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    contentDelimitation = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    OutputFilter[] outputFilters = outputBuffer.getFilters();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http09 == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// HTTP/0.9</span></span><br><span class="line">        outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]);</span><br><span class="line">        outputBuffer.commit();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> response.getStatus();</span><br><span class="line">    <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode == <span class="number">204</span> || statusCode == <span class="number">205</span> ||</span><br><span class="line">            statusCode == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="comment">// No entity body</span></span><br><span class="line">        outputBuffer.addActiveFilter</span><br><span class="line">            (outputFilters[Constants.VOID_FILTER]);</span><br><span class="line">        entityBody = <span class="literal">false</span>;</span><br><span class="line">        contentDelimitation = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="number">205</span>) &#123;</span><br><span class="line">            <span class="comment">// RFC 7231 requires the server to explicitly signal an empty response in this case</span></span><br><span class="line">            response.setContentLength(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setContentLength(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for compression</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isCompressible</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">useCompression</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (entityBody &amp;&amp; (compressionLevel &gt; <span class="number">0</span>) &amp;&amp; sendfileData == <span class="literal">null</span>) &#123;</span><br><span class="line">        isCompressible = isCompressible();</span><br><span class="line">        <span class="keyword">if</span> (isCompressible) &#123;</span><br><span class="line">            useCompression = useCompression();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Change content-length to -1 to force chunking</span></span><br><span class="line">        <span class="keyword">if</span> (useCompression) &#123;</span><br><span class="line">            response.setContentLength(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">MimeHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> response.getMimeHeaders();</span><br><span class="line">    <span class="comment">// A SC_NO_CONTENT response may include entity headers</span></span><br><span class="line">    <span class="keyword">if</span> (entityBody || statusCode == HttpServletResponse.SC_NO_CONTENT) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> response.getContentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">            headers.setValue(<span class="string">&quot;Content-Type&quot;</span>).setString(contentType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentLanguage</span> <span class="operator">=</span> response.getContentLanguage();</span><br><span class="line">        <span class="keyword">if</span> (contentLanguage != <span class="literal">null</span>) &#123;</span><br><span class="line">            headers.setValue(<span class="string">&quot;Content-Language&quot;</span>)</span><br><span class="line">                .setString(contentLanguage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add date header unless application has already set one (e.g. in a Caching Filter)</span></span><br><span class="line">    <span class="keyword">if</span> (headers.getValue(<span class="string">&quot;Date&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        headers.addValue(<span class="string">&quot;Date&quot;</span>).setString(</span><br><span class="line">                FastHttpDateFormat.getCurrentDate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entityBody) &amp;&amp; (!contentDelimitation)) &#123;</span><br><span class="line">        <span class="comment">// Mark as close the connection after the request, and add the connection: close header</span></span><br><span class="line">        keepAlive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This may disabled keep-alive to check before working out the Connection header.</span></span><br><span class="line">    checkExpectationAndResponseStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know that the request is bad this early, add the Connection: close header.</span></span><br><span class="line">    <span class="keyword">if</span> (keepAlive &amp;&amp; statusDropsConnection(statusCode)) &#123;</span><br><span class="line">        keepAlive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!keepAlive) &#123;</span><br><span class="line">        <span class="comment">// Avoid adding the close header twice</span></span><br><span class="line">        <span class="keyword">if</span> (!connectionClosePresent) &#123;</span><br><span class="line">            headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!http11 &amp;&amp; !getErrorState().isError()) &#123;</span><br><span class="line">        headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outputBuffer.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么本地环境和测试环境的区别在哪里呢？在最后判断Connection为close还是keep-alive的时候，processor根据请求的http版本执行不同操作，本地环境读到的是HTTP1.1，而测试环境读到的是HTTP1.0，就设置为了close。在浏览器的控制台-network中看到的protocol明明是h2，为什么后端服务读取到的是1.0呢？</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/321943562">浏览器发起http请求时候，如何知道服务器支持什么http 版本？ - 知乎</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000010612052">HTTP的版本是什么决定的，浏览器，服务器？ - SegmentFault 思否</a></p>
<p>越过nginx直接指定端口请求测试环境的服务，正常返回response body，因此判断是浏览器客户端和服务器协商HTTP版本时由于nginx限制没有成功使用</p>
<p>nginx增加配置项<code>proxy_http_version 1.1;</code>后，测试环境接口返回成功</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在找到了设置header的代码后再看下之前为什么debug没有跟踪到，设置header的调用栈：</p>
<ul>
<li>UTF8JsonGenerator.flush()</li>
<li>CoyoteOutputStream.flush()</li>
<li>org.apache.catalina.connector.OutputBuffer.flush()</li>
<li>OutputBuffer.doFlush()</li>
<li>org.apache.coyote.Response.sendHeaders()</li>
<li>Response.action(), 这里的hook是<code>Http11Processor</code></li>
<li>AbstractProcessor.prepareResponse()</li>
<li>Http11Processor.prepareResponse()</li>
</ul>
<p>谁能想到名为<code>OutputStream</code>和<code>OutputBuffer</code>的类的flush方法竟然会执行这么多业务操作呢:(</p>
<p>POSTMAN不支持指定HTTP1.0，有这个需求可以导出curl指令后使用curl实现，增加<code>-0</code>参数</p>
<p><a target="_blank" rel="noopener" href="https://community.postman.com/t/how-to-change-http-protocol-version-to-http-1-0/3963">How to change HTTP protocol version to HTTP 1.0 - Help - Postman</a></p>
<p>在网上看到其他人遇到的相似问题</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38531706/article/details/117448200">Nginx proxy_http_version默认值引发的问题__alone_的博客-CSDN博客_proxy_http_version</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" class="post-title-link" itemprop="url">《凤凰架构》读书摘要</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-14T00:00:00+08:00">2022-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-13 10:46:06" itemprop="dateModified" datetime="2022-05-13T10:46:06+08:00">2022-05-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

            <div class="post-description">周志明的关于构建一个大规模但依然可靠的软件系统的架构讨论与代码实践</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://icyfenix.cn/summary/">原文链接</a></p>
<h1 id="服务架构演进史"><a href="#服务架构演进史" class="headerlink" title="服务架构演进史"></a>服务架构演进史</h1><h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><blockquote>
<p>UNIX 的分布式设计哲学 保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要</p>
</blockquote>
<p>在 20 世纪 70 年代末期到 80 年代初，计算机科学刚经历了从以大型机为主向以微型机为主的蜕变，当时计算机硬件局促的运算处理能力，已直接妨碍到了在单台计算机上信息系统软件能够达到的最大规模</p>
<p>某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果</p>
<p>20 世纪 80 年代正是摩尔定律开始稳定发挥作用的黄金时期，信息系统进入了以单台或少量几台计算机即可作为服务器来支撑大型信息系统运作的单体时代</p>
<h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><blockquote>
<p>单体架构（Monolithic） “单体”只是表明系统中主要的过程调用都是进程内调用，不会发生进程间通信，仅此而已</p>
</blockquote>
<p>对于小型系统——即由单台机器就足以支撑其良好运行的系统，单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信（Inter-Process Communication，IPC），因此也是运行效率最高的一种架构风格</p>
<p><strong>优点</strong></p>
<ul>
<li><p>易于开发、易于测试、易于部署</p>
</li>
<li><p>由于所有代码都运行在同一个进程空间之内，所有模块、方法的调用都无须考虑网络分区、对象复制这些麻烦的事和性能损失</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>如果任何一部分代码出现了缺陷，过度消耗了进程空间内的资源，所造成的影响也是全局性的、难以隔离的。譬如内存泄漏、线程爆炸、阻塞、死循环等问题，都将会影响整个程序，而不仅仅是影响某一个功能、模块本身的正常运作。如果消耗的是某些更高层次的公共资源，譬如端口号或者数据库连接池泄漏，影响还将会波及整台机器，甚至是集群中其他单体副本的正常工作</p>
</li>
<li><p>由于所有代码都共享着同一个进程空间，不能隔离，也就无法（其实还是有办法的，譬如使用 OSGi 这种运行时模块化框架，但是很别扭、很复杂）做到单独停止、更新、升级某一部分代码，所以从可维护性来说，单体系统也是不占优势的</p>
</li>
<li><p>难以技术异构，每个模块的代码都通常需要使用一样的程序语言，乃至一样的编程框架去开发。单体系统的技术栈异构并非一定做不到，譬如 JNI 就可以让 Java 混用 C 或 C++，但这通常是迫不得已的，并不是优雅的选择</p>
</li>
<li><p>单体系统很难兼容“Phoenix”的特性。这种架构风格潜在的观念是希望系统的每一个部件，每一处代码都尽量可靠，靠不出或少出缺陷来构建可靠系统。然而战术层面再优秀，也很难弥补战略层面的不足，单体靠高质量来保证高可靠性的思路，在小规模软件上还能运作良好，但系统规模越大，交付一个可靠的单体系统就变得越来越具有挑战性</p>
</li>
</ul>
<h2 id="SOA时代"><a href="#SOA时代" class="headerlink" title="SOA时代"></a>SOA时代</h2><blockquote>
<p>SOA 架构（Service-Oriented Architecture） 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式</p>
</blockquote>
<ol>
<li>烟囱式架构, 完全不与其他相关信息系统进行互操作或者协调工作的设计模式</li>
<li>微内核架构（Microkernel Architecture）：也被称为插件式架构（Plug-in Architecture）将主数据，连同其他可能被各子系统使用到的公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心（Kernel），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样可提供可扩展的、灵活的、天然隔离的功能特性</li>
<li>事件驱动架构（Event-Driven Architecture）：在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去，如此，每一个消息的处理者都是独立的，高度解耦的，但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动</li>
</ol>
<ul>
<li>领导制定技术标准的组织 Open CSA</li>
<li>明确了采用 SOAP 作为远程调用的协议，依靠 SOAP 协议族（WSDL、UDDI 和一大票 WS-*协议）来完成服务的发布、发现和治理</li>
<li>利用一个被称为企业服务总线（的消息管道来实现各个子系统之间的通信交互</li>
<li>使用服务数据对象来访问和表示数据</li>
<li>使用服务组件架构来定义服务封装的形式和服务运行的容器</li>
</ul>
<p><strong>缺点</strong></p>
<p>过于严格的规范定义带来过度的复杂性。而构建在 SOAP 基础之上的 ESB、BPM、SCA、SDO 等诸多上层建筑，进一步加剧了这种复杂性</p>
<h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><blockquote>
<p>微服务架构（Microservices）<br>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</p>
</blockquote>
<p>微服务追求的是更加自由的架构风格，摒弃了几乎所有 SOA 里可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”</p>
<h2 id="后微服务时代"><a href="#后微服务时代" class="headerlink" title="后微服务时代"></a>后微服务时代</h2><blockquote>
<p>后微服务时代（Cloud Native）<br>从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”</p>
</blockquote>
<p>以 Docker Swarm、Apache Mesos 与 Kubernetes 为主要竞争者的“容器编排战争”终于有了明确的结果，Kubernetes 登基加冕是容器发展中一个时代的终章，也将是软件架构发展下一个纪元的开端</p>
<p>传统 Spring Cloud 与 Kubernetes 提供的解决方案对比</p>
<table>
<thead>
<tr>
<th>Kubernetes</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>弹性伸缩</td>
<td>Autoscaling N&#x2F;A</td>
</tr>
<tr>
<td>服务发现</td>
<td>KubeDNS, CoreDNS Spring Cloud Eureka</td>
</tr>
<tr>
<td>配置中心</td>
<td>ConfigMap, Secret Spring Cloud Config</td>
</tr>
<tr>
<td>服务网关</td>
<td>Ingress Controller Spring Cloud Zuul</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Load Balancer Spring Cloud Ribbon</td>
</tr>
<tr>
<td>服务安全</td>
<td>RBAC API Spring Cloud Security</td>
</tr>
<tr>
<td>跟踪监控</td>
<td>Metrics API, Dashboard Spring Cloud Turbine</td>
</tr>
<tr>
<td>降级熔断</td>
<td>N&#x2F;A Spring Cloud Hystrix</td>
</tr>
</tbody></table>
<p>仅从功能上看，单纯的 Kubernetes 反而不如之前的 Spring Cloud 方案。这是因为有一些问题处于应用系统与基础设施的边缘，使得完全在基础设施层面中确实很难精细化地处理。通过 Spring Cloud 这类应用代码实现的微服务中并不难处理，既然是使用程序代码来解决问题，只要合乎逻辑，想要实现什么功能，只受限于开发人员的想象力与技术能力，但基础设施是针对整个容器来管理的，粒度相对粗旷，只能到容器层面，对单个远程服务就很难有效管控</p>
<p>为了解决这一类问题，虚拟化的基础设施很快完成了第二次进化，引入了今天被称为“服务网格”（Service Mesh）的“边车代理模式”（Sidecar Proxy）</p>
<p>由系统自动在服务容器（通常是指 Kubernetes 的 Pod）中注入一个通信代理服务器，以类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理</p>
<h2 id="无服务时代"><a href="#无服务时代" class="headerlink" title="无服务时代"></a>无服务时代</h2><blockquote>
<p>无服务架构（Serverless）如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布式”的云端系统这条路的起点</p>
</blockquote>
<p>只涉及两块内容：后端设施（Backend）和函数（Function）</p>
<ul>
<li>后端设施是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，无服务中称其为“后端即服务”（Backend as a Service，BaaS）</li>
<li>函数是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，不必考虑容量规划（从技术角度可以不考虑，从计费的角度你的钱包够不够用还是要掂量一下的），无服务中称其为“函数即服务”（Function as a Service，FaaS）</li>
</ul>
<p>无服务架构对一些适合的应用确实能够降低开发和运维环节的成本，譬如不需要交互的离线大规模计算，又譬如多数 Web 资讯类网站、小程序、公共 API 服务、移动应用服务端等都契合于无服务架构所擅长的短链接、无状态、适合事件驱动的交互形式；但另一方面，对于那些信息管理系统、网络游戏等应用，又或者说所有具有业务逻辑复杂，依赖服务端状态，响应速度要求较高，需要长链接等这些特征的应用，至少目前是相对并不适合的</p>
<p>顺序上笔者将“无服务”安排到了“微服务”和“云原生”时代之后，但它们两者并没有继承替代关系，笔者相信软件开发的未来不会只存在某一种“最先进的”架构风格，多种具针对性的架构风格同时并存，是软件产业更有生命力的形态</p>
<h1 id="架构师的视角"><a href="#架构师的视角" class="headerlink" title="架构师的视角"></a>架构师的视角</h1><h2 id="访问远程服务"><a href="#访问远程服务" class="headerlink" title="访问远程服务"></a>访问远程服务</h2><h3 id="远程服务调用"><a href="#远程服务调用" class="headerlink" title="远程服务调用"></a>远程服务调用</h3><h4 id="调用本地方法"><a href="#调用本地方法" class="headerlink" title="调用本地方法"></a>调用本地方法</h4><ol>
<li>传递方法参数</li>
<li>确定方法版本</li>
<li>执行被调方法</li>
<li>返回执行结果</li>
</ol>
<p>1&#x2F;4依赖栈内存, 2依赖程序语言定义</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ol>
<li>管道, 在进程间传递少量的字符流或字节流</li>
<li>信号, 通知目标进程有某种事件发生, kill即shell向进程发送信号</li>
<li>信号量, wait() notify()</li>
<li>共享内存</li>
<li>Socket, 支持远程</li>
</ol>
<h4 id="分布式计算的八宗罪"><a href="#分布式计算的八宗罪" class="headerlink" title="分布式计算的八宗罪"></a>分布式计算的八宗罪</h4><ol>
<li>The network is reliable —— 网络是可靠的</li>
<li>Latency is zero —— 延迟是不存在的</li>
<li>Bandwidth is infinite —— 带宽是无限的</li>
<li>The network is secure —— 网络是安全的</li>
<li>Topology doesn’t change —— 拓扑结构是一成不变的</li>
<li>There is one administrator —— 总会有一个管理员</li>
<li>Transport cost is zero —— 不必考虑传输成本</li>
<li>The network is homogeneous —— 网络是同质化的</li>
</ol>
<h4 id="RPC的三个基本问题"><a href="#RPC的三个基本问题" class="headerlink" title="RPC的三个基本问题"></a>RPC的三个基本问题</h4><ol>
<li>如何表示数据, 各种协议</li>
<li>如何传递数据, 除了传输层的UDP&#x2F;TCP, 还包括应用层的wire protocal, 异常、超时、安全、认证、授权、事务等</li>
<li>如何确定方法</li>
</ol>
<h4 id="RPC的发展方向"><a href="#RPC的发展方向" class="headerlink" title="RPC的发展方向"></a>RPC的发展方向</h4><ol>
<li>面向对象, 不满足于 RPC 将面向过程的编码方式带到分布式，希望在分布式系统中也能够进行跨进程的面向对象编程，代表为 RMI、.NET Remoting</li>
<li>性能, 代表为 gRPC 和 Thrift, 决定 RPC 性能的主要就两个因素：序列化效率和信息密度。序列化效率很好理解，序列化输出结果的容量越小，速度越快，效率自然越高；信息密度则取决于协议中有效荷载（Payload）所占总传输数据的比例大小，使用传输协议的层次越高，信息密度就越低，SOAP 使用 XML 拙劣的性能表现就是前车之鉴。gRPC 和 Thrift 都有自己优秀的专有序列化器，而传输协议方面，gRPC 是基于 HTTP&#x2F;2 的，支持多路复用和 Header 压缩，Thrift 则直接基于传输层的 TCP 协议来实现，省去了额外应用层协议的开销</li>
<li>简化, 代表为 JSON-RPC</li>
</ol>
<h3 id="REST-设计风格"><a href="#REST-设计风格" class="headerlink" title="REST 设计风格"></a>REST 设计风格</h3><p>表征状态转移</p>
<ul>
<li>面向过程编程时，为什么要以算法和处理过程为中心，输入数据，输出结果？是为了符合计算机世界中主流的交互方式</li>
<li>面向对象编程时，为什么要将数据和行为统一起来、封装成对象？是为了符合现实世界的主流的交互方式</li>
<li>面向资源编程时，为什么要将数据（资源）作为抽象的主体，把行为看作是统一的接口？是为了符合网络世界的主流的交互方式</li>
</ul>
<h4 id="REST六大原则"><a href="#REST六大原则" class="headerlink" title="REST六大原则"></a>REST六大原则</h4><ul>
<li>服务端与客户端分离</li>
<li>无状态</li>
<li>可缓存</li>
<li>分层系统</li>
<li>统一接口</li>
<li>按需代码</li>
</ul>
<h4 id="REST好处"><a href="#REST好处" class="headerlink" title="REST好处"></a>REST好处</h4><ol>
<li>降低的服务接口的学习成本</li>
<li>资源天然具有集合与层次结构</li>
<li>REST 绑定于 HTTP 协议</li>
</ol>
<h4 id="REST缺点"><a href="#REST缺点" class="headerlink" title="REST缺点"></a>REST缺点</h4><ol>
<li>REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中</li>
<li>REST 没有传输可靠性支持</li>
<li>REST 缺乏对资源进行“部分”和“批量”的处理能力</li>
</ol>
<p>一种理论上较优秀的可以解决以上这几类问题的方案是GraphQL，这是由 Facebook 提出并开源的一种面向资源 API 的数据查询语言。比起依赖 HTTP 无协议的 REST，GraphQL 可以说是另一种“有协议”的、更彻底地面向资源的服务方式。然而凡事都有两面，离开了 HTTP，它又面临着几乎所有 RPC 框架所遇到的那个如何推广交互接口的问题。</p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul>
<li>一致性（Consistency）系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾</li>
<li>原子性（Atomic）在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销</li>
<li>隔离性（Isolation）在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响</li>
<li>持久性（Durability）事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据</li>
</ul>
<p>A、I、D 是手段，C 是目的</p>
<p>当一个服务只使用一个数据源时，通过 A、I、D 来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为__内部一致性__</p>
<p>当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，问题就变得相对困难了许多。此时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为__外部一致性__</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>直接依赖于数据源本身提供的事务能力来工作的，在程序代码层面，最多只能对事务接口做一层标准化的包装（如 JDBC 接口），与后续介绍的 XA、TCC、SAGA 等主要靠应用程序代码来实现的事务有着十分明显的区别</p>
<h4 id="实现原子性和隔离性"><a href="#实现原子性和隔离性" class="headerlink" title="实现原子性和隔离性"></a>实现原子性和隔离性</h4><p>写入中间状态与崩溃都不可能消除，所以如果不做额外保障措施的话，将内存中的数据写入磁盘，并不能保证原子性与持久性</p>
<p>使用 <strong>Commit Logging</strong> 实现</p>
<p>Commit Logging基于ARIES理论</p>
<p>将修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等，以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化</p>
<p>Write-Ahead Logging, 当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除</p>
<h4 id="实现隔离性"><a href="#实现隔离性" class="headerlink" title="实现隔离性"></a>实现隔离性</h4><p>现代数据库均提供了以下三种锁</p>
<ul>
<li>写锁（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）</li>
<li>读锁（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）</li>
<li>范围锁（Range Lock）, 在MySQL中实现为gap lock</li>
</ul>
<p>四个隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>使用的锁</th>
<th>存在问题</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交(Read Uncommitted)</td>
<td>写锁持续至事务结束,无读锁</td>
<td>脏读:在事务执行过程中,一个事务读取到了另一个事务未提交的数据(读数据不需要加读锁,写锁就限制不了读操作了)</td>
</tr>
<tr>
<td>读已提交(Read Committed)</td>
<td>写锁持续至事务结束,读锁在操作完成后马上释放</td>
<td>不可重复读:在事务执行过程中,对同一行数据的两次查询得到了不同的结果,即读到了另一个事务已提交的数据(写锁释放太早,限制不到其他事务加读锁)</td>
</tr>
<tr>
<td>可重复读(Repeatable Read)</td>
<td>写锁、读锁持续至事务结束</td>
<td>幻读:在事务执行过程中,两个完全相同的范围查询得到了不同的结果集,没有范围锁来禁止在该范围内插入新的数据</td>
</tr>
<tr>
<td>可串行化(Serializable)</td>
<td>写锁、读锁、范围所持续至事务结束</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h4><p>幻读、不可重复读、脏读等问题都是由于一个事务在读数据过程中，受另外一个写数据的事务影响而破坏了隔离性，针对这种“一个事务读+另一个事务写”的隔离问题，近年来有一种名为“多版本并发控制”（Multi-Version Concurrency Control，MVCC）的无锁优化方案被主流的商业数据库广泛采用。MVCC 是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的</p>
<h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><p>单个服务使用多个数据源场景</p>
<p>X&#x2F;Open组织（后来并入了The Open Group）提出了一套名为X&#x2F;Open XA（XA 是 eXtended Architecture 的缩写）的处理事务架构，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口</p>
<p>Java 中专门定义了JSR 907 Java Transaction API，基于 XA 模式在 Java 语言中的实现了全局事务处理的标准，这也就是我们现在所熟知的 JTA。JTA 最主要的两个接口是：</p>
<ol>
<li>事务管理器的接口：javax.transaction.TransactionManager。这套接口是给 Java EE 服务器提供容器事务（由容器自动负责事务管理）使用的，还提供了另外一套javax.transaction.UserTransaction接口，用于通过程序代码手动开启、提交和回滚事务。</li>
<li>满足 XA 规范的资源定义接口：javax.transaction.xa.XAResource，任何资源（JDBC、JMS 等等）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可</li>
</ol>
<h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>XA 将事务提交拆分成为两阶段过程，“两段式提交”（2 Phase Commit，2PC）协议，协调者、参与者都是可以由数据库自己来扮演的，不需要应用程序介入。协调者一般是在参与者之间选举产生的，而应用程序相对于数据库来说只扮演客户端的角色</p>
<ol>
<li><p>准备阶段：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态</p>
</li>
<li><p>提交阶段：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作</p>
</li>
</ol>
<p>2PC的前提条件: </p>
<ol>
<li><p>必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息</p>
</li>
<li><p>必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态，当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，并向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作</p>
</li>
</ol>
<p>2PC的缺点:</p>
<ol>
<li><p>单点问题：协调者</p>
</li>
<li><p>性能问题：要经过两次远程服务调用，三次数据持久化</p>
</li>
<li><p>一致性风险：需要前提条件</p>
</li>
</ol>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ol>
<li>canCommit，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成</li>
<li>preCommit</li>
<li>doCommit，未收到协调者返回，参与者默认的操作策略将是提交事务</li>
</ol>
<p>将2PC的prepare阶段分成两部分，增加了评估阶段，在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的，但在事务能够正常提交的场景中，两者的性能都依然很差，甚至三段式因为多了一次询问，还要稍微更差一些</p>
<p>缺点：单点问题、性能问题优于2PC，一致性风险大于2PC</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>多个服务同时访问多个数据源</p>
<h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>一个分布式的系统中，涉及共享数据问题时，以下三个特性最多只能同时满足其中两个：</p>
<ol>
<li><p>一致性（Consistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的</p>
</li>
<li><p>可用性（Availability）：代表系统不间断地提供服务的能力，可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A&#x3D;MTBF&#x2F;（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999%可用，即代表平均年故障修复时间为 32 秒</p>
</li>
<li><p>分区容忍性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力</p>
</li>
</ol>
<p>CAP舍弃其中一个:</p>
<ol>
<li><p>CA，不追求分区容忍性即认为节点之间通信永远可靠，不是分布式系统</p>
</li>
<li><p>CP，网络分区后服务不可用，退化为全局事务，使用2PC&#x2F;3PC，用于对数据要求很高的系统，HBase</p>
</li>
<li><p>AP，网络分区后服务可用但不同实例返回的数据可能不同，大部分nosql系统和分布式缓存</p>
</li>
</ol>
<h4 id="可靠事件队列-BASE"><a href="#可靠事件队列-BASE" class="headerlink" title="可靠事件队列 BASE"></a>可靠事件队列 BASE</h4><h4 id="TCC-事务"><a href="#TCC-事务" class="headerlink" title="TCC 事务"></a>TCC 事务</h4><h4 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h4><h2 id="透明多级分流系统"><a href="#透明多级分流系统" class="headerlink" title="透明多级分流系统"></a>透明多级分流系统</h2><p>系统中不同的组件:</p>
<ul>
<li>有一些部件位于客户端或网络的边缘，能够迅速响应用户的请求，避免给后方的 I&#x2F;O 与 CPU 带来压力，典型如本地缓存、内容分发网络、反向代理等。</li>
<li>有一些部件的处理能力能够线性拓展，易于伸缩，可以使用较小的代价堆叠机器来获得与用户数量相匹配的并发性能，应尽量作为业务逻辑的主要载体，典型如集群中能够自动扩缩的服务节点。</li>
<li>有一些部件稳定服务对系统运行有全局性的影响，要时刻保持着容错备份，维护着高可用性，典型如服务注册中心、配置中心。</li>
<li>有一些设施是天生的单点部件，只能依靠升级机器本身的网络、存储和运算性能来提升处理能力，如位于系统入口的路由、网关或者负载均衡器（它们都可以做集群，但一次网络请求中无可避免至少有一个是单点的部件）、位于请求调用链末端的传统关系数据库等</li>
</ul>
<p>两条原则:</p>
<ol>
<li><p>尽可能减少单点部件</p>
</li>
<li><p>奥卡姆剃刀原则</p>
</li>
</ol>
<p>几种优化:</p>
<ul>
<li>客户端缓存</li>
<li>域名解析</li>
<li>传输链路</li>
<li>内容分发网络</li>
<li>负载均衡</li>
<li><a target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cache-middleware.html">服务端缓存</a>, 介绍了传统意义上缓存的各个方面</li>
</ul>
<h2 id="架构安全性"><a href="#架构安全性" class="headerlink" title="架构安全性"></a>架构安全性</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><ul>
<li>RBAC, user&#x2F;role&#x2F;authority&#x2F;permission&#x2F;resource</li>
<li>OAuth2, 解决第三方应用的认证授权协议</li>
</ul>
<h3 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h3><ul>
<li>Cookie-Session, 受制于CAP理论</li>
<li>JWT, header+payload+sign</li>
</ul>
<h3 id="保密"><a href="#保密" class="headerlink" title="保密"></a>保密</h3><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h1 id="分布式的基石"><a href="#分布式的基石" class="headerlink" title="分布式的基石"></a>分布式的基石</h1><h2 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>Multi Paxos 对 Basic Paxos 的核心改进是增加了“选主”的过程</p>
<p>Raft 算法: 分布式系统中如何对某个值达成一致</p>
<ol>
<li>如何选主（Leader Election）</li>
<li>如何把数据复制到各个节点上（Entity Replication）</li>
<li>如何保证过程是安全的（Safety）</li>
</ol>
<p>Raft 是 Etcd、LogCabin、Consul 等重要分布式程序的实现基础, ZooKeeper 的 ZAB 算法与 Raft 的思路也非常类似，这些算法都被认为是 Multi Paxos 的等价派生实现。</p>
<h3 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h3><ul>
<li>强一致性, 尽管系统内部节点可以存在不一致的状态，但从系统外部看来不一致的情况并不会被观察到，所以整体上看系统是强一致性的, Paxos、Raft、ZAB</li>
<li>最终一致性, 系统中不一致的状态有可能会在一定时间内被外部直接观察到, DNS, Gossip</li>
</ul>
<h2 id="从类库到服务"><a href="#从类库到服务" class="headerlink" title="从类库到服务"></a>从类库到服务</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>实现</p>
<ol>
<li>全限定名(定位到主机)</li>
<li>端口号(tcp&#x2F;udp服务)</li>
<li>服务标识(具体接口)</li>
</ol>
<p>功能</p>
<ol>
<li>服务注册</li>
<li>服务维护</li>
<li>服务发现</li>
</ol>
<p>服务注册中心一旦崩溃，整个系统都不再可用，因此必须尽最大努力保证服务发现的可用性</p>
<p>CAP矛盾</p>
<ul>
<li>Eureka，AP，客户端拿到了已经发生变动的错误地址依赖故障转移（Failover）或者快速失败（Failfast）</li>
<li>Consul，CP</li>
</ul>
<p>选择AP&#x2F;CP</p>
<blockquote>
<p>假设系统形成了 A、B 两个网络分区后，A 区的服务只能从区域内的服务发现节点获取到 A 区的服务坐标，B 区的服务只能取到在 B 区的服务坐标，这对你的系统会有什么影响？</p>
</blockquote>
<ul>
<li>没有影响，AP</li>
<li>影响非常之大，甚至可能带来比整个系统宕机更坏的结果，CP</li>
</ul>
<p>实现方式</p>
<ul>
<li>在分布式 K&#x2F;V 存储框架上自己开发, ZooKeeper(CP), Etcd(CP), Redis(AP)</li>
<li>以基础设施（主要是指 DNS 服务器）来实现服务发现, SkyDNS、CoreDNS, AP&#x2F;CP取决于怎样实现</li>
<li>专门用于服务发现的框架和工具, Eureka(AP)、Consul(CP) 和 Nacos(AP&#x2F;CP)</li>
</ul>
<h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><p>网关 &#x3D; 路由器（基础职能） + 过滤器（可选职能）</p>
<p>网关是网络访问中的单点, 地址具有唯一性不能像服务中心一样做集群</p>
<h4 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h4><p>[以买饭为例]</p>
<ul>
<li>同步IO(Synchronous I&#x2F;O)<ul>
<li>阻塞IO(Blocking I&#x2F;O), 节省 CPU 资源(Java传统IO模型)</li>
<li>非阻塞IO(Non-Blocking I&#x2F;O), 浪费 CPU 资源(Java的NIO)</li>
<li>多路复用IO(Multiplexing I&#x2F;O), 主流(通过NIO实现的Reactor模式)</li>
<li>信号驱动IO(Signal-Driven I&#x2F;O), 需要自己从缓冲区获取数据</li>
</ul>
</li>
<li>异步IO(Asynchronous I&#x2F;O)(通过AIO实现的Proactor模式)</li>
</ul>
<h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p>请求的完整路径</p>
<ol>
<li>服务发现</li>
<li>网关路由</li>
<li>负载均衡</li>
<li>服务容错</li>
</ol>
<p>客户端指集群内部发起服务的进程</p>
<ul>
<li>Java, Netflix Ribbon, Spring Cloud Load Balancer</li>
<li>其他, 代理均衡器</li>
</ul>
<h2 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h2><p>服务降级</p>
<ul>
<li>出错后弥补</li>
<li>主动降级</li>
</ul>
<h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><p>失败如何弥补</p>
<ul>
<li>故障转移, 重试, 服务具备幂等性, 如果调用的服务器出现故障, 自动切换到其他副本</li>
<li>快速失败, 非幂等的服务, 拒绝重试, 抛出异常</li>
<li>安全失败, 不影响核心业务的旁路逻辑失败的话返回默认值</li>
<li>沉默失败, 当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响</li>
<li>故障恢复, 异步的故障转移<br>调用之前尽量获得最大的成功概率</li>
<li>并行调用, 同时调用多个副本, 返回一个成功即可</li>
<li>广播调用, 同时调用多个副本, 必须全部返回成功, 刷新分布式缓存</li>
</ul>
<table>
<thead>
<tr>
<th>容错策略</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>故障转移</td>
<td>系统自动处理，调用者对失败的信息不可见</td>
<td>增加调用时间，额外的资源开销</td>
<td>调用幂等服务, 对调用时间不敏感的场景</td>
</tr>
<tr>
<td>快速失败</td>
<td>调用者有对失败的处理完全控制权, 不依赖服务的幂等性</td>
<td>调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩</td>
<td>调用非幂等的服务, 超时阈值较低的场景</td>
</tr>
<tr>
<td>安全失败</td>
<td>不影响主路逻辑</td>
<td>只适用于旁路调用</td>
<td>调用链中的旁路服务</td>
</tr>
<tr>
<td>静默失败</td>
<td>控制错误不影响全局</td>
<td>出错的地方将在一段时间内不可用</td>
<td>频繁超时的服务</td>
</tr>
<tr>
<td>故障恢复</td>
<td>调用失败后自动重试，也不影响主路逻辑</td>
<td>重试任务可能产生堆积，重试仍然可能失败</td>
<td>调用链中的旁路服务, 对实时性要求不高的主路逻辑也可以使用</td>
</tr>
<tr>
<td>并行调用</td>
<td>尽可能在最短时间内获得最高的成功率</td>
<td>额外消耗机器资源，大部分调用可能都是无用功</td>
<td>资源充足且对失败容忍度低的场景</td>
</tr>
<tr>
<td>广播调用</td>
<td>支持同时对批量的服务提供者发起调用</td>
<td>资源消耗大，失败概率高</td>
<td>只适用于批量操作的场景</td>
</tr>
</tbody></table>
<h4 id="容错设计模式"><a href="#容错设计模式" class="headerlink" title="容错设计模式"></a>容错设计模式</h4><ul>
<li>断路器模式, 快速失败</li>
<li>舱壁隔离模式, 静默失败<ul>
<li>局部的线程池来控制服务, 缺点增加了 CPU 的开销, 增加请求延时</li>
<li>信号量机制, 为每个远程服务维护一个线程安全的计数器</li>
</ul>
</li>
<li>重试模式, 故障转移, 故障恢复<ul>
<li>仅在主路逻辑的关键服务上进行同步的重试, 尤其不该进行同步重试</li>
<li>仅对由瞬时故障导致的失败进行重试, 例如用http状态码来判断</li>
<li>仅对具备幂等性的服务进行重试</li>
<li>重试必须有明确的终止条件<ul>
<li>超时</li>
<li>次数限制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量统计指标</p>
<ul>
<li>TPS</li>
<li>HPS</li>
<li>QPS</li>
<li>流量, 登录用户数等</li>
</ul>
<p>限流设计模式</p>
<ul>
<li>流量计数器, 针对时间点进行离散的统计</li>
<li>滑动时间窗, 只适用于否决式限流，超过阈值的流量就必须强制失败或降级，很难进行阻塞等待处理</li>
<li>漏桶, 首先在缓冲区中暂存，然后再在控制算法的调节下均匀地发送这些被缓冲的报文, 不支持支持变动请求处理速率</li>
<li>令牌桶, 请求获取令牌</li>
</ul>
<p>分布式限流</p>
<ul>
<li>单机限流模式+各主机共享信息, 网络开销大</li>
<li>单机限流模式+本地缓存部分信息, 网络开销小, 不准确</li>
</ul>
<h3 id="可靠通讯"><a href="#可靠通讯" class="headerlink" title="可靠通讯"></a>可靠通讯</h3><p>基于边界的安全模型: 把网络划分为不同的区域，不同的区域对应于不同风险级别和允许访问的网络资源权限，将安全防护措施集中部署在各个区域的边界之上，重点关注跨区域的网络流量<br>零信任安全模型: 除非明确得到了能代表请求来源的身份凭证，否则一律不会有默认的信任关系</p>
<h4 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h4><ul>
<li>日志, Elasticsearch, Logstash(Fluentd), Kibana</li>
<li>追踪</li>
<li>度量, Java的JMX(单机), Kubernetes的Prometheus, Zabbix</li>
</ul>
<h1 id="不可变基础设施"><a href="#不可变基础设施" class="headerlink" title="不可变基础设施"></a>不可变基础设施</h1><p>云原生: 微服务, 容器网格, 不可变基础设施, 声明式API</p>
<p>软件兼容性</p>
<ul>
<li>ISA兼容: 机器指令集, x86&#x2F;ARM</li>
<li>ABI兼容: 操作系统或二进制库, Windows&#x2F;Linux, DirectX9&#x2F;DirectX12</li>
<li>环境兼容: 配置文件等</li>
</ul>
<p>虚拟化技术</p>
<ul>
<li>指令集虚拟化, 软件模拟指令集</li>
<li>硬件抽象层虚拟化, 以软件或者直接通过硬件来模拟处理器、芯片组、内存、磁盘控制器、显卡等设备, 虚拟机, VMware ESXi和Hyper-V</li>
<li>操作系统层虚拟化, 容器化, 只能提供操作系统内核以上的部分 ABI 兼容性与完整的环境兼容性</li>
<li>运行库虚拟化, 以一个独立进程来代替操作系统内核来提供目标软件运行所需的全部能力, WINE, WSL1</li>
<li>语言层虚拟化, 由虚拟机将高级语言生成的中间代码转换为目标机器可以直接执行的指令，Java 的 JVM 和.NET 的 CLR</li>
</ul>
<h2 id="虚拟化容器"><a href="#虚拟化容器" class="headerlink" title="虚拟化容器"></a>虚拟化容器</h2><p>容器的最初目的: 隔离资源</p>
<ul>
<li>隔离文件: chroot, 当某个进程经过chroot操作之后，它或者它的子进程将不能再访问和操作该目录之外的其他文件</li>
<li>隔离访问：namespaces, 由内核直接提供的全局资源封装，是内核针对进程设计的访问隔离机制, 不仅文件系统是独立的，还有着独立的 PID 编号、UID&#x2F;GID 编号、网络</li>
<li>隔离资源：cgroups, 由内核提供的功能，用于隔离或者说分配并限制某个进程组能够使用的资源配额，包括处理器时间、内存大小、磁盘 I&#x2F;O 速度等</li>
<li>封装系统：LXC, LXC封装系统, Docker封装应用</li>
<li>封装应用：Docker</li>
<li>封装集群：Kubernetes, Docker Engine 经历从不可或缺、默认依赖、可选择、直到淘汰是大概率事件</li>
</ul>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Docker 提倡单个容器封装单进程应用, 因为 Docker 只能通过监视 PID 为 1 的进程（即由 ENTRYPOINT 启动的进程）的运行状态来判断容器的工作状态是否正常</p>
<p>Docker Compose 可以设置不同的容器共享volume, 共享 IPC 名称空间</p>
<p>容器的本质是对 cgroups 和 namespaces 所提供的隔离能力的一种封装，然而 Linux 的 cgroups 和 namespaces 原本都是针对进程组而不仅仅是单个进程来设计的，同一个进程组中的多个进程天然就可以共享着相同的访问权限与资源配额, Kubernetes 里的 Pod</p>
<p>容器协作</p>
<ul>
<li>普通非亲密的容器, 以网络交互方式（其他譬如共享分布式存储来交换信息也算跨网络）</li>
<li>亲密协作的容器，被调度到同一个集群节点上，可以通过共享本地磁盘等方式协作</li>
<li>超亲密的协作, 特指多个容器位于同一个 Pod, 共享: UTS 名称空间, 网络名称空间, IPC 名称空间, 时间名称空间</li>
</ul>
<p>Kubernetes 将一切皆视为资源，不同资源之间依靠层级关系相互组合协作</p>
<ul>
<li>container, 延续了自 Docker 以来一个容器封装一个应用进程的理念，是镜像管理的最小单位</li>
<li>Pod, 补充了容器化后缺失的与进程组对应的“容器组”的概念，是资源调度的最小单位</li>
<li>Node, 对应于集群中的单台机器，这里的机器即可以是生产环境中的物理机，也可以是云计算环境中的虚拟节点，节点是处理器和内存等资源的资源池，是硬件单元的最小单位</li>
<li>Cluster, 当你要部署应用的时候，只需要通过声明式 API 将你的意图写成一份元数据, 是处理元数据的最小单位</li>
</ul>
<p>资源附加上了期望状态与实际状态两项属性，用户要想使用这些资源来实现某种需求，并不提倡像平常编程那样去调用某个或某一组方法来达成目的，而是通过描述清楚这些资源的期望状态，由 Kubernetes 中对应监视这些资源的控制器来驱动资源的实际状态逐渐向期望状态靠拢，这种交互风格被称为是 Kubernetes 的声明式 API</p>
<p>以应用(集群)为中心的封装</p>
<ul>
<li>Kustomize, 根据环境来生成不同的部署配置</li>
<li>Helm, Chart, 应用商店与包管理工具, 无法很好地管理这种有状态的依赖关系</li>
<li>Operator, CRD, 要求开发者自己实现一个专门针对该自定义资源的控制器，在控制器中维护自定义资源的期望状态</li>
<li>开放应用模型</li>
</ul>
<h2 id="容器间网络"><a href="#容器间网络" class="headerlink" title="容器间网络"></a>容器间网络</h2><h3 id="Linux网络虚拟化"><a href="#Linux网络虚拟化" class="headerlink" title="Linux网络虚拟化"></a>Linux网络虚拟化</h3><h4 id="网络通信模型"><a href="#网络通信模型" class="headerlink" title="网络通信模型"></a>网络通信模型</h4><h4 id="干预网络通信"><a href="#干预网络通信" class="headerlink" title="干预网络通信"></a>干预网络通信</h4><h4 id="虚拟化网络设备"><a href="#虚拟化网络设备" class="headerlink" title="虚拟化网络设备"></a>虚拟化网络设备</h4><h4 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h4><h3 id="容器网络与生态"><a href="#容器网络与生态" class="headerlink" title="容器网络与生态"></a>容器网络与生态</h3><h4 id="CNM-与-CNI"><a href="#CNM-与-CNI" class="headerlink" title="CNM 与 CNI"></a>CNM 与 CNI</h4><h4 id="网络插件生态"><a href="#网络插件生态" class="headerlink" title="网络插件生态"></a>网络插件生态</h4><h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><h3 id="Kubernetes-存储设计"><a href="#Kubernetes-存储设计" class="headerlink" title="Kubernetes 存储设计"></a>Kubernetes 存储设计</h3><h4 id="Mount-和-Volume"><a href="#Mount-和-Volume" class="headerlink" title="Mount 和 Volume"></a>Mount 和 Volume</h4><h4 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h4><h4 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h4><h3 id="容器存储与生态"><a href="#容器存储与生态" class="headerlink" title="容器存储与生态"></a>容器存储与生态</h3><h4 id="Kubernetes-存储架构"><a href="#Kubernetes-存储架构" class="headerlink" title="Kubernetes 存储架构"></a>Kubernetes 存储架构</h4><h4 id="FlexVolume-与-CSI"><a href="#FlexVolume-与-CSI" class="headerlink" title="FlexVolume 与 CSI"></a>FlexVolume 与 CSI</h4><h4 id="从-In-Tree-到-Out-of-Tree"><a href="#从-In-Tree-到-Out-of-Tree" class="headerlink" title="从 In-Tree 到 Out-of-Tree"></a>从 In-Tree 到 Out-of-Tree</h4><h4 id="容器插件生态"><a href="#容器插件生态" class="headerlink" title="容器插件生态"></a>容器插件生态</h4><h2 id="资源与调度"><a href="#资源与调度" class="headerlink" title="资源与调度"></a>资源与调度</h2><h3 id="资源模型"><a href="#资源模型" class="headerlink" title="资源模型"></a>资源模型</h3><h3 id="服务质量与优先级"><a href="#服务质量与优先级" class="headerlink" title="服务质量与优先级"></a>服务质量与优先级</h3><h3 id="驱逐机制"><a href="#驱逐机制" class="headerlink" title="驱逐机制"></a>驱逐机制</h3><h3 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h3><h2 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h2><h3 id="透明通信的涅槃"><a href="#透明通信的涅槃" class="headerlink" title="透明通信的涅槃"></a>透明通信的涅槃</h3><h4 id="通信的成本"><a href="#通信的成本" class="headerlink" title="通信的成本"></a>通信的成本</h4><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><h4 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h4><h3 id="服务网格与生态"><a href="#服务网格与生态" class="headerlink" title="服务网格与生态"></a>服务网格与生态</h3><h4 id="服务网格接口"><a href="#服务网格接口" class="headerlink" title="服务网格接口"></a>服务网格接口</h4><h4 id="通用数据平面-API"><a href="#通用数据平面-API" class="headerlink" title="通用数据平面 API"></a>通用数据平面 API</h4><h4 id="服务网格生态"><a href="#服务网格生态" class="headerlink" title="服务网格生态"></a>服务网格生态</h4><h1 id="技术方法论"><a href="#技术方法论" class="headerlink" title="技术方法论"></a>技术方法论</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的目的是有效的拆分应用，实现敏捷开发和部署</p>
<p>前提条件</p>
<ol>
<li>决策者与执行者都能意识到康威定律在软件设计中的关键作用(系统的架构趋同于组织的沟通结构)</li>
<li>组织中具备一些对微服务有充分理解、有一定实践经验的技术专家</li>
<li>系统应具有以自治为目标的自动化与监控度量能力</li>
<li>复杂性已经成为制约生产力的主要矛盾</li>
</ol>
<p>微服务的粒度: 领域驱动设计, DDD</p>
<ul>
<li>能够独立发布、独立部署、独立运行与独立测试</li>
<li>强相关的功能与数据在同一个服务中处理</li>
<li>一个服务包含至少一项业务实体与对应的完整操作</li>
<li>一个 2 Pizza Team (6-12) 能够在一个研发周期内完成的全部需求范围</li>
</ul>
<p>系统复杂性来源</p>
<ul>
<li>认知负担, 微服务&gt;单体服务</li>
<li>合作成本, 随人数的上升而上升, 单体服务上升比例远大于微服务</li>
</ul>
<p>架构腐化</p>
<blockquote>
<p>项目在开始的时候，团队会花很多时间去决策该选择用什么技术体系、哪种架构、怎样的平台框架、甚至具体到开发、测试和持续集成工具。此时就像小孩子们在选择自己所钟爱的玩具，笔者相信无论决策的结果如何，团队都会欣然选择他们所选择的，并且坚信他们的选择是正确的。事实也确实如此，团队选择的解决方案通常能够解决技术选型时就能预料到的那部分困难。但真正困难的地方在于，随着时间的流逝，团队对该项目质量的持续保持能力会逐渐下降，一方面是高级技术专家不可能持续参与软件稳定之后的迭代过程，反过来，如果持续绑定在同一个达到稳定之后的项目上，也很难培养出技术专家。老人的退出新人的加入使得团队总是需要理解旧代码的同时完成新功能，技术专家偶尔来评审一下或救一救火，充其量只能算临时抱佛脚；另一方面是代码会逐渐失控，时间长了一定会有某些并不适合放进最初设计中的需求出现，工期紧任务重业务复杂代码不熟悉都会成为欠下一笔技术债的妥协理由，原则底线每一次被细微地突破，都可能被破窗效应撕裂放大成触目惊心的血痕，最终累积到每个新人到来就马上能嗅出老朽腐臭味道的程度。</p>
</blockquote>
<p>架构腐化是软件动态发展中出现的问题，任何静态的治理方案都只能延缓，不能根治，唯一有效的办法是演进式的设计</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2022-01-07-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97a%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E6%AC%A1%E5%B9%82.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-01-07-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97a%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E6%AC%A1%E5%B9%82.html" class="post-title-link" itemprop="url">位运算计算大于等于给定数字a的最小二次幂</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-07 00:00:00 / 修改时间：16:06:21" itemprop="dateCreated datePublished" datetime="2022-01-07T00:00:00+08:00">2022-01-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

            <div class="post-description">Java里HashMap的两种实现</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/2%E7%9A%84%E5%B9%82">二次幂</a> 是指底数为2且指数为整数n的幂, 如2, 4, 8, 16等</p>
<p><code>大于等于给定数字a的最小二次幂</code> 即输入[5, 8]的数均输出8, 输入[9, 16]的数均输出16</p>
<p>在Java的HashMap中, 为了方便计算hash值、减少hash碰撞, hash的范围都是二次幂, 在初始化map和map扩容时需要根据给定的初始值计算<code>大于等于给定数字a的最小二次幂</code>, 即 <code>HashMap.java</code> 中的 <code>int tableSizeFor(int cap)</code></p>
<p>Java中int的最大值为2^31-1, 即<code>0x7fffffff</code>, 即<code>01111111 11111111 11111111 11111111</code></p>
<p>HashMap的capacity最大值为2^30, 即<code>1 &lt;&lt; 30</code>, 即<code>0x40000000</code>, 即<code>01000000 00000000 00000000 00000000</code></p>
<h1 id="Java8中的实现"><a href="#Java8中的实现" class="headerlink" title="Java8中的实现"></a>Java8中的实现</h1><p>看二进制的数, <code>大于给定数字a的最小二次幂</code>即从左到右数第一个值为1的位, 再左一位为1其他为0</p>
<p>5-&gt;8  0101-&gt;1000</p>
<p>7-&gt;8  0111-&gt;1000</p>
<p>目标值减1的数, 即从第一个值为1的位开始所有位的值均为1</p>
<p>5-&gt;7  0101-&gt;0111</p>
<p>7-&gt;7  0111-&gt;0111</p>
<p>考虑到输入即为二次幂的情况, 先将输入减1, 再计算从第一个值为1的位开始所有位的值均为1, 不需要考虑等于的情况, 最后得到的数再加1</p>
<p>0010 1001-&gt;0011 1111 即 41-&gt;63, 输出64</p>
<p>如何将一个数最高位1后面的1全部置为1呢? 使用右移+取或, 例如<code>0100</code>右移1位并和自身取或<code>0100 | 0010 = 0110</code>就将最高位的后一位置为了1, 不断重复这个过程</p>
<p>输入的最大值为<code>1 &lt;&lt; 30</code>即<code>01000000 00000000 00000000 00000000</code></p>
<p>减1后为<code>00111111 11111111 11111111 11111111</code>, 不断右移取或后还是自己, 加1后为<code>01000000 00000000 00000000 00000000</code></p>
<p>假设输入<code>1 &lt;&lt; 29 + 1</code>即<code>00100000 00000000 00000000 00000001</code></p>
<p>右移1位后和自己取或<code>00110000 00000000 00000000 00000000</code></p>
<p>右移2位后和自己取或<code>00111100 00000000 00000000 00000000</code></p>
<p>右移4位后和自己取或<code>00111111 11000000 00000000 00000000</code></p>
<p>右移8位后和自己取或<code>00111111 11111111 11000000 00000000</code></p>
<p>右移16位后和自己取或<code>00111111 11111111 11111111 11111111</code></p>
<p>加1后为<code>01000000 00000000 00000000 00000001</code>即<code>1 &lt;&lt; 30</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java11中的实现"><a href="#Java11中的实现" class="headerlink" title="Java11中的实现"></a>Java11中的实现</h1><p>目标同样是将最高位1后面的0计算出前导0的个数, 最后加1</p>
<p>先求出a前导0的数量, 使用比较和移位求出, 然后直接将-1 <code>0xffffffff</code>进行无符号右移</p>
<p>其中<code>numberOfLeadingZeros()</code>方法在OracleJDK中含注解<code>@IntrinsicCandidate</code>, OpenJDK中含注解<code>@HotSpotIntrinsicCandidate</code>, 均表示HotspotJVM会根据当前处理器平台对运算进行优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Integer.numberOfLeadingZeros()</code>的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Count leading 0&#x27;s</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-11-05-Java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E5%B7%A5%E5%85%B7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-11-05-Java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E5%B7%A5%E5%85%B7.html" class="post-title-link" itemprop="url">Java中几种常用的异步工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-05 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-05T00:00:00+08:00">2021-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-07 15:37:47" itemprop="dateModified" datetime="2022-01-07T15:37:47+08:00">2022-01-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>432</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

            <div class="post-description">线程池, ForkJoin, CompletableFuture的关系</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>几种异步工具的演化</p>
<ul>
<li>new线程, <code>Runnable</code> &#x2F; <code>Callable</code></li>
<li>线程池, <code>Executor</code> &#x2F; <code>ExecutorService</code> + <code>Future</code> &#x2F; <code>FutureTask</code></li>
<li>ForkJoin, <code>ForkJoinPool</code></li>
<li>CompletableFuture</li>
</ul>
<p>使用自定义的forkJoinPool运行parallelStream<br>new ForkJoinPool(16).submit(() -&gt; list.parallelStream())</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>new线程</td>
<td></td>
<td>线程创建和销毁消耗资源</td>
<td></td>
</tr>
<tr>
<td>线程池</td>
<td>降低线程创建和销毁的资源消耗, 统一管理线程</td>
<td></td>
<td></td>
</tr>
<tr>
<td>forkjoin</td>
<td>使用worksteal算法, 效率高于普通线程池</td>
<td></td>
<td>数据集大且可拆分, 并行的子集逻辑相对独立, CPU密集</td>
</tr>
<tr>
<td>CompletableFuture</td>
<td>链式写法, 支持自定义线程池</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://v2ex.com/t/811364">发现了个很奇怪的现象，关于 parallelStream 的 - V2EX</a></p>
<p><a href="https://hahahaha123567.github.io/2018-08-13-java-util-concurrent.html">java.util.concurrent | hahahaha123567’s Blog</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-07-22-%E9%98%85%E8%AF%BBSpring%E6%BA%90%E7%A0%811.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-07-22-%E9%98%85%E8%AF%BBSpring%E6%BA%90%E7%A0%811.html" class="post-title-link" itemprop="url">阅读Spring源码(1) - 上下文启动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-22T00:00:00+08:00">2021-07-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-08-05 17:32:04" itemprop="dateModified" datetime="2021-08-05T17:32:04+08:00">2021-08-05</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

            <div class="post-description">跟着其他人的博客看源码</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring的整体架构和环境搭建"><a href="#Spring的整体架构和环境搭建" class="headerlink" title="Spring的整体架构和环境搭建"></a>Spring的整体架构和环境搭建</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-chen-hao/p/11046190.html">spring5 源码深度解析—–Spring的整体架构和环境搭建 - chen_hao - 博客园</a></p>
<p>Spring的整体架构</p>
<ul>
<li>Core Container<ul>
<li>Core</li>
<li>Beans</li>
<li>Context</li>
<li>SpEL</li>
</ul>
</li>
<li>AOP</li>
<li>Aspect</li>
<li>Instrumentation</li>
<li>Messaging</li>
<li>Web<ul>
<li>Web</li>
<li>Servlet</li>
<li>Websocket</li>
<li>Portlet</li>
</ul>
</li>
<li>Data Access&#x2F;Integration<ul>
<li>JDBC</li>
<li>ORM</li>
<li>OXM</li>
<li>JMS</li>
<li>Transactions</li>
</ul>
</li>
<li>Test</li>
</ul>
<p>阅读步骤</p>
<ol>
<li>安装gradle</li>
<li>下载源码</li>
<li>build项目</li>
<li>创建测试模块并debug</li>
</ol>
<h1 id="IOC注册"><a href="#IOC注册" class="headerlink" title="IOC注册"></a>IOC注册</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-chen-hao/p/11113340.html">spring5 源码深度解析—– IOC 之 容器的基本实现 - chen_hao - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-chen-hao/p/11115300.html">spring5 源码深度解析—– IOC 之 默认标签解析（上） - chen_hao - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-chen-hao/p/11120677.html">spring5 源码深度解析—– IOC 之 默认标签解析（下） - chen_hao - 博客园</a></p>
<p>ClassPathResource, Resource 配置资源的抽象</p>
<p>示例使用 XmlBeanFactory</p>
<blockquote>
<p>BeanFactoryAware&#x2F;ApplicationContextAware 在构建BeanFactory的时候就进行了相关配置</p>
</blockquote>
<p>XmlBeanDefinitionReader 解析XML文件, 返回 <code>org.w3c.dom.Document</code></p>
<p>BeanDefinitionDocumentReader 使用 BeanDefinitionParserDelegate 解析Document, 包含defaultElement&#x2F;customElement, 返回 <code>BeanDefinitionHolder</code> (包含 <code>GenericBeanDefinition</code>)</p>
<p>BeanDefinitionDocumentReader 将 &lt;beanName, beanDefinition&gt; 注册到 <code>BeanDefinitionRegistry</code>(beanFactory), 实际使用 <code>DefaultListableBeanFactory</code> 的 <code>registerBeanDefinition</code>, 映射关系保存在一个ConcurrentHashMap中</p>
<h1 id="IOC注入-BeanFactory"><a href="#IOC注入-BeanFactory" class="headerlink" title="IOC注入(BeanFactory)"></a>IOC注入(BeanFactory)</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-chen-hao/p/11137571.html">spring5 源码深度解析—– IOC 之 开启 bean 的加载 - chen_hao - 博客园</a></p>
<p><strong>BeanFactory</strong></p>
<p><img src="/../../../../image/bean_factory.png" alt="BeanFactory类图"></p>
<p><code>BeanFactory</code> 和 <code>FactoryBean</code> 的区别:</p>
<ul>
<li>BeanFactory, 访问 Spring bean 容器的根接口, 是应用程序组件的中央注册表</li>
<li>FactoryBean, 如果一个 bean 实现了这个接口，它就被用作一个对象暴露的工厂</li>
</ul>
<h2 id="获取bean名称"><a href="#获取bean名称" class="headerlink" title="获取bean名称"></a>获取bean名称</h2><p><code>AbstractBeanFactory</code> 的 <code>transformedBeanName</code></p>
<ol>
<li>FactoryBean的&amp;名称解引用</li>
<li>alias转换</li>
</ol>
<h2 id="获取单例缓存sharedInstance"><a href="#获取单例缓存sharedInstance" class="headerlink" title="获取单例缓存sharedInstance"></a>获取单例缓存sharedInstance</h2><p><code>DefaultSingletonBeanRegistry</code> 的 <code>getSingleton()</code></p>
<p>几个缓存(使用时不加锁的是ConcurrentHashMap, 使用时加锁的是HashMap)</p>
<ul>
<li>singletonObjects:用于保存BeanName和创建bean实例之间的关系，beanName–&gt;bean Instance</li>
<li>singletonFactories:用于保存BeanName和创建bean的工厂之间的关系，banName–&gt;ObjectFactory</li>
<li>earlySingletonObjects:也是保存BeanName和创建bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例bean被放到这里面后，那么当bean还在创建过程中，就可以通过getBean方法获取到了，其目的是用来检测循环引用</li>
</ul>
<p>如果有单例缓存, 则使用单例缓存获取bean</p>
<p>如果单例缓存不是FactoryBean则说明为bean直接返回</p>
<p>如果单例缓存是FactoryBean则调用getBean, <code>DefaultSingletonBeanRegistry</code> 的 <code>beforeSingletonCreation</code> <code>afterSingletonCreation</code> 继续使用缓存判断是否创建中(检测循环引用), <code>postProcessObjectFromFactoryBean</code> 调用bean的 <code>BeanPostProcessors</code> 方法</p>
<h2 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-chen-hao/p/11139157.html">spring5 源码深度解析—– IOC 之 bean 创建 - chen_hao - 博客园</a></p>
<p>未获取到单例缓存的话就要创建bean</p>
<p>入口 <code>AbstractBeanFactory</code> 的 <code>doGetBean()</code></p>
<h3 id="scope-x3D-singleton"><a href="#scope-x3D-singleton" class="headerlink" title="scope&#x3D;singleton"></a>scope&#x3D;singleton</h3><ol>
<li>synchronized全局锁</li>
<li>检查缓存</li>
<li>beforeSingletonCreation()</li>
<li>createBean()</li>
<li>afterSingletonCreation()</li>
<li>加入缓存</li>
</ol>
<h3 id="scope-x3D-prototype"><a href="#scope-x3D-prototype" class="headerlink" title="scope&#x3D;prototype"></a>scope&#x3D;prototype</h3><ol>
<li>beforeSingletonCreation()</li>
<li>createBean()</li>
<li>afterSingletonCreation()</li>
<li>getObjectForBeanInstance()</li>
</ol>
<h3 id="scope-x3D-other"><a href="#scope-x3D-other" class="headerlink" title="scope&#x3D;other"></a>scope&#x3D;other</h3><ol>
<li>beforeSingletonCreation()</li>
<li>scope.get() -&gt; createBean()</li>
<li>afterSingletonCreation()</li>
<li>getObjectForBeanInstance()</li>
</ol>
<h3 id="实现的方法createBean"><a href="#实现的方法createBean" class="headerlink" title="实现的方法createBean()"></a>实现的方法createBean()</h3><p><code>AbstractAutowireCapableBeanFactory</code> 的 <code>createBean()</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-07-01-Java%E5%90%84%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-07-01-Java%E5%90%84%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D.html" class="post-title-link" itemprop="url">Java各版本更新介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-01T00:00:00+08:00">2021-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-07-22 16:03:00" itemprop="dateModified" datetime="2021-07-22T16:03:00+08:00">2021-07-22</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>80</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

            <div class="post-description">受限于自己贫乏的项目经验和语言理解,不再自己记录日志或翻译更新文档,收录dalao的文章</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/655943e5f85e6f79ffbd03047">新时代背景下的Java语法特性(9-14) - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/92ba88c7926b5f5c6fbc11830">剖析Java15新语法特性 - InfoQ 写作平台</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/8304c894c4e38318d38ceb116">实操 | 剖析 Java16 新语法特性 - InfoQ 写作平台</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-06-28-IDEA%E5%B0%86%E6%96%87%E4%BB%B6%E6%A0%87%E8%AE%B0%E4%B8%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%8F%8A%E5%8F%96%E6%B6%88.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-06-28-IDEA%E5%B0%86%E6%96%87%E4%BB%B6%E6%A0%87%E8%AE%B0%E4%B8%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%8F%8A%E5%8F%96%E6%B6%88.html" class="post-title-link" itemprop="url">IDEA将文件标记为文本文件及取消</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-28 00:00:00 / 修改时间：17:56:23" itemprop="dateCreated datePublished" datetime="2021-06-28T00:00:00+08:00">2021-06-28</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>253</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

            <div class="post-description">经常在重构时误触导致文件不能正常识别与提示</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用IDEA编辑文件时，在修改文件名时有时会修改文件后缀，此时IDE会弹出 <code>Register New File Type Association</code> 让你设置一些文件后缀的识别规则</p>
<p>这个时候我经常没看清楚误触导致IDE不再智能识别某种特定后缀的文件，编辑起来很不舒服</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="以前"><a href="#以前" class="headerlink" title="以前"></a>以前</h2><p>在文件上右键，选择 <code>mark as plain text</code> 或相反的选项</p>
<p>但是最近IDEA似乎移除了这个选项</p>
<h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p><code>Preferences</code> -&gt; <code>Editor</code> -&gt; <code>File Types</code> 这里可以任意修改文件后缀的识别规则，包括 <code>Recognized</code> 和 <code>Ignored</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-06-25-SpringCloud%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-06-25-SpringCloud%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html" class="post-title-link" itemprop="url">SpringCloud的一些常用组件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-06-25T00:00:00+08:00">2021-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-07-01 16:09:59" itemprop="dateModified" datetime="2021-07-01T16:09:59+08:00">2021-07-01</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>753</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

            <div class="post-description">SpringCloud的一些常用组件</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="服务组成"><a href="#服务组成" class="headerlink" title="服务组成"></a>服务组成</h1><p><img src="/../../../../image/spring_cloud_architecture_highlights.svg" alt="spring_cloud_architecture_highlights"></p>
<h2 id="service-discovery-服务发现"><a href="#service-discovery-服务发现" class="headerlink" title="service discovery 服务发现"></a>service discovery 服务发现</h2><ul>
<li>Eureka (netflix)</li>
<li>Consul</li>
<li>Zookeeper</li>
<li>Kubernetes</li>
<li>nacos (alibaba)</li>
</ul>
<h2 id="API-gateway-API网关"><a href="#API-gateway-API网关" class="headerlink" title="API gateway API网关"></a>API gateway API网关</h2><ul>
<li>spring cloud gateway</li>
</ul>
<h2 id="cloud-configuration-云配置"><a href="#cloud-configuration-云配置" class="headerlink" title="cloud configuration 云配置"></a>cloud configuration 云配置</h2><ul>
<li>spring cloud config</li>
<li>nacos (alibaba)</li>
</ul>
<h2 id="circuit-breaker-服务熔断"><a href="#circuit-breaker-服务熔断" class="headerlink" title="circuit breaker 服务熔断"></a>circuit breaker 服务熔断</h2><ul>
<li>Hystrix (netflix)</li>
<li>Resilience4J</li>
<li>Sentinel (alibaba)</li>
<li>Spring Retry</li>
</ul>
<h2 id="tracing-链路跟踪"><a href="#tracing-链路跟踪" class="headerlink" title="tracing 链路跟踪"></a>tracing 链路跟踪</h2><ul>
<li>Spring Cloud Sleuth</li>
<li>zipkin</li>
</ul>
<h2 id="test-测试"><a href="#test-测试" class="headerlink" title="test 测试"></a>test 测试</h2><ul>
<li>Spring Cloud Contract</li>
</ul>
<h2 id="others-其他"><a href="#others-其他" class="headerlink" title="others 其他"></a>others 其他</h2><h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><ul>
<li>Kafka</li>
<li>RabbitMQ</li>
<li>Feign</li>
</ul>
<h3 id="Distributed-Transaction"><a href="#Distributed-Transaction" class="headerlink" title="Distributed Transaction"></a>Distributed Transaction</h3><ul>
<li>Seata</li>
</ul>
<h1 id="套件"><a href="#套件" class="headerlink" title="套件"></a>套件</h1><h2 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h2><p>原组件</p>
<ul>
<li>Hystrix(熔断器)</li>
<li>Hystrix Dashboard(监控)</li>
<li>Ribbon(客户端负载均衡)</li>
<li>Zuul(网关)</li>
<li>Archaius(云配置)</li>
</ul>
<p>现在项目内只有Eureka</p>
<h2 id="Netflix替代"><a href="#Netflix替代" class="headerlink" title="Netflix替代"></a>Netflix替代</h2><p>Spring Cloud 2020.0.0版本彻底删除掉了Netflix除Eureka外的所有组件, 推荐的替代品如下</p>
<ul>
<li>Resilience4j</li>
<li>Micrometer + Monitoring System</li>
<li>Spring Cloud Loadbalancer</li>
<li>Spring Cloud Gateway</li>
<li>Spring Cloud Config</li>
</ul>
<p>Feign从Netflix转交给OpenFeign, 当前可以使用Spring Cloud Loadbalancer作为http-client实现</p>
<hr>
<p><strong>reference</strong></p>
<p><a target="_blank" rel="noopener" href="https://spring.io/cloud">Spring | Cloud</a></p>
<p><a target="_blank" rel="noopener" href="https://incoder.org/2020/11/11/microservices-alibaba1/#SpringCloud-VS-SpringCloud-Alibaba">微服务架构 - Alibaba 生态整合（一） | BladeCode</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-06-24-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E9%83%A8%E5%88%86%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-06-24-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E9%83%A8%E5%88%86%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD.html" class="post-title-link" itemprop="url">Java实现gRPC的部分进阶功能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-24 00:00:00 / 修改时间：17:27:43" itemprop="dateCreated datePublished" datetime="2021-06-24T00:00:00+08:00">2021-06-24</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

            <div class="post-description">本篇文章内容均基于gRPC官方文档提供的代码示例</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本篇文章内容均基于gRPC<a target="_blank" rel="noopener" href="https://grpc.io/docs/languages/java/quickstart/">官方文档</a>提供的<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-java/archive/v1.38.0.zip">代码示例v1.38.0</a></p>
<p>你也可以直接看<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-java/tree/master/examples">github上的最新版本</a></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p><code>StatusException</code> gRPC常用的异常类型, 扩展自 <code>Exception</code> , 包含状态信息 <code>Status status</code> 和扩展信息 <code>Metadata trailers</code></p>
<p><code>StatusRuntimeException</code> gRPC常用的异常类型, 扩展自 <code>RuntimeException</code> , 包含状态信息 <code>Status status</code> 和扩展信息 <code>Metadata trailers</code></p>
<h2 id="服务端返回错误"><a href="#服务端返回错误" class="headerlink" title="服务端返回错误"></a>服务端返回错误</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误扩展信息key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Metadata.Key&lt;DebugInfo&gt; DEBUG_INFO_TRAILER_KEY = ProtoUtils.keyForProto(DebugInfo.getDefaultInstance());</span><br><span class="line"><span class="comment">// 错误扩展信息value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DebugInfo</span> <span class="variable">DEBUG_INFO</span> <span class="operator">=</span> DebugInfo.newBuilder()</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_1&quot;</span>)</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_2&quot;</span>)</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_3&quot;</span>)</span><br><span class="line">                                                    .setDetail(<span class="string">&quot;detailed error info.&quot;</span>).build();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;</span><br><span class="line">    <span class="comment">// 错误扩展信息</span></span><br><span class="line">    <span class="type">Metadata</span> <span class="variable">trailers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Metadata</span>();</span><br><span class="line">    trailers.put(DEBUG_INFO_TRAILER_KEY, DEBUG_INFO);</span><br><span class="line">    <span class="comment">// 返回错误</span></span><br><span class="line">    responseObserver.onError(</span><br><span class="line">        Status.INTERNAL.withDescription(DEBUG_DESC).asRuntimeException(trailers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端处理错误"><a href="#客户端处理错误" class="headerlink" title="客户端处理错误"></a>客户端处理错误</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Metadata.Key&lt;DebugInfo&gt; DEBUG_INFO_TRAILER_KEY = ProtoUtils.keyForProto(DebugInfo.getDefaultInstance());</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> Status.fromThrowable(t);</span><br><span class="line">    <span class="type">Metadata</span> <span class="variable">trailers</span> <span class="operator">=</span> Status.trailersFromThrowable(t);</span><br><span class="line">    <span class="comment">// 不符合条件则抛出VerifyException</span></span><br><span class="line">    Verify.verify(status.getCode() == Status.Code.INTERNAL);</span><br><span class="line">    Verify.verify(trailers.containsKey(DEBUG_INFO_TRAILER_KEY));</span><br><span class="line">    Verify.verify(status.getDescription().contains(<span class="string">&quot;Overbite&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端请求重试"><a href="#客户端请求重试" class="headerlink" title="客户端请求重试"></a>客户端请求重试</h2><p>配置重试参数需要在构建channel时传入配置, 具体参数等可以参考 <code>ManagedChannelServiceConfig</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重试参数</span></span><br><span class="line">Map&lt;String, Object&gt; name0 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">name0.put(<span class="string">&quot;service&quot;</span>, <span class="string">&quot;helloworld.Greeter&quot;</span>);</span><br><span class="line">name0.put(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;SayHello&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; retryPolicies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">retryPolicies.put(<span class="string">&quot;backoffMultiplier&quot;</span>, <span class="number">2.0</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;maxAttempts&quot;</span>, <span class="number">5.0</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;initialBackoff&quot;</span>, <span class="string">&quot;0.5s&quot;</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;maxBackoff&quot;</span>, <span class="string">&quot;30s&quot;</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;retryableStatusCodes&quot;</span>, Arrays.stream(Status.Code.values()).filter(code -&gt; !Status.Code.OK.equals(code)).map(Enum::name).collect(Collectors.toList()));</span><br><span class="line">Map&lt;String, Object&gt; methodConfig0 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">methodConfig0.put(<span class="string">&quot;name&quot;</span>, Collections.singletonList(name0));</span><br><span class="line">methodConfig0.put(<span class="string">&quot;retryPolicy&quot;</span>, retryPolicies);</span><br><span class="line">Map&lt;String, Object&gt; defaultServiceConfig = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">defaultServiceConfig.put(<span class="string">&quot;methodConfig&quot;</span>, Collections.singletonList(methodConfig0));</span><br><span class="line"><span class="comment">// 构建channel</span></span><br><span class="line">helloWorldChannel = ManagedChannelBuilder.forTarget(<span class="string">&quot;localhost:50051&quot;</span>)</span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .enableRetry()</span><br><span class="line">        .defaultServiceConfig(defaultServiceConfig)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>以上为Java代码方式构造参数, 官方提供的是使用json配置文件+gson解析的方式</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;methodConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;helloworld.Greeter&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SayHello&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;retryPolicy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;maxAttempts&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;initialBackoff&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.5s&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;maxBackoff&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30s&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;backoffMultiplier&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;retryableStatusCodes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;UNAVAILABLE&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">JsonReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(RetryingHelloWorldClient.class.getResourceAsStream(<span class="string">&quot;retrying_service_config.json&quot;</span>), UTF_8)),Map.class);</span><br></pre></td></tr></table></figure>

<h2 id="服务端拦截器"><a href="#服务端拦截器" class="headerlink" title="服务端拦截器"></a>服务端拦截器</h2><p>gRPC支持服务端设置拦截器链</p>
<p>继承 <code>ServerInterceptor</code> 接口并实现 <code>interceptCall</code> 方法, 在创建 <code>server</code> 时进行配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LatencyInjectionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ServerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;HelloRequestT, HelloReplyT&gt; Listener&lt;HelloRequestT&gt; <span class="title function_">interceptCall</span><span class="params">(ServerCall&lt;HelloRequestT, HelloReplyT&gt; call, Metadata headers, ServerCallHandler&lt;HelloRequestT, HelloReplyT&gt; next)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个Interceptor制造了长尾延迟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (random &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            delay = <span class="number">10_000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (random &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            delay = <span class="number">5_000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (random &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            delay = <span class="number">2_000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(delay);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next.startCall(call, headers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> ServerBuilder.forPort(port)</span><br><span class="line">        .addService(<span class="keyword">new</span> <span class="title class_">GreeterImpl</span>())</span><br><span class="line">        .intercept(<span class="keyword">new</span> <span class="title class_">LatencyInjectionInterceptor</span>())</span><br><span class="line">        .build()</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure>

<h2 id="请求对冲"><a href="#请求对冲" class="headerlink" title="请求对冲"></a>请求对冲</h2><p><code>对冲请求</code> 是一种优化 <code>长尾延迟</code> 的方法, 参考 <a target="_blank" rel="noopener" href="https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577">Hedged requests — Tackling tail latency | by Ricardo Linck | The Startup | Medium</a></p>
<p>gRPC自带对冲请求的支持, 类似上面的重试请求, 需要在构造channel时进行配置, 配置粒度精确到方法</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;helloworld.Greeter&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SayHello&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hedgingPolicy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;maxAttempts&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;hedgingDelay&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;retryThrottling&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;maxTokens&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tokenRatio&quot;</span><span class="punctuation">:</span> <span class="number">0.1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>gRPC提供的示例还包括</p>
<ul>
<li>client自定义请求头</li>
<li>server自定义请求头</li>
<li>请求压缩</li>
<li>响应压缩</li>
<li>client自定义序列化反序列化逻辑</li>
<li>server自定义序列化反序列化逻辑</li>
<li>背压流量控制</li>
<li>TLS</li>
<li>ALTS(Google’s Application Layer Transport Security)</li>
<li>jwt</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-06-23-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-06-23-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF.html" class="post-title-link" itemprop="url">Java实现gRPC的服务端和客户端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-23 00:00:00" itemprop="dateCreated datePublished" datetime="2021-06-23T00:00:00+08:00">2021-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-06-24 11:45:17" itemprop="dateModified" datetime="2021-06-24T11:45:17+08:00">2021-06-24</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

            <div class="post-description">按照官方文档实践之后的流程梳理</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gRPC简介"><a href="#gRPC简介" class="headerlink" title="gRPC简介"></a>gRPC简介</h1><p>gRPC是一种 <a href="https://hahahaha123567.github.io/2020/04/17/2020-04-17-RPC%E6%A6%82%E5%BF%B5/">RPC</a> 框架,特点:</p>
<ol>
<li>序列化&#x2F;反序列化使用Protocol Buffers,比起json等格式更高效</li>
<li>支持多种语言编写服务端&#x2F;客户端</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://grpc.io/">gRPC官网</a></p>
<h1 id="Java开发gRPC流程"><a href="#Java开发gRPC流程" class="headerlink" title="Java开发gRPC流程"></a>Java开发gRPC流程</h1><p>本章节内容基于 <a target="_blank" rel="noopener" href="https://grpc.io/docs/languages/java/basics/">Basics tutorial | Java | gRPC</a></p>
<h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><p>protocol buffer使用proto文件定义接口,参考 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3)  |  Protocol Buffers  |  Google Developers</a></p>
<p>以下为示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 协议版本</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">// 编译后是否生成多个Java类</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">// 编译后生成Java类的package路径</span><br><span class="line">option java_package = &quot;idol.elie.grpc.routeguide.protobuf&quot;;</span><br><span class="line">// 编译后生成的配置基类名</span><br><span class="line">option java_outer_classname = &quot;RouteGuideProto&quot;;</span><br><span class="line"></span><br><span class="line">// proto内部使用的package</span><br><span class="line">package routeguide;</span><br><span class="line"></span><br><span class="line">// 接口</span><br><span class="line">service RouteGuide &#123;</span><br><span class="line">    // 客户端同步请求,服务端单次返回</span><br><span class="line">    rpc GetFeature(Point) returns (Feature) &#123;&#125;;</span><br><span class="line">    // 客户端同步请求,服务端流式返回</span><br><span class="line">    rpc ListFeatures(Rectangle) returns (stream Feature);</span><br><span class="line">    // 客户端流式异步请求,服务端单次返回</span><br><span class="line">    rpc RecordRoute(stream Point) returns (RouteSummary);</span><br><span class="line">    // 客户端流式异步请求,服务端流式返回</span><br><span class="line">    rpc RouteChat(stream RouteNote) returns (stream RouteNote);</span><br><span class="line">&#125;</span><br><span class="line">// 数据类</span><br><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude = 1;</span><br><span class="line">  int32 longitude = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Rectangle &#123;</span><br><span class="line">  Point p1 = 1;</span><br><span class="line">  Point p2 = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Feature &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  Point location = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FeatureDatabase &#123;</span><br><span class="line">  repeated Feature features = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RouteNote &#123;</span><br><span class="line">  Point location = 1;</span><br><span class="line">  string message = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">  int32 point_count = 1;</span><br><span class="line">  int32 feature_count = 2;</span><br><span class="line">  int32 distance = 3;</span><br><span class="line">  int32 elapsed_time = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="proto编译生成Java类"><a href="#proto编译生成Java类" class="headerlink" title="proto编译生成Java类"></a>proto编译生成Java类</h2><p>Java版本推荐使用maven插件进行编译,<code>os-maven-plugin</code>判断当前运行平台,<code>protobuf-maven-plugin</code>使用对应平台的protoc进行编译</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">protoc.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">protoc.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protoc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:$&#123;grpc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将编译生成的类复制到src的对应目录下即可开始正式进行开发</p>
<h2 id="编写服务代码"><a href="#编写服务代码" class="headerlink" title="编写服务代码"></a>编写服务代码</h2><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  RouteGuideGrpc为编译生成的基础配置类, 我们需要继承并实现RouteGuideImplBase</span></span><br><span class="line"><span class="comment">  没有被继承实现的方法被调用后会向客户端报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteGuideImpl</span> <span class="keyword">extends</span> <span class="title class_">RouteGuideGrpc</span>.RouteGuideImplBase &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建web服务并监听</span></span><br><span class="line"><span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> ServerBuilder</span><br><span class="line">                .forPort(port)</span><br><span class="line">                .addService(<span class="keyword">new</span> <span class="title class_">RouteGuideImpl</span>())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">server.awaitTermination();</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteGuideClient</span> &#123;</span><br><span class="line">	<span class="comment">// 同步调用stub</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteGuideGrpc.RouteGuideBlockingStub blockingStub;</span><br><span class="line">	<span class="comment">// 异步调用stub</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteGuideGrpc.RouteGuideStub stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RouteGuideClient</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        blockingStub = RouteGuideGrpc.newBlockingStub(channel);</span><br><span class="line">        stub = RouteGuideGrpc.newStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ManagedChannel</span> <span class="variable">routeGuideChannel</span> <span class="operator">=</span> ManagedChannelBuilder</span><br><span class="line">				.forTarget(<span class="string">&quot;localhost:25252&quot;</span>) <span class="comment">// target server</span></span><br><span class="line">                .usePlaintext() <span class="comment">// not ssl</span></span><br><span class="line">                .build();</span><br><span class="line"><span class="type">RouteGuideClient</span> <span class="variable">routeGuideClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteGuideClient</span>(routeGuideChannel);</span><br></pre></td></tr></table></figure>

<h3 id="客户端同步请求-服务端单次返回"><a href="#客户端同步请求-服务端单次返回" class="headerlink" title="客户端同步请求,服务端单次返回"></a>客户端同步请求,服务端单次返回</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFeature</span><span class="params">(Point request, StreamObserver&lt;Feature&gt; responseObserver)</span> &#123;</span><br><span class="line">	<span class="comment">// 处理请求</span></span><br><span class="line">	responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line">	<span class="comment">// 处理完成</span></span><br><span class="line">	responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFeature</span><span class="params">(<span class="type">int</span> latitude, <span class="type">int</span> longitude)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 使用阻塞stub直接调用</span></span><br><span class="line">		<span class="type">Feature</span> <span class="variable">feature</span> <span class="operator">=</span> blockingStub.getFeature(Point.newBuilder().build());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		logger.log(Level.WARNING, <span class="string">&quot;getFeature error&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端同步请求-服务端流式返回"><a href="#客户端同步请求-服务端流式返回" class="headerlink" title="客户端同步请求,服务端流式返回"></a>客户端同步请求,服务端流式返回</h3><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFeatures</span><span class="params">(Rectangle request, StreamObserver&lt;Feature&gt; responseObserver)</span> &#123;</span><br><span class="line">	<span class="comment">// 返回流式响应</span></span><br><span class="line">	responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line">	responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line">	responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFeatures</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Iterator&lt;Feature&gt; featureIterator = blockingStub.listFeatures(Rectangle.newBuilder().build());</span><br><span class="line">		<span class="comment">// 用Iterator读取流式数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; featureIterator.hasNext(); ++i) &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		logger.log(Level.WARNING, <span class="string">&quot;listFeatures error&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端流式异步请求-服务端单次返回"><a href="#客户端流式异步请求-服务端单次返回" class="headerlink" title="客户端流式异步请求,服务端单次返回"></a>客户端流式异步请求,服务端单次返回</h3><h4 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StreamObserver&lt;Point&gt; <span class="title function_">recordRoute</span><span class="params">(StreamObserver&lt;RouteSummary&gt; responseObserver)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Point value)</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">// 返回响应</span></span><br><span class="line">            responseObserver.onNext(RouteSummary.newBuilder().build());</span><br><span class="line">			responseObserver.onCompleted();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordRoute</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	<span class="comment">// 异步响应处理</span></span><br><span class="line">	StreamObserver&lt;RouteSummary&gt; responseObserver = <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteSummary value)</span> &#123;</span><br><span class="line">			<span class="comment">// 处理返回值</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 用响应处理器生成请求</span></span><br><span class="line">	StreamObserver&lt;Point&gt; requestObserver = stub.recordRoute(responseObserver);</span><br><span class="line">	<span class="comment">// 流式请求</span></span><br><span class="line">	requestObserver.onNext(Point.newBuilder().build());</span><br><span class="line">	requestObserver.onNext(Point.newBuilder().build());</span><br><span class="line">	requestObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端流式异步请求-服务端流式返回"><a href="#客户端流式异步请求-服务端流式返回" class="headerlink" title="客户端流式异步请求,服务端流式返回"></a>客户端流式异步请求,服务端流式返回</h3><h4 id="服务端-4"><a href="#服务端-4" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StreamObserver&lt;RouteNote&gt; <span class="title function_">routeChat</span><span class="params">(StreamObserver&lt;RouteNote&gt; responseObserver)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteNote value)</span> &#123;</span><br><span class="line">			<span class="comment">// 流式返回</span></span><br><span class="line">			responseObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">			responseObserver.onCompleted();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理服务器返回的响应</span></span><br><span class="line">StreamObserver&lt;RouteNote&gt; responseStreamObserver = <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteNote value)</span> &#123;</span><br><span class="line">		logger.info(value.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">StreamObserver&lt;RouteNote&gt; requestStreamObserver = stub.routeChat(responseStreamObserver);</span><br><span class="line"><span class="comment">// 流式请求</span></span><br><span class="line">requestStreamObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">requestStreamObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">requestStreamObserver.onCompleted();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-06-01-%E4%B8%80%E4%B8%AAredis-session%E7%9A%84%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-06-01-%E4%B8%80%E4%B8%AAredis-session%E7%9A%84%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html" class="post-title-link" itemprop="url">一个redis-session的错误使用示例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-06-01T00:00:00+08:00">2021-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-06 10:24:36" itemprop="dateModified" datetime="2022-04-06T10:24:36+08:00">2022-04-06</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

            <div class="post-description">服务里定时出现的神秘异常</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>某个模块的几个子服务上线后会定时出现如下的异常日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">14:56:00.009 [ing-scheduled-1] [FJNJFVNG] ERROR o.s.s.s.TaskUtils$LoggingErrorHandler    - Unexpected error occurred in scheduled task </span><br><span class="line">org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">	at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:84)</span><br><span class="line">	at org.springframework.data.redis.serializer.SerializationUtils.deserializeValues(SerializationUtils.java:54)</span><br><span class="line">	at org.springframework.data.redis.serializer.SerializationUtils.deserialize(SerializationUtils.java:62)</span><br><span class="line">	at org.springframework.data.redis.core.AbstractOperations.deserializeValues(AbstractOperations.java:223)</span><br><span class="line">	at org.springframework.data.redis.core.DefaultSetOperations.members(DefaultSetOperations.java:216)</span><br><span class="line">	at org.springframework.data.redis.core.DefaultBoundSetOperations.members(DefaultBoundSetOperations.java:152)</span><br><span class="line">	at org.springframework.session.data.redis.RedisSessionExpirationPolicy.cleanExpiredSessions(RedisSessionExpirationPolicy.java:129)</span><br><span class="line">	at org.springframework.session.data.redis.RedisIndexedSessionRepository.cleanupExpiredSessions(RedisIndexedSessionRepository.java:407)</span><br><span class="line">	at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54)</span><br><span class="line">	at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:93)</span><br><span class="line">	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">	at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">	at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:78)</span><br><span class="line">	at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:36)</span><br><span class="line">	at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:82)</span><br><span class="line">	... 16 common frames omitted</span><br><span class="line">Caused by: java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">	at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:937)</span><br><span class="line">	at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:395)</span><br><span class="line">	at org.springframework.core.ConfigurableObjectInputStream.&lt;init&gt;(ConfigurableObjectInputStream.java:65)</span><br><span class="line">	at org.springframework.core.ConfigurableObjectInputStream.&lt;init&gt;(ConfigurableObjectInputStream.java:51)</span><br><span class="line">	at org.springframework.core.serializer.DefaultDeserializer.deserialize(DefaultDeserializer.java:70)</span><br><span class="line">	at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:73)</span><br><span class="line">	... 18 common frames omitted</span><br></pre></td></tr></table></figure>

<h1 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h1><p>根据异常栈底的类名<code>DeserializingConverter</code>大概可以知道是反序列化的问题，但是什么反序列化会定时执行并抛出异常呢？</p>
<p>这个时候我们要看第一个异常栈，从栈底开始，忽略<code>ThreadPoolExecutor</code>等没有逻辑特征的类，往下看</p>
<p>首先是<code>ReschedulingRunnable</code>，是spring定时任务的默认接口，服务中用到定时任务的地方不算多，但是我们不能以此为依据，因为springboot本身也包含很多定时任务</p>
<p>接下来我们看<code>RedisIndexedSessionRepository</code>，找到异常栈中的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanupExpiredSessions</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.expirationPolicy.cleanExpiredSessions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是服务在清理过期的session，继续往下debug可以看到服务使用代码里默认的<code>JdkSerializationRedisSerializer</code>执行redis的member操作检查过期key时产生的反序列化异常</p>
<p>再从异常栈顶往下跟踪，看看哪一步开始可以修改默认的serializer。要注意idea不支持外部库的变量引用查询，在跟踪字段的时候需要文件内搜索</p>
<p>发现在<code>RedisHttpSessionConfiguration</code>中调用了<code>RedisIndexedSessionRepository</code>的<code>setDefaultSerializer()</code>，Configuration在配置类中提供了serializer的注入方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;springSessionDefaultRedisSerializer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDefaultRedisSerializer</span><span class="params">(RedisSerializer&lt;Object&gt; defaultRedisSerializer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaultRedisSerializer = defaultRedisSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在spring配置中注入名为<code>springSessionDefaultRedisSerializer</code>的自定义serializer即可</p>
<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p>spring-session-data-redis和spring-data-redis相对独立，redis客户端的serializer等需要独立配置</p>
<p>RedisHttpSessionConfiguration 本身是一个 Spring 配置类, 会向 Spring 容器注册 sessionRepository, redisMessageListenerContainer 等实例</p>
<p>RedisHttpSessionConfiguration 会注册 Redis 消息监听器容器 RedisMessageListenerContainer, 并将 RedisIndexedSessionRepository 作为 Redis 消息订阅的监听器, 因为它实现了 MessageListener 接口。当 Redis 中 key 过期或销毁时, 会通知将 RedisIndexedSessionRepository 调用其onMessage() 方法来处理消息</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904159091621901">Spring Session Data Redis 源码解析</a></p>
<p>排查问题的时候要灵活阅读异常栈的信息</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-04-07-JavaSE%E5%90%84%E5%A4%A7%E5%8E%82%E5%95%86JDK.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-04-07-JavaSE%E5%90%84%E5%A4%A7%E5%8E%82%E5%95%86JDK.html" class="post-title-link" itemprop="url">Java SE 各大厂商JDK</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-07T00:00:00+08:00">2021-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-08 18:16:36" itemprop="dateModified" datetime="2022-07-08T18:16:36+08:00">2022-07-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

            <div class="post-description">Oracle的JDK和各个厂商、个人的OpenJDK版本</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2022-07-08-UPDATE"><a href="#2022-07-08-UPDATE" class="headerlink" title="2022-07-08 UPDATE"></a>2022-07-08 UPDATE</h1><p>资源站 <a target="_blank" rel="noopener" href="https://www.injdk.cn/">Java I tell you-爪哇我话你知</a></p>
<h1 id="Oracle-JDK"><a href="#Oracle-JDK" class="headerlink" title="Oracle JDK"></a>Oracle JDK</h1><p>Oracle官方的商业JDK，收费。</p>
<h1 id="Oracle-OpenJDK"><a href="#Oracle-OpenJDK" class="headerlink" title="Oracle OpenJDK"></a>Oracle OpenJDK</h1><p>Oracle官方的商业JDK的社区版，免费。</p>
<h1 id="Amazon-Corretto"><a href="#Amazon-Corretto" class="headerlink" title="Amazon Corretto"></a>Amazon Corretto</h1><p>Amazon Corretto 是亚马逊基于 开放Java 开发工具包 (OpenJDK) 的免费、多平台、生产就绪型发行版。Corretto 提供长期支持，其中包括性能增强和安全修复。亚马逊在内部的数千种生产服务上运行 Corretto，并且 Corretto 已被证明能够兼容 Java SE 标准。借助 Corretto，您可以在常用操作系统（包括 Linux、Windows 和 macOS）上开发和运行 Java 应用程序。</p>
<h1 id="BellSoft-Liberica-JDK"><a href="#BellSoft-Liberica-JDK" class="headerlink" title="BellSoft Liberica JDK"></a>BellSoft Liberica JDK</h1><p>OpenJDK 的贡献者之一 BellSoft发布的基于OpenJDK的免费版。</p>
<h1 id="AdoptOpenJDK"><a href="#AdoptOpenJDK" class="headerlink" title="AdoptOpenJDK"></a>AdoptOpenJDK</h1><p>现属于Eclipse基金会的基于OpenJDK发布的免费版本，支持Oracle公司的HotSpot虚拟机和Eclipse基金会的OpenJ9虚拟机。</p>
<h1 id="Azul-Zulu-OpenJDK"><a href="#Azul-Zulu-OpenJDK" class="headerlink" title="Azul Zulu OpenJDK"></a>Azul Zulu OpenJDK</h1><p>Azul 成立于 2002 年，是一家私营软件公司，总部位于加州桑尼维尔，在全球设有销售、技术支持和工程办事处，基于OpenJDK发布，免费。</p>
<h1 id="SAP-SapMachine"><a href="#SAP-SapMachine" class="headerlink" title="SAP SapMachine"></a>SAP SapMachine</h1><p>SAP是OpenJDK项目的贡献者之一，基于OpenJDK发布，免费。</p>
<h1 id="Red-Hat-build-of-OpenJDK"><a href="#Red-Hat-build-of-OpenJDK" class="headerlink" title="Red Hat build of OpenJDK"></a>Red Hat build of OpenJDK</h1><p>Red Hat(红帽子)公司基于OpenJDK发布的免费版。</p>
<h1 id="阿里巴巴Dragonwell-JDK"><a href="#阿里巴巴Dragonwell-JDK" class="headerlink" title="阿里巴巴Dragonwell JDK"></a>阿里巴巴Dragonwell JDK</h1><p>Alibaba Dragonwell 是一款免费的, 生产就绪型Open JDK 发行版，提供长期支持，包括性能增强和安全修复。阿里巴巴拥有最丰富的Java应用场景，覆盖电商，金融，物流等众多领域，世界上最大的Java用户之一。Alibaba Dragonwell作为Java应用的基石，支撑了阿里经济体内所有的Java业务。Alibaba Dragonwell完全兼容 Java SE 标准，您可以在任何常用操作系统（包括 Linux、Windows 和 macOS）上开发 Java 应用程序， 运行时生产环境选择Alibaba Dragonwell。</p>
<h1 id="腾讯Kona-JDK"><a href="#腾讯Kona-JDK" class="headerlink" title="腾讯Kona JDK"></a>腾讯Kona JDK</h1><p>腾讯 Kona（Tencent Kona，TK）是免费、可立即投入生产的 OpenJDK 发行版。腾讯 Kona 基于 TencentJDK 开发，针对云应用场景定制新的功能及优化， 具备更快的云应用启动速度，更好的性能以及更为便捷的分析、诊断工具；此外，腾讯 Kona 服务于腾讯内部大量 Java 应用程序，提供稳定、高效的运行环境。 </p>
<h1 id="华为毕昇JDK"><a href="#华为毕昇JDK" class="headerlink" title="华为毕昇JDK"></a>华为毕昇JDK</h1><p>华为内部OpenJDK定制版的开源版本，是一个高性能、可用于生产环境的OpenJDK发行版。</p>
<p><img src="/../../../../image/jdk_1.png" alt="jdk_1"></p>
<p><img src="/../../../../image/jdk_2.png" alt="jdk_2"></p>
<p><img src="/../../../../image/jdk_3.png" alt="jdk_3"></p>
<hr>
<p>reference</p>
<p><a target="_blank" rel="noopener" href="https://www.huoxiaoqiang.com/java/javahigh/2381.html">6.Java SE 各大厂商JDK大全一览表 | 霍小强博客</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.okta.com/blog/2019/01/16/which-java-sdk">Which Java SDK Should You Use? | Okta Developer</a></p>
<p><a target="_blank" rel="noopener" href="https://snyk.io/blog/36-of-developers-switched-from-oracle-jdk-to-an-alternate-openjdk-distribution-over-the-last-year/">36% of developers switched from Oracle JDK to an alternate OpenJDK distribution, over the last year | Snyk</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hahahaha123567.github.io/2021-03-17-%E9%98%85%E8%AF%BBRocketMQ%E6%BA%90%E7%A0%812.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hahahaha123567">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hahahaha123567">
      <meta itemprop="description" content="niconiconi">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | hahahaha123567">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-03-17-%E9%98%85%E8%AF%BBRocketMQ%E6%BA%90%E7%A0%812.html" class="post-title-link" itemprop="url">阅读RocketMQ源码(2) - 基础通信模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-17 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-17T00:00:00+08:00">2021-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-31 11:27:31" itemprop="dateModified" datetime="2021-12-31T11:27:31+08:00">2021-12-31</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

            <div class="post-description">基础通信模块</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础通信模块"><a href="#基础通信模块" class="headerlink" title="基础通信模块"></a>基础通信模块</h1><p>依赖netty实现,引入了netty-tcnative</p>
<h2 id="协议内容"><a href="#协议内容" class="headerlink" title="协议内容"></a>协议内容</h2><ul>
<li>4byte msg length</li>
<li>1byte serialization type</li>
<li>3byte header length</li>
<li>header</li>
<li>body</li>
</ul>
<h2 id="序列化-x2F-反序列化"><a href="#序列化-x2F-反序列化" class="headerlink" title="序列化&#x2F;反序列化"></a>序列化&#x2F;反序列化</h2><p>在<code>RemotingCommand</code>类的<code>encode()</code>方法中可以看到序列化的过程</p>
<ul>
<li>RocketMQSerializable, 序列化为bytes, 用ByteBuffer实现</li>
<li>RemotingSerializable, 序列化为Json, 用fastjson实现</li>
</ul>
<p>在获取selector时针对Linux特殊处理, 尝试获取<code>sun.nio.ch.EPollSelectorProvider</code>, 笔者使用macOS装有Java1.8 HotSpotJVM, 使用了<code>sun.nio.ch.KQueueSelectorProvider</code></p>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p><img src="/../../../../image/rocketmq_design_3.png" alt="rocketmq_design_3"></p>
<p>在<code>NettyRemotingAbstract</code>类中实现了三种通信方式</p>
<ul>
<li>sync</li>
<li>async</li>
<li>oneway</li>
</ul>
<h2 id="异步请求的流程"><a href="#异步请求的流程" class="headerlink" title="异步请求的流程"></a>异步请求的流程</h2><p><img src="/../../../../image/rocketmq_design_5.png" alt="rocketmq_design_5"></p>
<ol>
<li><p><strong>client</strong> Assemle remotingCommand and generate callbacks (MQClientAPIImpl.sendMessage())</p>
</li>
<li><p><strong>client</strong> create a chennel for communication based on addr (NettyRemotingClient.getAndCreateChannel())</p>
</li>
<li><p><strong>client</strong> Acquisition semaphore (NettyRemotingAbstract.invokeAsyncImpl())</p>
</li>
<li><p><strong>client</strong> give opaque access to ResponseFuture (NettyRemotingAbstract.invokeAsyncImpl())</p>
</li>
<li><p><strong>client</strong> call netty’s channel’s writeAndFlush (NettyRemotingAbstract.invokeAsyncImpl())</p>
</li>
</ol>
<h3 id="serverHandler-receive-and-process-message"><a href="#serverHandler-receive-and-process-message" class="headerlink" title="serverHandler: receive and process message"></a>serverHandler: receive and process message</h3><h3 id="server-the-processMessageReceived-method-process"><a href="#server-the-processMessageReceived-method-process" class="headerlink" title="server: the processMessageReceived method process"></a>server: the processMessageReceived method process</h3><h3 id="server-get-the-corresponding-processor-according-to-the-business-code"><a href="#server-get-the-corresponding-processor-according-to-the-business-code" class="headerlink" title="server: get the corresponding processor according to the business code"></a>server: get the corresponding processor according to the business code</h3><h3 id="server-the-business-processor-executes-and-gets-the-responds-result"><a href="#server-the-business-processor-executes-and-gets-the-responds-result" class="headerlink" title="server: the business processor executes and gets the responds result"></a>server: the business processor executes and gets the responds result</h3><h3 id="server-determines-whether-the-request-is-one-way"><a href="#server-determines-whether-the-request-is-one-way" class="headerlink" title="server: determines whether the request is one-way"></a>server: determines whether the request is one-way</h3><h3 id="server-set-opaque-to-the-response-and-send-it-to-the-client-side"><a href="#server-set-opaque-to-the-response-and-send-it-to-the-client-side" class="headerlink" title="server: set opaque to the response and send it to the client side"></a>server: set opaque to the response and send it to the client side</h3><h3 id="clientHandler-read-the-message-that-netty-receives-and-process"><a href="#clientHandler-read-the-message-that-netty-receives-and-process" class="headerlink" title="clientHandler: read the message that netty receives and process"></a>clientHandler: read the message that netty receives and process</h3><h3 id="client-get-responseFuture-based-on-opaque"><a href="#client-get-responseFuture-based-on-opaque" class="headerlink" title="client: get responseFuture based on opaque"></a>client: get responseFuture based on opaque</h3><h3 id="client-execute-the-callback-method"><a href="#client-execute-the-callback-method" class="headerlink" title="client: execute the callback method"></a>client: execute the callback method</h3><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="获取当前os版本"><a href="#获取当前os版本" class="headerlink" title="获取当前os版本"></a>获取当前os版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p>reference</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#2-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6">2-通信机制 at master · apache&#x2F;rocketmq</a></p>
<p><a target="_blank" rel="noopener" href="https://jaskey.github.io/blog/2016/12/19/rocketmq-network-protocol/">RocketMQ——通信协议 - 薛定谔的风口猪</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hahahaha123567</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">162k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:27</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  





  





</body>
</html>
