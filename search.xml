<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis的key里的大括号会影响指令的路由</title>
      <link href="/2024-03-20-Redis%E7%9A%84key%E9%87%8C%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8C%87%E4%BB%A4%E7%9A%84%E8%B7%AF%E7%94%B1.html"/>
      <url>/2024-03-20-Redis%E7%9A%84key%E9%87%8C%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8C%87%E4%BB%A4%E7%9A%84%E8%B7%AF%E7%94%B1.html</url>
      
        <content type="html"><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>系统压测时发现Redis集群的某个节点出现CPU过高的情况，使用Redis阿里云控制台的[实时TopKey统计]功能发现某一高频写Redis的功能使用的几个key都被路由到了同一个Redis节点，key形如</p><ul><li>{cache}:::table_name:::field1</li><li>{cache}:::table_name:::field2</li></ul><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>阿里云提供了一些文档进行Redis的基本的性能优化 <a href="https://help.aliyun.com/zh/redis/user-guide/performance-optimization/">性能调优_云数据库 Redis 版(Redis)-阿里云帮助中心</a> 但是显然多个高频写的key被路由到同一个节点导致CPU升高的问题不是Redis自身的优化能够解决的</p><p>阿里云的Redis集群是Redis cluster的实现，查询Redis cluster的文档后发现了问题</p><p>关于Redis cluster的简要描述 <a href="https://redis.io/docs/reference/cluster-spec/#overview-of-redis-cluster-main-components">overview-of-redis-cluster-main-components</a> , Redis使用<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC16</a>算法对key进行hash, hash值再对cluster的size取模后决定路由的节点</p><p>使用 <a href="https://redis.io/commands/cluster-keyslot/">CLUSTER KEYSLOT | Redis</a> 命令查询这几个key的hash值都是相等的，为什么？</p><p><a href="https://redis.io/docs/reference/cluster-spec/#hash-tags">hash-tags</a> 哈希标签是一种确保多个键分配在同一个哈希槽中的方法。这用于在 Redis Cluster 中实现多键操作。为了实现哈希标签，在某些条件下，密钥的哈希槽的计算方式略有不同。如果密钥包含“{…}”模式，则仅对和之间的子字符串进行哈希 {处理}以获取哈希槽</p><p>样例里的几个key使用了共同的”{cache}”前缀导致Redis计算hash时只计算了”cache”这5个字符的hash值，导致几个key路由到了同一个节点</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>进行修复时要注意这几个key的读操作和写操作的服务，必要时可以对读服务进行灰度发布，保证旧的key全部被消费、写服务全部更新为新key后再全量发布读服务</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java, Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定位dependencyManagement指定的错误版本</title>
      <link href="/2024-02-23-%E5%AE%9A%E4%BD%8DdependencyManagement%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC.html"/>
      <url>/2024-02-23-%E5%AE%9A%E4%BD%8DdependencyManagement%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>项目引入<code>shardingsphere-jdbc</code>和<code>shardingsphere-cluster-mode-repository-zookeeper</code>后启动报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: org/apache/curator/connection/StandardConnectionHandlingPolicy</span><br><span class="line">at org.apache.curator.framework.CuratorFrameworkFactory$Builder.&lt;init&gt;(CuratorFrameworkFactory.java:147)</span><br><span class="line">at org.apache.curator.framework.CuratorFrameworkFactory$Builder.&lt;init&gt;(CuratorFrameworkFactory.java:130)</span><br><span class="line">at org.apache.curator.framework.CuratorFrameworkFactory.builder(CuratorFrameworkFactory.java:78)</span><br><span class="line">at org.apache.shardingsphere.mode.repository.cluster.zookeeper.ZookeeperRepository.&lt;init&gt;(ZookeeperRepository.java:65)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:380)</span><br><span class="line">... 90 common frames omitted</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.apache.curator.connection.StandardConnectionHandlingPolicy</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:387)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:419)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:352)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:352)</span><br><span class="line">... 100 common frames omitted</span><br></pre></td></tr></table></figure><p>可以看到<code>CuratorFrameworkFactory</code>类中引用的<code>StandardConnectionHandlingPolicy</code>没有被找到</p><p>项目的<code>pom.xml</code>配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mvn-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-cluster-mode-repository-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-cluster-mode-repository-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>shardingsphere-cluster-mode-repository-zookeeper</code>会引入依赖<code>curator-framework</code> <code>curator-client</code> <code>curator-recipes</code></p><h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>按照经验, 出现依赖项冲突后执行<code>mvn dependency:tree &gt; tree</code>后检查依赖树发现了奇怪的现象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[INFO] org.example:mvn-test:jar:1.0.0-SNAPSHOT</span><br><span class="line">[INFO] +- org.apache.shardingsphere:shardingsphere-jdbc-core:jar:5.4.1:compile</span><br><span class="line">[INFO] \- org.apache.shardingsphere:shardingsphere-cluster-mode-repository-zookeeper:jar:5.4.1:compile</span><br><span class="line">[INFO]    +- org.apache.shardingsphere:shardingsphere-cluster-mode-repository-api:jar:5.4.1:compile</span><br><span class="line">[INFO]    +- org.apache.curator:curator-framework:jar:4.0.1:compile</span><br><span class="line">[INFO]    +- org.apache.curator:curator-client:jar:5.5.0:compile</span><br><span class="line">[INFO]    |  \- org.apache.zookeeper:zookeeper:jar:3.7.1:compile</span><br><span class="line">[INFO]    \- org.apache.curator:curator-recipes:jar:4.0.1:compile</span><br></pre></td></tr></table></figure><p>5.4.1版本的<code>shardingsphere-cluster-mode-repository-zookeeper</code>引入的<code>curator-client</code>是正确版本5.5.0, 但是<code>curator-framework</code>和<code>curator-recipes</code>都是错误的旧版本4.0.1</p><p>检查了<code>shardingsphere-cluster-mode-repository-zookeeper</code>的pom文件后确认curator的几个库期望结果应该均为5.5.0</p><p>控制变量法, <code>dependency</code>没有异常的话问题可能出在<code>dependencyManagement</code>中, 删除其他无关依赖项后发现问题出在<code>spring-cloud-dependencies</code>中, 定位具体原因的话需要使用<code>mvn help:effective-pom</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:effective-pom &gt; effective.pom</span><br></pre></td></tr></table></figure><p>输出的文件中, 配置的<code>dependencyManagement</code>会展开, 其中可以发现指定了<code>curator-framework</code>和<code>curator-recipes</code>的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p><code>dependencyManagement</code>不支持exclusion, 需要自己声明所需的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-cluster-mode-repository-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他</p><p>基于springboot的项目引入sharding-jdbc</p><p>5.0-5.2版本官方建议使用<code>shardingsphere-cluster-mode-repository-zookeeper-curator</code></p><p><a href="https://shardingsphere.apache.org/document/5.0.0/cn/user-manual/shardingsphere-jdbc/usage/governance/spring-boot-starter/">使用 Spring Boot Starter :: ShardingSphere</a></p><p>5.3版本开始</p><p><a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/java-api/mode/">模式配置 :: ShardingSphere</a></p><p><a href="https://github.com/apache/shardingsphere/issues/24258">shardingsphere-jdbc-core-spring-boot-starter,When will version 5.3.0 be released? · Issue #24258 · apache&#x2F;shardingsphere</a></p><p>参考</p><p><a href="https://maven.apache.org/plugins/maven-help-plugin/index.html">Apache Maven Help Plugin – Introduction</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java, Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtual Threads虚拟线程(译)</title>
      <link href="/2023-10-07-VirtualThreads%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B(%E8%AF%91).html"/>
      <url>/2023-10-07-VirtualThreads%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B(%E8%AF%91).html</url>
      
        <content type="html"><![CDATA[<p>原文 <a href="https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html">Virtual Threads</a></p><hr><p>Virtual threads 虚拟线程是轻量级的线程，可以减少编写、维护和调试高吞吐量并发应用程序的工作量</p><p>有关 Virtual Threads 的背景信息，请参阅 <a href="https://openjdk.org/jeps/444">JEP 444</a></p><p>thread是可调度的最小处理单元，thread之间同时（并且独立）运行</p><p>thread有两种，Platform Threads 平台线程和 Virtual Threads 虚拟线程</p><h1 id="Platform-Threads-是什么"><a href="#Platform-Threads-是什么" class="headerlink" title="Platform Threads 是什么"></a>Platform Threads 是什么</h1><p>Platform Threads 是操作系统 (OS) 线程的简单封装，在底层OS线程上运行 Java 代码，因此 Platform Threads 的可用数量受限于OS线程的数量</p><p>Platform Threads 通常具有大型线程堆栈和由OS维护的其他资源，适合运行所有类型的任务，但资源有限</p><h1 id="Virtual-Threads-是什么"><a href="#Virtual-Threads-是什么" class="headerlink" title="Virtual Threads 是什么"></a>Virtual Threads 是什么</h1><p>与 Platform Threads 一样，Virtual Threads 也是 java.lang.Thread 的一个实例。 但是，Virtual Threads 并不依赖于特定的OS线程。Virtual Threads 仍然在OS线程上运行，但是当 Virtual Thread 中运行的代码调用阻塞 I&#x2F;O 操作时，Java 运行时会挂起 Virtual Threads，直到可以恢复为止。与挂起的 Virtual Thread 关联的OS线程现在可以自由地为其他 Virtual Threads 执行操作</p><p>Virtual Thread 的实现方式与虚拟内存类似。为了模拟大量内存，操作系统将较大的虚拟地址空间映射到有限的 RAM。同样，为了模拟大量线程，Java运行时将大量 Virtual Threads 映射到少量OS线程。</p><p>与 Platform Thread 不同，Virtual Threads 通常具有浅调用堆栈，只执行单个 HTTP 客户端调用或单个 JDBC 查询。 尽管Virtual Threads 支持线程本地变量和可继承的线程本地变量，但您应该仔细考虑使用它们，因为单个 JVM 可能支持数百万个 Virtual Threads</p><p>Virtual Threads 适合运行大部分时间处于阻塞状态、通常等待 I&#x2F;O 操作完成的任务，不适用于长时间运行的 CPU 密集型操作</p><h1 id="为什么要使用-Virtual-Threads"><a href="#为什么要使用-Virtual-Threads" class="headerlink" title="为什么要使用 Virtual Threads"></a>为什么要使用 Virtual Threads</h1><p>在高并发IO应用程序中使用 Virtual Threads，尤其是那些包含大量并发任务且大部分时间都在等待的应用程序。服务器应用程序是高吞吐量应用程序的示例，因为它们通常处理许多执行阻塞 I&#x2F;O 操作（例如获取资源）的客户端请求</p><p>Virtual Threads 运行代码的速度并不比 Platform Threads 快。 它们的存在是为了提供scale规模（更高的吞吐量），而不是速度（更低的延迟）</p><h1 id="创建并运行-Virtual-Thread"><a href="#创建并运行-Virtual-Thread" class="headerlink" title="创建并运行 Virtual Thread"></a>创建并运行 Virtual Thread</h1><p>Thread 和 Thread.Builder API 提供了创建 Platform Thread 和 Virtual Threads 的方法。</p><p>java.util.concurrent.Executors 类还定义了创建 ExecutorService 的方法，该服务为每个任务启动一个新的 Virtual Threads</p><h2 id="使用-Thread-类和-Thread-Builder-接口创建-Virtual-Threads"><a href="#使用-Thread-类和-Thread-Builder-接口创建-Virtual-Threads" class="headerlink" title="使用 Thread 类和 Thread.Builder 接口创建 Virtual Threads"></a>使用 Thread 类和 Thread.Builder 接口创建 Virtual Threads</h2><p>调用 Thread.ofVirtual() 方法创建 Thread.Builder 实例来创建 Virtual Threads</p><p>以下示例创建并启动一个打印消息的 Virtual Threads。 它调用 join 方法来等待 Virtual Threads 终止（这使您能够在主线程终止之前看到打印的消息）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.ofVirtual().start(() -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure><h3 id="Thread-Builder-接口允许您创建具有常见线程属性（例如线程名称）的线程。-Thread-Builder-OfPlatform-子接口创建-Platform-Threads，而-Thread-Builder-OfVirtual-创建-Virtual-Threads"><a href="#Thread-Builder-接口允许您创建具有常见线程属性（例如线程名称）的线程。-Thread-Builder-OfPlatform-子接口创建-Platform-Threads，而-Thread-Builder-OfVirtual-创建-Virtual-Threads" class="headerlink" title="Thread.Builder 接口允许您创建具有常见线程属性（例如线程名称）的线程。 Thread.Builder.OfPlatform 子接口创建 Platform Threads，而 Thread.Builder.OfVirtual 创建 Virtual Threads"></a>Thread.Builder 接口允许您创建具有常见线程属性（例如线程名称）的线程。 Thread.Builder.OfPlatform 子接口创建 Platform Threads，而 Thread.Builder.OfVirtual 创建 Virtual Threads</h3><p>以下示例使用 Thread.Builder 接口创建一个名为 MyThread 的 Virtual Threads</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Running thread&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> builder.start(task);</span><br><span class="line">System.out.println(<span class="string">&quot;Thread t name: &quot;</span> + t.getName());</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure><p>以下示例使用 Thread.Builder 创建并启动两个 Virtual Threads</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;worker-&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Thread ID: &quot;</span> + Thread.currentThread().threadId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// name &quot;worker-0&quot;</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> builder.start(task);   </span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(t1.getName() + <span class="string">&quot; terminated&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name &quot;worker-1&quot;</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> builder.start(task);   </span><br><span class="line">t2.join();  </span><br><span class="line">System.out.println(t2.getName() + <span class="string">&quot; terminated&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 21</span><br><span class="line">worker-0 terminated</span><br><span class="line">Thread ID: 24</span><br><span class="line">worker-1 terminated</span><br></pre></td></tr></table></figure><h2 id="使用-Executors-newVirtualThreadPerTaskExecutor-方法创建并运行-Virtual-Threads"><a href="#使用-Executors-newVirtualThreadPerTaskExecutor-方法创建并运行-Virtual-Threads" class="headerlink" title="使用 Executors.newVirtualThreadPerTaskExecutor() 方法创建并运行 Virtual Threads"></a>使用 Executors.newVirtualThreadPerTaskExecutor() 方法创建并运行 Virtual Threads</h2><p>Executors 允许您将线程的管理和创建与应用程序的其余部分分开。</p><p>以下示例使用 Executors.newVirtualThreadPerTaskExecutor() 方法创建 ExecutorService。 每当调用 ExecutorService.submit(Runnable) 时，就会创建一个新的 Virtual Thread 并开始运行任务。 该方法返回一个 Future 的实例。 请注意，Future.get() 方法等待线程任务完成。 因此，一旦 Virtual Threads 的任务完成，此示例就会打印一条消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">myExecutor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    Future&lt;?&gt; future = myExecutor.submit(() -&gt; System.out.println(<span class="string">&quot;Running thread&quot;</span>));</span><br><span class="line">    future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;Task completed&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程-Client-Server-示例"><a href="#多线程-Client-Server-示例" class="headerlink" title="多线程 Client Server 示例"></a>多线程 Client Server 示例</h2><p>以下示例由两个类组成。 EchoServer 是一个服务器程序，它监听端口并为每个连接启动一个新的 Virtual Thread</p><p>EchoClient 是一个客户端程序，它连接到服务器并发送在命令行中输入的消息</p><p>EchoClient 创建一个 Socket，从而获得与 EchoServer 的连接。 它在标准输入流上读取用户的输入，然后通过将文本写入 Socket 来将该文本转发到 EchoServer。 EchoServer 通过 Socket 将输入回显给 EchoClient。 EchoClient 读取并显示从服务器传回给它的数据。 EchoServer 可以通过 Virtual Threads 同时为多个客户端提供服务，每个客户端连接一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage: java EchoServer &lt;port&gt;&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">portNumber</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(Integer.parseInt(args[<span class="number">0</span>]));</span><br><span class="line">        ) &#123;                </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">// Accept incoming connections</span></span><br><span class="line">                <span class="comment">// Start a service thread</span></span><br><span class="line">                Thread.ofVirtual().start(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> (</span><br><span class="line">                        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">                        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(clientSocket.getInputStream()));</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        String inputLine;</span><br><span class="line">                        <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            System.out.println(inputLine);</span><br><span class="line">                            out.println(inputLine);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception caught when trying to listen on port &quot;</span></span><br><span class="line">                + portNumber + <span class="string">&quot; or listening for a connection&quot;</span>);</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage: java EchoClient &lt;hostname&gt; &lt;port&gt;&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">portNumber</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">echoSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(hostName, portNumber);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(echoSocket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(echoSocket.getInputStream()));</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">stdIn</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            String userInput;</span><br><span class="line">            <span class="keyword">while</span> ((userInput = stdIn.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                out.println(userInput);</span><br><span class="line">                System.out.println(<span class="string">&quot;echo: &quot;</span> + in.readLine());</span><br><span class="line">                <span class="keyword">if</span> (userInput.equals(<span class="string">&quot;bye&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Don&#x27;t know about host &quot;</span> + hostName);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Couldn&#x27;t get I/O for the connection to &quot;</span> + hostName);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Virtual-Threads-的调度和固定（pin）"><a href="#Virtual-Threads-的调度和固定（pin）" class="headerlink" title="Virtual Threads 的调度和固定（pin）"></a>Virtual Threads 的调度和固定（pin）</h2><p>OS调度 platform threads 何时运行。 但是，Java 运行时会调度 virtual threads 的运行时间。 当Java运行时调度 virtual threads 时，它会在 platform threads 上分配或安装 virtual threads，然后OS照常调度该 platform threads。 该 platform threads 称为 carrier 载体。运行一些代码后，virtual threads 可以从其 carrier 上卸载。 这通常发生在 virtual threads 执行阻塞 I&#x2F;O 操作时。Virtual threads 从其 carrier 上卸载后，carrier 就空闲了，这意味着Java运行时调度程序可以在其上挂载不同的 virtual threads</p><p>当 virtual thread 固定到其 carrier 时，无法在阻塞操作期间卸载该 virtual thread。Virtual threads 在以下情况下被固定</p><ol><li><p>Virtual threads 在同步块或方法内运行代码</p></li><li><p>Virtual threads 运行 native 方法或 foreign 函数（请参阅外部函数和内存 API）</p></li></ol><p>固定不会使应用程序不正确，但可能会妨碍其可扩展性。 尝试通过修改频繁运行的同步块或方法并使用 java.util.concurrent.locks.ReentrantLock 给潜在的长 I&#x2F;O 操作加锁来避免频繁且长期的固定</p><h1 id="Debugging-Virtual-Threads"><a href="#Debugging-Virtual-Threads" class="headerlink" title="Debugging Virtual Threads"></a>Debugging Virtual Threads</h1><p>Virtual Threads 仍然是 thread, debugger 可以像 platform thread 一样单步调试它们。Java Flight Recorder 和 jcmd 工具具有附加功能，可帮助您观察应用程序中的 Virtual Threads</p><h2 id="Virtual-Threads-的-Java-Flight-Recorder-事件"><a href="#Virtual-Threads-的-Java-Flight-Recorder-事件" class="headerlink" title="Virtual Threads 的 Java Flight Recorder 事件"></a>Virtual Threads 的 Java Flight Recorder 事件</h2><p>Java Flight Recorder (JFR) 可以发出与 Virtual Threads 相关的以下事件：</p><ul><li><p>jdk.VirtualThreadStart 和 jdk.VirtualThreadEnd 指示 Virtual Threads 何时开始和结束。 默认情况下禁用这些事件。</p></li><li><p>jdk.VirtualThreadPinned 指示 Virtual Threads 被固定（并且其载体线程未释放）的时间超过阈值持续时间。 默认情况下启用此事件，阈值为 20 毫秒。</p></li><li><p>jdk.VirtualThreadSubmitFailed 表示启动或取消停放 Virtual Threads 失败，可能是由于资源问题。 停放 Virtual Threads 会释放底层承载线程以执行其他工作，而取消停放 Virtual Threads 会安排其继续。 该事件默认启用。</p></li></ul><p>通过 JDK Mission Control 或使用自定义 JFR 配置启用事件 jdk.VirtualThreadStart 和 jdk.VirtualThreadEnd，如 Java 平台标准版 Flight Recorder API 程序员指南中的 Flight Recorder 配置中所述。</p><p>要打印这些事件，请运行以下命令，其中recording.jfr 是录制文件的文件名：</p><p>jfr print –events jdk.VirtualThreadStart,jdk.VirtualThreadEnd,jdk.VirtualThreadPinned,jdk.VirtualThreadSubmitFailed recording.jfr</p><h2 id="查看-jcmd-线程-dump-中的-virtual-threads"><a href="#查看-jcmd-线程-dump-中的-virtual-threads" class="headerlink" title="查看 jcmd 线程 dump 中的 virtual threads"></a>查看 jcmd 线程 dump 中的 virtual threads</h2><p>您可以以纯文本和 JSON 格式创建线程dump：</p><p>jcmd <PID> Thread.dump_to_file -format&#x3D;text <file></p><p>jcmd <PID> Thread.dump_to_file -format&#x3D;json <file></p><p>jcmd 线程转储列出了网络 I&#x2F;O 操作中被阻塞的 virtual threads 以及 ExecutorService 接口创建的 virtual threads。 它不包括对象地址、锁、JNI 统计信息、堆统计信息以及传统线程dump中出现的其他信息</p><h1 id="Virtual-Threads-采用指南"><a href="#Virtual-Threads-采用指南" class="headerlink" title="Virtual Threads 采用指南"></a>Virtual Threads 采用指南</h1><p>Virtual Threads 是由 Java 运行时而不是OS实现的 Java 线程。Virtual Threads 和传统线程（我们称之为 Platform Threads）之间的主要区别在于，我们可以轻松地在同一个 Java 进程中运行大量活动 Virtual Threads，甚至数百万个。Virtual Threads 的数量众多，赋予了 Virtual Threads 强大的力量：通过允许服务器同时处理更多请求，它们可以更有效地运行以 thread-per-request 风格编写的服务器应用程序，从而提高吞吐量并减少硬件浪费。</p><p>由于 Virtual Threads 是 java.lang.Thread 的实现，并且遵守自 Java SE 1.0 以来指定 java.lang.Thread 的相同规则，因此开发人员无需学习新概念即可使用它们。 然而，由于无法生成大量 Platform Threads （多年来 Java 中唯一可用的线程实现），已经产生了旨在应对其高成本的实践。 这些做法在应用于 Virtual Threads 时会适得其反，必须摒弃。 此外，成本上的巨大差异提供了一种新的思考线程的方式，而这些线程一开始可能是陌生的。</p><p>本指南无意全面涵盖 Virtual Threads 的每个重要细节。 其目的只是提供一套介绍性指南，以帮助那些希望开始使用 Virtual Threads 的人充分利用它们。</p><h2 id="使用阻塞-I-x2F-O-API-以-thread-per-request-的方式编写简单的同步代码"><a href="#使用阻塞-I-x2F-O-API-以-thread-per-request-的方式编写简单的同步代码" class="headerlink" title="使用阻塞 I&#x2F;O API 以 thread-per-request 的方式编写简单的同步代码"></a>使用阻塞 I&#x2F;O API 以 thread-per-request 的方式编写简单的同步代码</h2><p>Virtual Threads 可以显著提高以 thread-per-request 风格编写的服务器的吞吐量（而不是延迟）。 在这种风格中，服务器专用一个线程在整个持续时间内处理每个传入请求。 它至少专用一个线程，因为在处理单个请求时，您可能希望使用更多线程来同时执行某些任务。</p><p>阻塞 Platform Threads 的成本很高，因为它保留了线程（一种相对稀缺的资源），而它没有做太多有意义的工作。 因为 Virtual Threads 可能很丰富，所以阻塞它们是廉价的并且值得鼓励。 因此，您应该以简单的同步风格编写代码并使用阻塞 I&#x2F;O API</p><p>例如，以下以非阻塞异步风格编写的代码不会从 Virtual Threads 中受益太多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(info::getUrl, pool)</span><br><span class="line">   .thenCompose(url -&gt; getBodyAsync(url, HttpResponse.BodyHandlers.ofString()))</span><br><span class="line">   .thenApply(info::findImage)</span><br><span class="line">   .thenCompose(url -&gt; getBodyAsync(url, HttpResponse.BodyHandlers.ofByteArray()))</span><br><span class="line">   .thenApply(info::setImageData)</span><br><span class="line">   .thenAccept(<span class="built_in">this</span>::process)</span><br><span class="line">   .exceptionally(t -&gt; &#123; t.printStackTrace(); <span class="keyword">return</span> <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure><p>另一方面，以下以同步风格编写并使用简单阻塞 IO 的代码将受益匪浅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">page</span> <span class="operator">=</span> getBody(info.getUrl(), HttpResponse.BodyHandlers.ofString());</span><br><span class="line">   <span class="type">String</span> <span class="variable">imageUrl</span> <span class="operator">=</span> info.findImage(page);</span><br><span class="line">   <span class="type">byte</span>[] data = getBody(imageUrl, HttpResponse.BodyHandlers.ofByteArray());   </span><br><span class="line">   info.setImageData(data);</span><br><span class="line">   process(info);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">   t.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类代码也更容易在调试器中调试、在分析器中分析或通过线程dump进行观察。要观察 virtual thread，请使用 jcmd 命令创建线程dump：</p><p><code>jcmd &lt;pid&gt; Thread.dump_to_file -format=json &lt;文件&gt;</code></p><p>以这种方式编写的堆栈越多， virtual threads 的性能和可观察性就越好。 以其他风格编写的程序或框架，如果每个任务没有专用一个线程，则不应期望从  virtual threads 中获得显著的好处。 避免将同步、阻塞代码与异步框架混合</p><h2 id="将每个并发任务表示为一个-Virtual-Thread-不池化-Virtual-Threads"><a href="#将每个并发任务表示为一个-Virtual-Thread-不池化-Virtual-Threads" class="headerlink" title="将每个并发任务表示为一个 Virtual Thread, 不池化 Virtual Threads"></a>将每个并发任务表示为一个 Virtual Thread, 不池化 Virtual Threads</h2><p>关于 Virtual Threads 最难理解的事情是，虽然它们具有与 Platform Threads 相同的行为，但它们不应该代表相同的程序概念</p><p> Platform Threads 稀缺，因此是宝贵的资源。 宝贵的资源需要管理，管理 Platform Threads 最常见的方法是使用线程池。 然后您需要回答的一个问题是，池中应该有多少个线程？</p><p>但 Virtual Threads 非常丰富，因此每个 Virtual Threads 不应代表某些共享的、池化的资源，而应代表一个任务。 线程从托管资源转变为应用程序域对象。 我们应该有多少个 Virtual Threads 的问题变得显而易见，就像我们应该使用多少个字符串在内存中存储一组用户名的问题一样显而易见：在您的应用程序中，Virtual Threads 的数量始终等于并发任务的数量</p><p>将 n 个平台线程转换为 n 个 Virtual Threads 不会产生什么好处；相反，它是需要转换的任务</p><p>要将每个应用程序任务表示为一个线程，请不要使用共享线程池执行器，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;ResultA&gt; f1 = sharedThreadPoolExecutor.submit(task1);</span><br><span class="line">Future&lt;ResultB&gt; f2 = sharedThreadPoolExecutor.submit(task2);</span><br><span class="line"><span class="comment">// ... use futures</span></span><br></pre></td></tr></table></figure><p>相反，请使用 Virtual Threads 执行器，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">   Future&lt;ResultA&gt; f1 = executor.submit(task1);</span><br><span class="line">   Future&lt;ResultB&gt; f2 = executor.submit(task2);</span><br><span class="line">   <span class="comment">// ... use futures</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码仍然使用 ExecutorService，但从 Executors.newVirtualThreadPerTaskExecutor() 返回的 service 不使用线程池。 相反，它为每个提交的任务创建一个新的 Vritual Thread</p><p>此外，ExecutorService 本身是轻量级的，我们可以像创建任何简单对象一样创建一个新的。这使我们能够依赖新添加的 ExecutorService.close() 方法和 try-with-resources 构造。 在 try 块末尾隐式调用的 close 方法将自动等待提交给 ExecutorService 的所有任务（即 ExecutorService 生成的所有 Virtual Threads）终止</p><p>对于扇出（fanout）场景来说，这是一种特别有用的模式，在这种场景中，您希望同时对不同的服务执行多个传出调用，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Request request, Response response)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">url1</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">var</span> <span class="variable">url2</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">future1</span> <span class="operator">=</span> executor.submit(() -&gt; fetchURL(url1));</span><br><span class="line">        <span class="type">var</span> <span class="variable">future2</span> <span class="operator">=</span> executor.submit(() -&gt; fetchURL(url2));</span><br><span class="line">        response.send(future1.get() + future2.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">        response.fail(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">fetchURL</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> url.openStream()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(in.readAllBytes(), StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，您应该为即使是小型、短期的并发任务创建一个新的 Vritual Thread</p><p>为了获得更多帮助编写扇出（fanout）模式和其他常见并发模式，并具有更好的可观察性，请使用结构化并发（structured concurrency）</p><p>根据经验，如果您的应用程序从未拥有 10,000 个或更多 Vritual Threads，则它不太可能从 Vritual Threads 中受益。 要么它的负载太轻而需要更高的吞吐量，要么您没有向 Vritual Threads 表示足够多的任务</p><h2 id="用-Semaphores-限制并发"><a href="#用-Semaphores-限制并发" class="headerlink" title="用 Semaphores 限制并发"></a>用 Semaphores 限制并发</h2><p>有时需要限制某个操作的并发数。 例如，某些外部服务可能无法处理超过 10 个并发请求。 由于 Platform Threads 是一种宝贵的资源，通常在池中进行管理，因此线程池已经变得如此普遍，以至于它们被用于限制并发的目的，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">...</span><br><span class="line">Result <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">fut</span> <span class="operator">=</span> es.submit(() -&gt; callLimitedService());</span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例确保有限服务最多有 10 个并发请求</p><p>但限制并发只是线程池操作的副作用。 池旨在共享稀缺资源，而 Virtual Threads 并不稀缺，因此永远不应该池化！</p><p>使用 Virtual Threads 时，如果要限制访问某些服务的并发性，则应该使用专门为此目的设计的构造：Semaphore 类。 下面的例子演示了这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line">...</span><br><span class="line">Result <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> callLimitedService();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 foo 的线程将被阻塞，因此一次只有 10 个线程可以取得进展，而其他线程将不受阻碍地继续自己的业务</p><p>简单地使用信号量阻塞某些 Virtual Threads 可能看起来与将任务提交到固定线程池有很大不同，但事实并非如此。 将任务提交到线程池会将它们排队以供稍后执行，但内部信号量（或与此相关的任何其他阻塞同步构造）会创建一个在其上阻塞的线程队列，该队列镜像等待池线程执行的任务队列来执行。 因为 Virtual Threads 是任务，所以结果结构是等效的</p><p><img src="https://docs.oracle.com/en/java/javase/21/core/img/java-core-libraries-virtual-threads-thread-pool-and-semaphore.png" alt="线程池与信号量的比较"></p><p>尽管您可以将 Platform Threads 池视为处理从队列中提取的任务的工作人员，并将 Virtual Threads 视为任务本身，在它们可以继续之前被阻塞，但计算机中的底层表示实际上是相同的。 认识排队任务和阻塞线程之间的等效性将帮助您充分利用 Virtual Threads</p><p>数据库连接池本身充当信号量。 连接池限制为十个连接将阻止第十一个线程尝试获取连接。 无需在连接池之上添加额外的信号量</p><h2 id="不要在线程局部变量中缓存昂贵的可重用对象"><a href="#不要在线程局部变量中缓存昂贵的可重用对象" class="headerlink" title="不要在线程局部变量中缓存昂贵的可重用对象"></a>不要在线程局部变量中缓存昂贵的可重用对象</h2><p>Virtual Threads 支持线程局部变量，就像平台线程一样。 有关详细信息，请参阅线程局部变量。 通常，线程局部变量用于将一些特定于上下文的信息与当前运行的代码关联起来，例如当前事务和用户ID。 对于 Virtual Threads 来说，线程局部变量的使用是完全合理的。 但是，请考虑使用更安全、更有效的范围值。 有关详细信息，请参阅范围值。</p><p>线程局部变量的另一种用途与 Virtual Threads 根本上是不一致的：缓存可重用对象。 这些对象的创建成本通常很高（并且消耗大量内存），并且是可变的，并且不是线程安全的。 它们被缓存在线程局部变量中，以减少它们实例化的次数以及它们在内存中的实例数量，但它们可以被线程上不同时间运行的多个任务重用。</p><p>例如，SimpleDateFormat 的实例创建成本很高，而且不是线程安全的。 出现的一种模式是将此类实例缓存在 ThreadLocal 中，如下例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; cachedFormatter = ThreadLocal.withInitial(SimpleDateFormat::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">        cachedFormatter.get().format(...);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅当线程（以及因此在线程本地缓存的昂贵对象）被多个任务共享和重用时（就像平台线程被池化时的情况一样），这种缓存才有用。 许多任务在线程池中运行时可能会调用 foo，但由于池中仅包含几个线程，因此该对象只会被实例化几次（每个池线程一次）并被缓存和重用。</p><p>但是，Virtual Threads 永远不会被池化，也不会被不相关的任务重用。 因为每个任务都有自己的 Virtual hreads ，所以每次从不同任务调用 foo 都会触发新 SimpleDateFormat 的实例化。 而且，由于可能有大量的 Virtual Threads 同时运行，昂贵的对象可能会消耗相当多的内存。 这些结果与线程本地缓存想要实现的结果恰恰相反。</p><p>没有提供单一的通用替代方案，但对于 SimpleDateFormat，您应该将其替换为 DateTimeFormatter，DateTimeFormatter 是不可变的，因此单个实例可以由所有线程共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter….;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">        formatter.format(...);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，使用线程局部变量来缓存共享的昂贵对象有时是由异步框架在幕后完成的，其隐含的假设是它们由极少数池线程使用。 这就是为什么混合 Virtual Threads 和异步框架不是一个好主意的原因之一：对方法的调用可能会导致在本来要缓存和共享的线程局部变量中实例化昂贵的对象</p><h2 id="避免长时间和频繁的固定"><a href="#避免长时间和频繁的固定" class="headerlink" title="避免长时间和频繁的固定"></a>避免长时间和频繁的固定</h2><p>当前 Virtual Threads 实现的一个限制是，在同步块或方法内执行阻塞操作会导致 JDK 的 Virtual Threads 调度程序阻塞宝贵的OS线程，而如果阻塞操作是在同步块之外完成则不会，我们称这种情况为“固定”。 如果阻塞操作既长期又频繁，则固定可能会对服务器的吞吐量产生不利影响。 保护短期操作（例如内存中操作）或使用同步块或方法的不频繁操作应该不会产生不利影响。</p><p>为了检测可能有害的固定实例，（JDK Flight Recorder (JFR) 在固定阻塞操作时发出 jdk.VirtualThreadPinned 线程；默认情况下，当操作时间超过 20 毫秒时启用此事件</p><p>或者，您可以使用系统属性 jdk.tracePinnedThreads 在线程被固定时阻塞时发出堆栈跟踪。 使用选项 -Djdk.tracePinnedThreads&#x3D;full 运行会在线程被固定时阻塞时打印完整的堆栈跟踪，突出显示本机帧和持有监视器的帧。 使用选项 -Djdk.tracePinnedThreads&#x3D;short 运行将输出限制为仅有问题的帧。</p><p>如果这些机制检测到固定既长期又频繁的地方，请在这些特定地方将同步的使用替换为 ReentrantLock（同样，无需在保护短期或不频繁操作的地方替换同步）。 以下是长期且频繁使用同步块的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lockObj) &#123;</span><br><span class="line">    frequentIO();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以将其替换为以下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    frequentIO();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> JDK21 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtual Threads背景和影响</title>
      <link href="/2023-09-27-VirtualThreads%E8%83%8C%E6%99%AF%E5%92%8C%E5%BD%B1%E5%93%8D.html"/>
      <url>/2023-09-27-VirtualThreads%E8%83%8C%E6%99%AF%E5%92%8C%E5%BD%B1%E5%93%8D.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="JEP-JDK-Enhancement-Proposals-推进"><a href="#JEP-JDK-Enhancement-Proposals-推进" class="headerlink" title="JEP(JDK Enhancement Proposals)推进"></a>JEP(JDK Enhancement Proposals)推进</h2><p>将虚拟线程引入Java 平台。虚拟线程是轻量级线程，可以显著减少编写、维护和观察高吞吐量并发应用程序的工作量</p><ul><li><p>使以简单的每个请求线程风格编写的服务器应用程序能够以接近最佳的硬件利用率进行扩展</p></li><li><p>使使用 java.lang.Thread API 的现有代码能够以最小的更改采用虚拟线程</p></li><li><p>使用现有 JDK 工具轻松进行虚拟线程故障排除、调试和分析</p></li></ul><p>2022-09-20 Java19发布, virtual threads作为preview功能发布 <a href="https://openjdk.org/jeps/425">https://openjdk.org/jeps/425</a></p><p>2023-03-21 Java20发布, virtual threads作为second preview预览功能发布 <a href="https://openjdk.org/jeps/436">https://openjdk.org/jeps/436</a></p><p>2023-09-19 Java21(LTS)发布, virtual threads正式发布 <a href="https://openjdk.org/jeps/444">https://openjdk.org/jeps/444</a></p><h2 id="Loom"><a href="#Loom" class="headerlink" title="Loom"></a>Loom</h2><p>Loom 是一个OpenJDK的项目，旨在探索、孵化和交付构建在其之上的 Java VM 功能和 API，以支持 Java 平台上易于使用、高吞吐量的轻量级并发和新的编程模型</p><p>主要包含2部分</p><ol><li><p>Virtual threads</p></li><li><p>Structured concurrency</p></li></ol><p><a href="https://wiki.openjdk.org/display/loom">https://wiki.openjdk.org/display/loom</a></p><h2 id="Structured-Concurrency-结构化并发"><a href="#Structured-Concurrency-结构化并发" class="headerlink" title="Structured Concurrency 结构化并发"></a>Structured Concurrency 结构化并发</h2><p>通过引入结构化并发 API 来简化并发编程。结构化并发将在不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消、提高可靠性并增强可观察性</p><p>2022-09-20 Java19发布, structured concurrency作为Incubator开始孵化 <a href="https://openjdk.org/jeps/428">https://openjdk.org/jeps/428</a></p><p>2023-03-21 Java20发布, structured concurrency作为Second Incubator <a href="https://openjdk.org/jeps/437">https://openjdk.org/jeps/437</a></p><p>2023-09-19 Java21(LTS)发布, structured concurrency作为preview功能发布 <a href="https://openjdk.org/jeps/453">https://openjdk.org/jeps/453</a></p><h1 id="对开发的影响"><a href="#对开发的影响" class="headerlink" title="对开发的影响"></a>对开发的影响</h1><h2 id="框架开发or应用开发"><a href="#框架开发or应用开发" class="headerlink" title="框架开发or应用开发"></a>框架开发or应用开发</h2><p>对于使用线程或并行的库和框架来说，将是一件大事。库作者能够实现巨大的性能和可扩展性提升，同时简化代码库，使其更易维护。大多数使用线程池和平台线程的 Java 项目都能够从切换至虚拟线程的过程中受益，候选项目包括 Tomcat、Undertow 和 Netty 这样的 Java 服务器软件，以及 Spring 和 Micronaut 这样的 Web 框架</p><p>不会对普通的 Java 开发人员产生太大的影响，因为这些开发人员可能正在使用某些库来处理并发的场景。但是，在一些比较罕见的场景中，比如你可能进行了大量的多线程操作但是没有使用库，那么这些特性就是很有价值的了。虚拟线程可以毫不费力地替代你现在使用的线程池。根据现有的基准测试，在大多数情况下它们都能提高性能和可扩展性</p><p><a href="https://www.infoq.cn/article/wg5qybla1ps222larj3y">https://www.infoq.cn/article/wg5qybla1ps222larj3y</a></p><h2 id="库依赖版本"><a href="#库依赖版本" class="headerlink" title="库依赖版本"></a>库依赖版本</h2><p><a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions</a></p><p><a href="https://stackoverflow.com/questions/42659920/is-there-a-compatibility-matrix-of-spring-boot-and-spring-cloud">https://stackoverflow.com/questions/42659920/is-there-a-compatibility-matrix-of-spring-boot-and-spring-cloud</a></p><h2 id="VS-反应式编程"><a href="#VS-反应式编程" class="headerlink" title="VS 反应式编程"></a>VS 反应式编程</h2><p>对于应用开发者来说，Virtual Threads 和 Reactive 的目的一样，都是对于IO密集型服务，通过提高CPU的使用率来实现提高服务的吞吐量</p><p>在Virtual Threads没有作为JEPS正式提出前，知乎上就有一些讨论，大部分人认为 Virtual Threads 这样将负担交给JVM的方式更好，而不是自己组织Reactive代码写回调</p><ul><li><p>Oracle的Reactive驱动ADBA停止开发，现在使用较多的MySQL Reactive驱动是Spring主导开发的R2DBC</p></li><li><p>loom的tech lead认为正确的方向是”Code like sync, works like async”</p></li></ul><p><a href="https://www.zhihu.com/question/67579790">如何看待Project Loom? - 知乎</a></p><p><a href="https://www.zhihu.com/question/375996978">对于后端开发，响应式编程真的是大势所趋吗？ - 知乎</a></p><h1 id="其他语言的coroutine"><a href="#其他语言的coroutine" class="headerlink" title="其他语言的coroutine"></a>其他语言的coroutine</h1><h2 id="go的goroutine"><a href="#go的goroutine" class="headerlink" title="go的goroutine"></a>go的goroutine</h2><p><a href="https://colobu.com/2016/06/27/dive-into-go-8/">深入Go语言 - 8 - colobu.com</a></p><p><a href="https://colobu.com/2016/04/19/Scheduler-Tracing-In-Go/">Go 调度器跟踪 - colobu.com</a></p><p>Go所有线程都是”虚拟线程”</p><p>Java兼容GUI、Android，Virtual Thread是Thread的子类，支持手动指定Virtual Thread pin到 Platform Thread的逻辑</p><h2 id="kotlin的coroutine"><a href="#kotlin的coroutine" class="headerlink" title="kotlin的coroutine"></a>kotlin的coroutine</h2><p><a href="https://kotlinlang.org/docs/coroutines-overview.html">Coroutines | Kotlin Documentation - kotlinlang.org</a></p><hr><p>参考文章</p><p><a href="https://juejin.cn/post/7280746515526058038">Java21手册（一）：虚拟线程 Virtual Threads - 掘金 - juejin.cn</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> JDK21 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lombok的@Builder使用避雷</title>
      <link href="/2023-07-12-%E4%BD%BF%E7%94%A8lombok%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html"/>
      <url>/2023-07-12-%E4%BD%BF%E7%94%A8lombok%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>新项目的mybatis反序列化报错, Enum类型的字段, 在mapper中指定了typeHandler但是未生效, 报错内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column &#x27;account&#x27; from result set.  Cause: java.lang.IllegalArgumentException: No enum constant com.billing.api.enums.TenantAccountEnum.0</span><br><span class="line">at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:96)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)</span><br><span class="line">at com.sun.proxy.$Proxy141.selectOne(Unknown Source)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate.selectOne(SqlSessionTemplate.java:160)</span><br><span class="line">at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:87)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86)</span><br><span class="line">at com.sun.proxy.$Proxy148.selectBySourceModuleExtendId(Unknown Source)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)</span><br><span class="line">at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212)</span><br><span class="line">at com.sun.proxy.$Proxy149.selectBySourceModuleExtendId(Unknown Source)</span><br><span class="line">at com.billing.provider.service.impl.BillServiceImpl.selectBySourceModuleExtendId(BillServiceImpl.java:25)</span><br><span class="line">at com.billing.provider.service.BillServiceTest.create(BillServiceTest.java:26)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)</span><br><span class="line">at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)</span><br><span class="line">at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)</span><br><span class="line">at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</span><br><span class="line">at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</span><br><span class="line">at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</span><br><span class="line">at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</span><br><span class="line">at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)</span><br><span class="line">at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)</span><br><span class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:137)</span><br><span class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:115)</span><br><span class="line">at org.junit.vintage.engine.execution.RunnerExecutor.execute(RunnerExecutor.java:40)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)</span><br><span class="line">at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)</span><br><span class="line">at java.util.Iterator.forEachRemaining(Iterator.java:116)</span><br><span class="line">at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)</span><br><span class="line">at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)</span><br><span class="line">at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)</span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)</span><br><span class="line">at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)</span><br><span class="line">at org.junit.vintage.engine.VintageTestEngine.executeAllChildren(VintageTestEngine.java:80)</span><br><span class="line">at org.junit.vintage.engine.VintageTestEngine.execute(VintageTestEngine.java:71)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)</span><br><span class="line">at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71)</span><br><span class="line">at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)</span><br><span class="line">at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:221)</span><br><span class="line">at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)</span><br><span class="line">Caused by: org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column &#x27;account&#x27; from result set.  Cause: java.lang.IllegalArgumentException: No enum constant com.billing.api.enums.TenantAccountEnum.0</span><br><span class="line">at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:87)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.createUsingConstructor(EnumResultSetHandler.java:705)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.createByConstructorSignature(EnumResultSetHandler.java:688)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.createResultObject(EnumResultSetHandler.java:652)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.createResultObject(EnumResultSetHandler.java:625)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.getRowValue(EnumResultSetHandler.java:375)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.handleRowValuesForSimpleResultMap(EnumResultSetHandler.java:332)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.handleRowValues(EnumResultSetHandler.java:306)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.handleResultSet(EnumResultSetHandler.java:279)</span><br><span class="line">at com.middleware.mysql.common.EnumResultSetHandler.handleResultSets(EnumResultSetHandler.java:172)</span><br><span class="line">at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:65)</span><br><span class="line">at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79)</span><br><span class="line">at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63)</span><br><span class="line">at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:325)</span><br><span class="line">at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156)</span><br><span class="line">at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109)</span><br><span class="line">at com.github.pagehelper.PageInterceptor.intercept(PageInterceptor.java:151)</span><br><span class="line">at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:62)</span><br><span class="line">at com.sun.proxy.$Proxy230.query(Unknown Source)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.apache.ibatis.plugin.Invocation.proceed(Invocation.java:49)</span><br><span class="line">at com.middleware.mysql.common.MybatisLogInterceptor.intercept(MybatisLogInterceptor.java:143)</span><br><span class="line">at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:62)</span><br><span class="line">at com.sun.proxy.$Proxy230.query(Unknown Source)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.apache.ibatis.plugin.Invocation.proceed(Invocation.java:49)</span><br><span class="line">at com.middleware.mysql.common.EnumInterceptor.intercept(EnumInterceptor.java:66)</span><br><span class="line">at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:62)</span><br><span class="line">at com.sun.proxy.$Proxy230.query(Unknown Source)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:151)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:145)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:76)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:427)</span><br><span class="line">... 68 more</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: No enum constant com.billing.api.enums.TenantAccountEnum.0</span><br><span class="line">at java.lang.Enum.valueOf(Enum.java:238)</span><br><span class="line">at org.apache.ibatis.type.EnumTypeHandler.getNullableResult(EnumTypeHandler.java:49)</span><br><span class="line">at org.apache.ibatis.type.EnumTypeHandler.getNullableResult(EnumTypeHandler.java:26)</span><br><span class="line">at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:85)</span><br><span class="line">... 111 more</span><br></pre></td></tr></table></figure><p>数据库中 <code>account</code> 为0的数据本应使用自定义的typeHandler转换为 <code>TenantAccountEnum</code> 的一个类型, 但是自定义的typeHandler未生效</p><h1 id="排查流程"><a href="#排查流程" class="headerlink" title="排查流程"></a>排查流程</h1><p>检查mybatis的配置项, typeHandler所在目录正常配置, 且mapper中显示指定了类的完整路径</p><p>打断点排查, 发现并不是在反序列化<code>account</code>字段时产生的异常, 而是在sql执行完, 创建目标对象时产生的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; resultType = resultMap.getType();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MetaClass</span> <span class="variable">metaType</span> <span class="operator">=</span> MetaClass.forClass(resultType, reflectorFactory);</span><br><span class="line">    <span class="keyword">final</span> List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span><br><span class="line">    <span class="keyword">if</span> (hasTypeHandlerForResultObject(rsw, resultType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!constructorMappings.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123;</span><br><span class="line">        <span class="keyword">return</span> objectFactory.create(resultType);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Do not know how to create an instance of &quot;</span> + resultType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 框架尝试用反射创建该对象的一个实例, 在其中一步判断<code>metaType.hasDefaultConstructor()</code>时, 代理对象返回false导致没有使用空构造函数新建实例, 后续使用反射新建实例时框架没有使用mapper中配置的typeHandler导致抛出异常</p><p>对象使用了lombok的<code>@Data</code>注解为什么会没有空构造函数?</p><p>因为又使用了<code>@Builder</code>注解</p><h1 id="lombok的这几个对象注解"><a href="#lombok的这几个对象注解" class="headerlink" title="lombok的这几个对象注解"></a>lombok的这几个对象注解</h1><p>TODO</p><p><a href="https://mp.weixin.qq.com/s/yp-lvB9A5dVBrsBT3XkICA">请谨慎使用 @Builder 注解！</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encoding</title>
      <link href="/2022-12-15-%E3%80%8A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E3%80%8B%E7%AC%94%E8%AE%B0.html"/>
      <url>/2022-12-15-%E3%80%8A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E3%80%8B%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h1><p>字符集：字符的集合</p><p>字符编码：字符集中的字符映射到数字序列的方式</p><h1 id="为什么计算机需要编码"><a href="#为什么计算机需要编码" class="headerlink" title="为什么计算机需要编码"></a>为什么计算机需要编码</h1><ul><li>磁盘使用凸起&#x2F;凹陷存储数据</li><li>内存使用有电荷&#x2F;无电荷</li><li>显示器不同颜色的二极管分别亮或灭</li></ul><p>二进制是为了处理这些情况抽象出来的数学逻辑</p><h1 id="字的编码"><a href="#字的编码" class="headerlink" title="字的编码"></a>字的编码</h1><ul><li>字形码: 屏幕上最终展示的字</li><li>机内码: 计算机内部存储的字符格式</li></ul><p>字形码&#x3D;机内码+字体, 换句话说, 机内码是对字形码的一种压缩</p><h1 id="字符编码演化"><a href="#字符编码演化" class="headerlink" title="字符编码演化"></a>字符编码演化</h1><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>一个字节，最高位0，剩下7位表示127个字符，控制字符和英文数字字符</p><h2 id="ISO-8859系列"><a href="#ISO-8859系列" class="headerlink" title="ISO-8859系列"></a>ISO-8859系列</h2><p>ASCII+欧洲字符</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>一套字符编码体系，涵盖抽象字符集、编号、逻辑编码、编码实现</p><p>可以容纳世界上所有国家的文字和符号，其编号范围是0-0x10FFFF，有1,114,112个码位，现已定义的码位有238,605个</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>Unicode最开始设计位双字节编码，固定16位表示一个字符，后来发现不够用，修改为变长编码，常用字符使用2字节，不常用字符使用4字节</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8是变长编码，范围1-4字节</p><p>UTF-16不兼容ASCII，UTF-8兼容ASCII</p><h2 id="GB系列"><a href="#GB系列" class="headerlink" title="GB系列"></a>GB系列</h2><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>双字节编码，两个大于 127 的字节连在一起来共同表示一个汉字</p><p>由__区位码__和__国标码__组成</p><p>可容纳字符数过少</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>国标扩展</p><p>双字节编码，字符数&#x3D;2*GB2312</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>强制性标准，现在在中国大陆销售的软件都支持</p><p>Unicode的一种实现，兼容GB系列，是GB2312、GBK的超集</p><hr><p>参考资料</p><p><a href="https://mp.weixin.qq.com/s/5pAgcjk_lFGrPhSUp2Na3Q">一文读懂字符编码</a></p><p><a href="https://www.zhihu.com/question/23374078">Unicode 和 UTF-8 有何区别？ - 知乎</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka设计</title>
      <link href="/2022-08-05-Kafka%E8%AE%BE%E8%AE%A1.html"/>
      <url>/2022-08-05-Kafka%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><code>Apache Kafka</code>是一个开源的分布式事件流平台, 用于高性能数据管道、流分析、数据集成</p><p>事件流是从事件源（如数据库、传感器、移动设备、云服务和软件应用程序）以事件流的形式实时捕获数据的实践；持久存储这些事件流以供以后检索；实时和回顾性地操作、处理和响应事件流；并根据需要将事件流路由到不同的目标技术</p><ul><li>publish&#x2F;subscribe(write&#x2F;read)事件流</li><li>存储事件流</li><li>实时或追溯处理事件流</li></ul><h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>与传统的MQ相比，更像数据库日志</p><ul><li>支持高吞吐</li><li>支持处理大量数据积压</li><li>支持低延迟</li><li>机器故障时支持容错</li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>Kafka非常依赖文件系统进行存储和缓存</p><p>使用内存缓存的坏处:</p><ol><li>OS会将内存转移到磁盘缓存</li><li>Java的对象内存开销大</li><li>堆内存使用越多GC越慢</li><li>服务重启时重建缓存慢</li></ol><p>进行的优化:</p><ol><li>自动访问空闲内存</li><li>保存byte[]而不是Java对象</li></ol><ul><li>NO  在内存中维护尽可能多的内容，并在空间不足时将其全部刷新到文件系统</li><li>YES 所有数据都会立即写入文件系统上的持久日志, 不必刷新到磁盘(实际上只是被转移到内核的页面缓存中)</li></ul><h3 id="常数时间"><a href="#常数时间" class="headerlink" title="常数时间"></a>常数时间</h3><p>Queue建立在对文件的read和append上(在日志系统中很常见), 而BTree等数据结构如果触发磁盘寻道会开销很大</p><p>优点:</p><ol><li>操作的时间复杂度O(1)</li><li>读写不会阻塞</li><li>性能与数据量无关</li><li>支持消息保存较长时间</li></ol><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>避免效率低的磁盘访问:</p><ol><li>过多的小型IO操作</li><li>过多的byte复制</li></ol><p>如何避免:</p><ol><li>将数据抽象为<code>message set</code>, 网络请求将消息组合在一起, 服务器将消息一次性append, 消费者一次性获取大数据块</li><li>使用标准化二进制格式, 这样数据传输时不用修改, 就可以利用OS提供的<code>zero-copy</code>, 在Linux中为<code>sendfile</code>系统调用. 使用<code>pagecache</code>+<code>sendfile</code>使磁盘几乎不会有高负载</li></ol><h3 id="端到端批量压缩"><a href="#端到端批量压缩" class="headerlink" title="端到端批量压缩"></a>端到端批量压缩</h3><p>大部分信息冗余来源于同一种类型的不同消息, Kafka支持一批消息批量压缩</p><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>客户端可以控制消息的目标partition, 支持设置使用指定字段作为分区根据, 这样设计使consumer可以做局部敏感数据处理</p><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>producer支持异步, 在内存中保留一定消息然后批处理发送以提高效率, 可以配置缓存的大小和有效时间</p><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>consumer在每个请求中指定想要访问的偏移量</p><h3 id="PUSH-vs-PULL"><a href="#PUSH-vs-PULL" class="headerlink" title="PUSH vs PULL"></a>PUSH vs PULL</h3><p>Kafka使用支持阻塞的PULL请求</p><p>PULL的优点</p><ol><li>consumer不会收到超出可处理上限的消息, 不同的consumer可以按照自己的处理能力获取消息</li><li>PUSH需要针对可能的阻塞设置推送延迟, PULL不需要设置</li></ol><p>简单的PULL的缺点</p><ol><li>没有消息的时候consumer浪费CPU资源进行空轮询</li></ol><h3 id="Consumer记录位置"><a href="#Consumer记录位置" class="headerlink" title="Consumer记录位置"></a>Consumer记录位置</h3><p>MQ需要确认消息是否被成功消费, 一些MQ引入一个中间状态”已发送未消费”</p><p>Kafka的topic的每个分区记录一个consumer位置, 不需要维护每个消息的确认状态</p><h3 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h3><p>可以在所有情况下提供多种保证()</p><ol><li>最多一次, 消息可能会丢失, 不会重复</li><li>最少一次, 消息可能会重复, 不会丢失</li><li>精确一次</li></ol><p>Kafka默认保证最少一次, 事务性producer&#x2F;consumer可以实现精确一次</p><h4 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h4><p>Kafka支持<code>idempotent delivery</code>幂等生产, 重新发送消息不会导致broker中出现重复消息</p><h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><p>Kafka需要支持一个consumer崩溃后切换到其他consumer的场景</p><ol><li>最多一次, consumer读消息-&gt;保存位置-&gt;处理消息</li><li>至少一次, consumer读消息-&gt;处理消息-&gt;保存位置</li><li>精确一次, 使用事务更新, broker同时更新consumer的位置和处理结果</li></ol><h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><p>replication的单位是partition, 每个partition都有1个主节点0或多个从节点, 主写从读</p><p>replication的心跳使用ZooKeeper维护</p><p>分布式一致性</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>NIO服务器</p><h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>key&#x2F;value不透明</p><hr><p><a href="https://kafka.apache.org/intro">Apache Kafka - intro</a></p><p><a href="https://kafka.apache.org/documentation/#design">Apache Kafka - doc</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Message Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《聊聊Netty那些事》阅读笔记</title>
      <link href="/2022-07-07-%E3%80%8A%E8%81%8A%E8%81%8ANetty%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html"/>
      <url>/2022-07-07-%E3%80%8A%E8%81%8A%E8%81%8ANetty%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="内核IO模型"><a href="#内核IO模型" class="headerlink" title="内核IO模型"></a>内核IO模型</h1><h2 id="网络包接收流程"><a href="#网络包接收流程" class="headerlink" title="网络包接收流程"></a>网络包接收流程</h2><p>接收网络数据包的详细开销</p><ul><li>从<code>网卡</code>DMA拷贝网络数据包到<code>内存</code>中的开销(DMA指网卡可以在没有CPU参与的情况下独立写内存)</li><li>CPU收到<code>硬中断</code>后调用网卡驱动进行响应的开销</li><li>OS的内核线程<code>ksoftirqd</code>响应<code>软中断</code>的开销</li><li>应用程序通过系统调用从<code>用户态</code>转为<code>内核态</code>的开销, 系统调用返回时从<code>内核态</code>转为<code>用户态</code>的开销</li><li>网络数据从<code>内存</code>的<code>内核空间</code>通过CPU拷贝到<code>用户空间</code>的开销</li></ul><p><img src="/../../../../image/netty1-1.png" alt="网络包接收过程"></p><p><img src="/../../../../image/netty1-2.png" alt="网络包发送过程"></p><h2 id="同步与异步-阻塞与非阻塞"><a href="#同步与异步-阻塞与非阻塞" class="headerlink" title="同步与异步, 阻塞与非阻塞"></a>同步与异步, 阻塞与非阻塞</h2><p>接收网络数据包的2个流程</p><ul><li>数据准备阶段:  在这个阶段, 网络数据包到达<code>网卡</code>, 通过<code>DMA</code>的方式将数据包拷贝到<code>内存</code>中, 然后经过<code>硬中断</code>, <code>软中断</code>, 接着通过内核线程<code>ksoftirqd</code>经过内核协议栈的处理, 最终将数据发送到<code>内核Socket的接收缓冲区</code>中</li><li>数据拷贝阶段:  当数据到达内核Socket的接收缓冲区中时, 此时数据存在于<code>内核空间</code>中, 需要将数据拷贝到<code>用户空间</code>中, 才能够被应用程序读取</li></ul><p>参考<a href="https://hahahaha123567.github.io/2022-01-14-feng-huang-jia-gou-du-shu-bi-ji-copy.html">《凤凰架构》读书摘要</a>的<code>网络IO模型</code>一节</p><p><a href="http://icyfenix.cn/distribution/connect/service-routing.html">网关路由 | 凤凰架构</a></p><ul><li>同步IO(Synchronous I&#x2F;O)<ul><li>阻塞IO(Blocking I&#x2F;O), 节省 CPU 资源(Java传统IO模型)</li><li>非阻塞IO(Non-Blocking I&#x2F;O), 浪费 CPU 资源(Java的NIO)</li><li>多路复用IO(Multiplexing I&#x2F;O), 主流(通过NIO实现的Reactor模式)</li><li>信号驱动IO(Signal-Driven I&#x2F;O), 需要自己从缓冲区获取数据</li></ul></li><li>异步IO(Asynchronous I&#x2F;O)(通过AIO实现的Proactor模式)</li></ul><p>阻塞与非阻塞的区别主要发生在第一阶段: 数据准备阶段</p><ul><li>阻塞模式, 当Socket的接收缓冲区中没有数据的时候, 应用线程会一直等待</li><li>非阻塞模式, 应用线程不会等待, 系统调用直接返回错误标志<code>EWOULDBLOCK</code></li></ul><p>同步与异步主要的区别发生在第二阶段: 数据拷贝阶段</p><ul><li>同步模式在数据准备好后, 是由用户线程的内核态来执行第二阶段, 所以应用程序会在第二阶段发生阻塞, 直到数据从内核空间拷贝到用户空间, 系统调用才会返回</li><li>异步模式下是由内核来执行第二阶段的数据拷贝操作, 当内核执行完第二阶段, 会通知用户线程IO操作已经完成, 并将数据回调给用户线程</li></ul><h2 id="IO多路复用-TODO"><a href="#IO多路复用-TODO" class="headerlink" title="IO多路复用 TODO"></a>IO多路复用 TODO</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><img src="/../../../../image/netty1-3.png" alt="select"></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="/../../../../image/netty1-4.png" alt="epoll"></p><p>在Netty中实现的<code>EpollSocketChannel</code>默认的就是边缘触发模式, JDK的NIO默认是水平触发模式</p><p>epoll对select, poll的优化</p><ol><li><p>epoll在内核中通过红黑树管理海量的连接, 所以在调用<code>epoll_wait</code>获取IO就绪的socket时, 不需要传入监听的socket文件描述符, 从而避免了海量的文件描述符集合在用户空间和内核空间中来回复制</p></li><li><p>epoll仅会通知IO就绪的socket, 避免了在用户空间遍历的开销</p></li><li><p>epoll通过在socket的等待队列上注册回调函数<code>ep_poll_callback</code>通知用户程序IO就绪的socket, 避免了在内核中轮询的开销</p></li></ol><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p><code>Reactor</code>基于<code>NIO</code>, <code>Proactor</code>基于<code>AIO</code></p><ul><li>单Reactor单线程<ul><li>单Reactor意味着只有一个epoll对象, 监听所有的事件, 包括连接事件, 读写事件</li><li>单线程意味着只有一个线程来执行<code>epoll_wait</code>获取IO就绪的Socket, 然后对这些就绪的Socket执行读写, 后续的业务处理也依然是这个线程</li></ul></li><li>单Reactor多线程<ul><li>只有一个epoll对象来监听所有的IO事件, 一个线程来调用<code>epoll_wait</code>获取IO就绪的Socket</li><li>当IO就绪事件产生时, 这些IO事件对应处理的业务Handler, 我们是通过线程池来执行, 这样相比单Reactor单线程模型提高了执行效率, 充分发挥了多核CPU的优势</li></ul></li><li>主从Reactor多线程<ul><li><code>主Reactor</code>处理连接事件</li><li>当创建好连接, 建立好对应的socket后, 在acceptor中将需要监听的read事件注册到<code>从Reactor</code>中, 由<code>从Reactor</code>来监听socket上的读写事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置单Reactor单线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(eventGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置多Reactor线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(eventGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置主从Reactor多线程</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure><h2 id="Netty对Reactor模型的实现"><a href="#Netty对Reactor模型的实现" class="headerlink" title="Netty对Reactor模型的实现"></a>Netty对Reactor模型的实现</h2><p><img src="/../../../../image/netty1-5.png" alt="Netty中的reactor"></p><p>Reactor在netty中是以group的形式出现的, netty中将Reactor分为两组, 一组是<code>主ReactorGroup</code>也就是<code>bossGroup</code>, 另一组是<code>从ReactorGroup</code>也就是<code>workerGroup</code></p><h3 id="主ReactorGroup"><a href="#主ReactorGroup" class="headerlink" title="主ReactorGroup"></a>主ReactorGroup</h3><p><code>主ReactorGroup</code>中通常只有一个Reactor, 专门负责监听<code>连接accept事件</code>, 当有连接事件产生时, 在acceptor中创建相应的<code>NioSocketChannel</code>(代表一个Socket连接), 然后以负载均衡的方式在<code>从ReactorGroup</code>中选一个Reactor, 注册监听<code>Read事件</code></p><p><code>主ReactorGroup</code>中只有一个Reactor, 因为通常我们服务端程序只会绑定监听一个端口, 如果要绑定监听多个端口, 就会配置多个Reactor</p><h3 id="从ReactorGroup"><a href="#从ReactorGroup" class="headerlink" title="从ReactorGroup"></a>从ReactorGroup</h3><p><code>从ReactorGroup</code>中有多个Reactor, 具体Reactor的个数可以由系统参数指定, 默认的Reactor的个数为<code>CPU核数 * 2</code>, <code>从ReactorGroup</code>中的Reactor主要负责监听读写事件, 每一个Reactor负责监听一组socket连接</p><p>Socket连接在创建后就被固定的分配给一个Reactor, 所以一个Socket连接也只会被一个固定的IO线程执行, 这种无锁串行化的设计的目的是为了防止多线程并发执行同一个socket连接上的IO逻辑处理, 防止出现线程安全问题</p><ol><li>轮询IO就绪事件</li><li>处理IO事件</li><li>执行异步任务</li></ol><p>由于每个Reactor中只有一个IO线程, <code>ChannelHandler</code>中执行的逻辑不能耗时太长, 尽量将耗时的业务逻辑处理放入单独的业务线程池中处理, 否则会影响其他连接的IO读写, 从而影响整个服务程序的IO吞吐</p><h1 id="Reactor在Netty中的实现-创建"><a href="#Reactor在Netty中的实现-创建" class="headerlink" title="Reactor在Netty中的实现(创建)"></a>Reactor在Netty中的实现(创建)</h1><h2 id="Netty服务端代码模板"><a href="#Netty服务端代码模板" class="headerlink" title="Netty服务端代码模板"></a>Netty服务端代码模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Echoes back any received data from a client.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        <span class="comment">//创建主从Reactor线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">EchoServerHandler</span> <span class="variable">serverHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup) <span class="comment">// 配置主从Reactor</span></span><br><span class="line">             .channel(NioServerSocketChannel.class) <span class="comment">// 配置主Reactor中的channel类型</span></span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>) <span class="comment">// 设置主Reactor中channel的option选项</span></span><br><span class="line">             .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">// 设置主Reactor中Channel-&gt;pipline-&gt;handler</span></span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="comment">// 设置从Reactor中注册channel的pipeline</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                     <span class="comment">// p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口启动服务, 开始监听accept事件</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>主从ReactorGroup</code>, 在Netty中<code>EventLoopGroup</code>就是<code>ReactorGroup</code>的实现类, <code>EventLoop</code>就是<code>Reactor</code>的实现类</p><p>SocketChannel</p><ul><li><code>NioServerSocketChannel</code>, 监听Socket, 负责listen和bind, 使用<code>ServerBootstrapAcceptor</code>创建<code>NioSocketChannel</code></li><li><code>NioSocketChannel</code>, 客户端连接socket, 负责与客户端之间的网络通信</li></ul><p>serverBootstrap.handler设置的是服务端NioServerSocketChannel PipeLine中的ChannelHandler, ServerBootstrap启动类方法带有child前缀的均是设置客户端NioSocketChannel属性的</p><h2 id="创建用于启动EventLoop线程的executor"><a href="#创建用于启动EventLoop线程的executor" class="headerlink" title="创建用于启动EventLoop线程的executor"></a>创建用于启动EventLoop线程的executor</h2><p><code>ThreadPerTaskExecutor</code>, 来一个任务就创建一个线程执行, EventLoop线程的核心就是一个死循环不停的轮询IO就绪事件, 处理IO事件, 执行异步任务</p><h2 id="创建EventLoop"><a href="#创建EventLoop" class="headerlink" title="创建EventLoop"></a>创建EventLoop</h2><p><img src="/../../../../image/netty2-1.png" alt="EventLoop结构"></p><p>EventLoop线程组<code>NioEventLoopGroup</code>包含多个<code>EventLoop</code>, 存放于<code>private final EventExecutor[] children</code>中</p><p>EventLoop的核心是使用IO多路复用模型来对客户端连接上的IO事件进行监听, 所以最重要的事情是创建Selector</p><p>openSelector是NioEventLoop类中用于创建IO多路复用的Selector, 并对创建出来的JDK NIO原生的Selector进行性能优化: </p><ol><li>将<code>SelectorImpl</code>中存放可用socket的<code>HashSet</code>使用反射修改为<code>SelectedSelectionKeySet</code>, 底层实现从<code>HashMap</code>变为<code>数组</code>, 优化遍历、插入性能, 利用cpu cache</li><li>使用代理模式, 用<code>SelectedSelectionKeySetSelector</code>代理selector的真实实现类, 在每次遍历结束后清空SelectedSelectionKeySet的内容</li></ol><p>EventLoop内的异步任务队列的类型为<code>MpscQueue</code>,它是由<code>JCTools</code>提供的一个高性能无锁队列, 从命名前缀Mpsc可以看出, 它适用于多生产者单消费者的场景</p><p>EventLoop负责执行的异步任务分为三类: </p><ul><li>普通任务: 这是Netty最主要执行的异步任务, 存放在普通任务队列taskQueue中, 在<code>NioEventLoop</code>构造函数中创建</li><li>定时任务: 存放在优先级队列中</li><li>尾部任务: 存放于尾部任务队列tailTasks中, 尾部任务一般不常用, 在普通任务执行完后 EventLoop线程会执行尾部任务, 比如对Netty的运行状态做一些统计数据, 例如任务循环的耗时、占用物理内存的大小等等都可以向尾部队列添加一个收尾任务完成统计数据的实时更新</li></ul><h2 id="创建Channel到EventLoop的绑定策略"><a href="#创建Channel到EventLoop的绑定策略" class="headerlink" title="创建Channel到EventLoop的绑定策略"></a>创建Channel到EventLoop的绑定策略</h2><p>无论是Netty服务端<code>NioServerSocketChannel</code>关注的<code>OP_ACCEPT</code>事件, 还是Netty客户端<code>NioSocketChannel</code>关注的<code>OP_READ</code>和<code>OP_WRITE</code>事件, 都需要先注册到EventLoop上, EventLoop才能监听Channel上关注的IO事件实现IO多路复用</p><p><code>MultithreadEventExecutorGroup</code>类的构造器参数<code>EventExecutorChooserFactory</code>负责创建Channel到EventLoop的绑定策略, 默认为round-robin轮询, 如果EventLoop数量为2的次幂可以用移位快速计算</p><h1 id="Netty启动流程"><a href="#Netty启动流程" class="headerlink" title="Netty启动流程"></a>Netty启动流程</h1><p><img src="/../../../../image/netty3-1.png" alt="EventLoop启动流程图"></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>不管是服务端用到的<code>NioServerSocketChannel</code>还是客户端用到的<code>NioSocketChannel</code>, 每个Channel实例都会有一个Pipeline, Pipeline中有多个<code>ChannelHandler</code>用于编排处理对应Channel上感兴趣的IO事件</p><p>向<code>NioServerSocketChannel</code>中的Pipeline添加<code>ChannelHandler</code>分为两种方式</p><ol><li>显式添加: 用户通过<code>ServerBootstrap#handler</code>添加, 如果需要添加多个<code>ChannelHandler</code>, 则可以通过<code>ChannelInitializer</code>向pipeline中进行添加</li><li>隐式添加: 隐式添加主要添加的就是<code>MainEventLoopGroup</code>的核心组件, 也就是图中的acceptor, Netty中的实现为<code>ServerBootstrapAcceptor</code>, 本质上也是一种<code>ChannelHandler</code>, 主要负责在客户端连接建立好后, 初始化客户端<code>NioSocketChannel</code>, 在从EventLoop线程组中选取一个<code>SubEventLoop</code>, 将客户端<code>NioSocketChannel</code>注册到<code>SubEventLoop</code>中的selector上</li></ol><p><img src="/../../../../image/netty3-2.png" alt="EventLoopGroup结构"></p><p>由于在Netty的IO线程模型中, 是由单个<code>SubEventLoop</code>线程负责执行客户端<code>NioSocketChannel</code>中的Pipeline, 一个<code>SubEventLoop</code>线程负责处理多个<code>NioSocketChannel</code>上的IO事件, 如果Pipeline中的<code>ChannelHandler</code>添加的太多, 就会影响<code>SubEventLoop</code>线程执行其他<code>NioSocketChannel</code>上的Pipeline, 从而降低IO处理效率, 降低吞吐量</p><p>所以Pipeline中的<code>ChannelHandler</code>不易添加过多, 并且不能在<code>ChannelHandler</code>中执行耗时的业务处理任务</p><h2 id="Netty服务端的启动"><a href="#Netty服务端的启动" class="headerlink" title="Netty服务端的启动"></a>Netty服务端的启动</h2><p><img src="/../../../../image/netty3-3.png" alt="EventLoop启动后的结构"></p><p>Netty服务端的启动流程总体如下: </p><ol><li>创建服务端<code>NioServerSocketChannel</code>并初始化</li><li>将服务端<code>NioServerSocketChannel</code>注册到<code>主EventLoopGroup</code>中</li><li>注册成功后, 开始初始化<code>NioServerSocketChannel</code>中的pipeline, 然后在pipeline中触发<code>ChannelRegister</code>事件</li><li>随后由<code>NioServerSocketChannel</code>绑定端口地址</li><li>绑定端口地址成功后, 向<code>NioServerSocketChannel</code>对应的Pipeline中触发传播<code>ChannelActive</code>事件, 在事件回调中向<code>MainEventLoop</code>注册<code>OP_ACCEPT</code>事件, 开始等待客户端连接, 服务端启动完成</li></ol><p>代码执行流程:</p><ol><li>创建<code>NioServerSocketChannel</code></li><li>初始化<code>NioServerSocketChannel</code></li><li>向<code>MainEventLoop</code>注册<code>NioServerSocketChannel</code><ol><li><code>MainEventLoopGroup</code>中选取一个<code>MainEventLoop</code>进行注册</li><li>向绑定后的<code>MainEventLoop</code>进行注册</li><li><code>MainEventLoop</code>的启动</li><li>startThread</li><li>register0, 封装为异步任务</li><li>doRegister(), 添加Acceptor封装为异步任务</li><li><code>HandlerAdded</code>事件回调中初始化ChannelPipeline</li><li>回调regFuture的<code>ChannelFutureListener</code></li></ol></li><li>doBind0, 封装为异步任务</li><li>绑定端口地址<ol><li>HeadContext</li><li><code>channelActive</code>事件处理, 封装为异步任务</li><li>beginRead</li></ol></li></ol><p><code>Unsafe</code>为<code>Channel</code>接口的一个内部接口, 用于定义实现对Channel底层的各种操作, Unsafe接口定义的操作行为只能由Netty框架的Reactor线程调用, 用户线程禁止调用</p><p>Netty自定义的<code>SocketChannel</code>类型均继承<code>AttributeMap</code>接口以及<code>DefaultAttributeMap</code>类, 正是它们定义了<code>ChannelAttributes</code>, 用于向Channel添加用户自定义的一些信息</p><p>初始化<code>NioServerSocketChannel</code>中pipeline的时机是: 当<code>NioServerSocketChannel</code>注册到<code>MainEventLoop</code>之后, 绑定端口地址之前</p><p><code>MainEventLoop</code>线程是在提交第一个异步任务的时候启动的, 在用户程序(Main线程)提交用于注册<code>NioServerSocketChannel</code>的异步任务时开始启动</p><h1 id="Reactor的架构"><a href="#Reactor的架构" class="headerlink" title="Reactor的架构"></a>Reactor的架构</h1><h2 id="Reactor线程的整个运行框架"><a href="#Reactor线程的整个运行框架" class="headerlink" title="Reactor线程的整个运行框架"></a>Reactor线程的整个运行框架</h2><p>Netty中的Reactor线程主要干三件事情: </p><ul><li>轮询注册在<code>EventLoop</code>上的所有Channel感兴趣的IO就绪事件</li><li>处理Channel上的IO就绪事件</li><li>执行Netty中的异步任务</li></ul><p><code>EventLoop</code>线程其实执行的就是一个死循环, 在死循环中不断的通过Selector去轮询IO就绪事件, 如果发生IO就绪事件则从Selector系统调用中返回并处理IO就绪事件, 如果没有发生IO就绪事件则一直阻塞在Selector系统调用上, 直到满足Selector唤醒条件:</p><ol><li>当Selector轮询到有IO活跃事件发生时</li><li>当<code>EventLoop</code>线程需要执行的定时任务到达任务执行时间deadline时</li><li>当有异步任务提交给<code>EventLoop</code>时, <code>EventLoop</code>线程需要从Selector上被唤醒, 这样才能及时的去执行异步任务</li></ol><p><img src="/../../../../image/netty4-1.png" alt="EventLoop工作流程图"></p><h2 id="Reactor线程轮询IO就绪事件"><a href="#Reactor线程轮询IO就绪事件" class="headerlink" title="Reactor线程轮询IO就绪事件"></a>Reactor线程轮询IO就绪事件</h2><p>在Reactor线程的轮询工作开始之前, 需要首先判断下当前是否有异步任务需要执行, 判断依据就是查看Reactor中的异步任务队列taskQueue和用于统计信息任务用的尾部队列tailTask是否有异步任务</p><p>如果Reactor中有异步任务需要执行, 那么Reactor线程需要立即执行, 不能阻塞在Selector上, 在返回前需要再顺带调用<code>selectNow()</code>非阻塞查看一下当前是否有IO就绪事件发生, 如果有, 那么正好可以和异步任务一起被处理, 如果没有, 则及时地处理异步任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSelectStrategy</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="type">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reactor线程要保证及时的执行异步任务</span></span><br><span class="line"><span class="comment">     * 1: 如果有异步任务等待执行, 则马上执行selectNow()非阻塞轮询一次IO就绪事件</span></span><br><span class="line"><span class="comment">     * 2: 没有异步任务, 则跳到switch select分支</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">IntSupplier</span> <span class="variable">selectNowSupplier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntSupplier</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">return</span> selector.selectNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>NioEventLoop</code>是<code>ScheduledExecutorService</code>的子类, 支持执行定时任务, 在阻塞轮询IO任务之前通过<code>AbstractScheduledEventExecutor</code>的<code>nextScheduledTaskDeadlineNanos</code>获取到下个定时任务执行的时间作为阻塞超时时间</p><p>异步任务在被提交后希望立马得到执行, 那么就在提交异步任务的时候去唤醒正在阻塞轮询的Reactor线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">        strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 执行到这里说明EventLoop已经从Selector上被唤醒了</span></span><br><span class="line">    <span class="comment">// 设置EventLoop的状态为苏醒状态AWAKE</span></span><br><span class="line">    <span class="comment">// lazySet优化不必要的volatile操作, 不使用内存屏障, 不保证写操作的可见性（单线程不需要保证）</span></span><br><span class="line">    nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactor处理IO与处理异步任务的时间比例分配"><a href="#Reactor处理IO与处理异步任务的时间比例分配" class="headerlink" title="Reactor处理IO与处理异步任务的时间比例分配"></a>Reactor处理IO与处理异步任务的时间比例分配</h2><p>Netty通过ioRatio变量来调配<code>EventLoop</code>线程在处理IO事件和执行异步任务之间的CPU时间分配比例, 防止<code>EventLoop</code>线程处理异步任务时间过长而导致I&#x2F;O 事件得不到及时地处理</p><p><code>ioRatio / 100 = 执行异步任务时间 / (执行异步任务时间 + 轮询IO事件时间)</code>, 默认50</p><h2 id="Reactor线程处理IO就绪事件"><a href="#Reactor线程处理IO就绪事件" class="headerlink" title="Reactor线程处理IO就绪事件"></a>Reactor线程处理IO就绪事件</h2><ol><li><code>processSelectedKeysPlain</code>, JDK实现<ol><li>获取IO就绪的Channel</li><li>处理Channel上的IO事件<ol><li>处理Connect事件</li><li>处理Write事件</li><li>处理Read事件或者Accept事件</li></ol></li><li>从Selector中移除失效的<code>SelectionKey</code>, 为了保证Selector中所有KeySet的有效性, 需要在Channel取消个数达到256时, 触发一次selectNow, 目的是清除无效的<code>SelectionKey</code></li></ol></li><li><code>processSelectedKeysOptimized</code>, Netty实现<ol><li>数组需要手动做清除</li></ol></li></ol><p>服务端<code>NioServerSocketChannel</code>中的Read方法处理的是Accept事件, 客户端<code>NioSocketChannel</code>中的Read方法处理的是Read事件</p><h2 id="Reactor线程处理异步任务"><a href="#Reactor线程处理异步任务" class="headerlink" title="Reactor线程处理异步任务"></a>Reactor线程处理异步任务</h2><p><code>EventLoop</code>线程执行异步任务的核心逻辑:</p><ol><li>先将到期的定时任务从定时任务队列<code>scheduledTaskQueue</code>中全部取出并转存到普通任务队列taskQueue中</li><li>由<code>EventLoop</code>线程统一从普通任务队列taskQueue中取出任务执行</li><li>在<code>EventLoop</code>线程执行完定时任务和普通任务后, 开始执行存储于尾部任务队列tailTasks中的尾部任务</li></ol><h2 id="规避JDK-Epoll空轮询bug"><a href="#规避JDK-Epoll空轮询bug" class="headerlink" title="规避JDK Epoll空轮询bug"></a>规避JDK Epoll空轮询bug</h2><p>JDK NIO Epoll的空轮询BUG会导致<code>EventLoop</code>线程在没有任何事情可做的情况下被意外唤醒, 导致CPU空转</p><p>既没有IO就绪事件, 也没有异步任务, <code>EventLoop</code>线程从Selector上被异常唤醒, 发生512次之后认为已触发bug, 则重建Selector(将之前注册的所有Channel重新注册到新的Selector上并关闭旧的Selector), selectCnt计数归0</p><h1 id="Netty接收网络连接"><a href="#Netty接收网络连接" class="headerlink" title="Netty接收网络连接"></a>Netty接收网络连接</h1><h2 id="MainReactor处理OP-ACCEPT事件"><a href="#MainReactor处理OP-ACCEPT事件" class="headerlink" title="MainReactor处理OP_ACCEPT事件"></a>MainReactor处理OP_ACCEPT事件</h2><p>Netty将<code>OP_ACCEPT</code>事件处理的入口函数封装在<code>NioServerSocketChannel</code>里的底层操作类Unsafe的read方法中</p><p><img src="/../../../../image/netty6.png" alt="接收客户端连接"></p><p>main reactor线程是在一个无限循环read loop中不断的调用JDK NIO <code>serverSocketChannel.accept()</code>方法来接收完成三次握手的客户端连接<code>NioSocketChannel</code>的, 并将接收到的<code>NioSocketChannel</code>临时保存在<code>List&lt;Object&gt; readBuf</code>集合中, 后续在<code>NioServerSocketChannel</code>的pipeline中通过<code>ChannelRead</code>事件来传递, 最终会在<code>ServerBootstrapAcceptor</code>这个ChannelHandler中被处理初始化, 并将其注册到<code>SubEventLoop</code>中</p><p>这里的read loop循环会被限定只能读取16次, 当<code>MainEventLoop</code>从<code>NioServerSocketChannel</code>中读取客户端连接<code>NioSocketChannel</code>的次数达到16次之后, 无论此时是否还有客户端连接都不能在继续读取了, 因为还需要分配时间去执行异步任务, 不能因为无限制的接收客户端连接而耽误了异步任务的执行</p><h2 id="doReadMessages接收客户端连接"><a href="#doReadMessages接收客户端连接" class="headerlink" title="doReadMessages接收客户端连接"></a>doReadMessages接收客户端连接</h2><p>根据<code>ServerSocketChannel</code>的accept方法获取到JDK NIO 原生的<code>SocketChannel</code>(用于底层真正与客户端通信的Channel), 来创建Netty中的<code>NioSocketChannel</code></p><p><code>NioServerSocketChannel</code>与<code>NioSocketChannel</code>的不同</p><ol><li><code>NioServerSocketChannel</code>在<code>EventLoop</code>启动过程中创建, <code>NioSocketChannel</code>在<code>EventLoop</code>接收连接时被<code>NioServerSocketChannel</code>创建</li><li><code>NioServerSocketChannel</code>向<code>MainEventLoop</code>注册<code>OP_ACCEPT</code>事件, <code>NioSocketChannel</code>向<code>SubEventLoop</code>注册<code>OP_READ</code>事件</li><li><code>NioServerSocketChannel</code>继承<code>AbstractNioMessageChannel</code>, 输出的Message指的是<code>SocketChannel</code>客户端连接; <code>NioSocketChannel</code>继承的是<code>AbstractNioByteChannel</code>, 输出的是网络数据Byte</li></ol><p><img src="/../../../../image/netty8.png" alt="NioSocketChannel结构"></p><h2 id="ChannelRead事件的响应"><a href="#ChannelRead事件的响应" class="headerlink" title="ChannelRead事件的响应"></a>ChannelRead事件的响应</h2><p><code>ServerBootstrapAcceptor</code>主要的作用就是初始化客户端<code>NioSocketChannel</code>, 并将客户端<code>NioSocketChannel</code>注册到<code>从ReactorGroup</code>中, 并监听OP_READ事件</p><h2 id="向从ReactorGroup注册NioSocketChannel"><a href="#向从ReactorGroup注册NioSocketChannel" class="headerlink" title="向从ReactorGroup注册NioSocketChannel"></a>向从ReactorGroup注册NioSocketChannel</h2><ol><li>从<code>从ReactorGroup</code>中选取一个<code>从Reactor</code>进行绑定</li><li>向绑定的<code>从Reactor</code>上注册<code>NioSocketChannel</code></li><li>register0</li></ol><h1 id="Netty接收网络数据"><a href="#Netty接收网络数据" class="headerlink" title="Netty接收网络数据"></a>Netty接收网络数据</h1><h2 id="SubReactor处理OP-READ事件流程总览"><a href="#SubReactor处理OP-READ事件流程总览" class="headerlink" title="SubReactor处理OP_READ事件流程总览"></a>SubReactor处理OP_READ事件流程总览</h2><p>当网络数据到达服务端的网卡并经过内核协议栈的处理, 最终数据到达Socket的接收缓冲区之后, <code>SubEventLoop</code>轮询到<code>NioSocketChannel</code>上的<code>OP_READ</code>事件就绪, 随后<code>SubEventLoop</code>线程就会从JDK Selector上的阻塞轮询API<code>selector.select(timeoutMillis)</code>调用中返回, 转而去处理<code>NioSocketChannel</code>上的<code>OP_READ</code>事件</p><p><code>SubEventLoop</code>在处理Channel上的IO事件入口函数为<code>NioEventLoop#processSelectedKey</code></p><h2 id="Netty接收网络数据流程总览"><a href="#Netty接收网络数据流程总览" class="headerlink" title="Netty接收网络数据流程总览"></a>Netty接收网络数据流程总览</h2><p><img src="/../../../../image/netty10.png" alt="Netty接收网络数据流程"></p><p><code>NioSocketChannel</code>读取连接数据的read loop中受最大读取次数的限制, 默认配置最多只能读取16次, 超过16次无论此时<code>NioSocketChannel</code>中是否还有可读数据都不能在进行读取了</p><ul><li>lastBytesRead &lt; 0: 表示客户端主动发起了连接关闭流程, Netty开始连接关闭处理流程</li><li>lastBytesRead &#x3D; 0: 表示当前<code>NioSocketChannel</code>上的数据已经全部读取完毕, 没有数据可读, 本次<code>OP_READ</code>事件处理完毕</li><li>lastBytesRead &gt; 0: 表示在本次read loop中从<code>NioSocketChannel</code>中读取到了数据, 会在<code>NioSocketChannel</code>的pipeline中触发<code>ChannelRead</code>事件, 进而在pipeline中负责IO处理的<code>ChannelHandelr</code>中响应, 处理网络请求</li></ul><h2 id="ChannelRead和ChannelReadComplete的区别"><a href="#ChannelRead和ChannelReadComplete的区别" class="headerlink" title="ChannelRead和ChannelReadComplete的区别"></a>ChannelRead和ChannelReadComplete的区别</h2><ul><li><code>ChanneRead</code>事件: 一次循环读取一次数据, 就触发一次ChannelRead事件, 本次最多读取在read loop循环开始分配的<code>DirectByteBuffer</code>容量大小</li><li><code>ChannelReadComplete</code>事件: 当读取不到数据或者不满足continueReading的任意一个条件就会退出read loop, 这时就会触发<code>ChannelReadComplete</code>事件</li></ul><p>触发<code>ChannelReadComplete</code>事件并不代表<code>NioSocketChannel</code>中的数据已经读取完了, 只能说明本次<code>OP_READ</code>事件处理完毕, 因为有可能是客户端发送的数据太多, Netty读了16次还没读完, 那就只能等到下次<code>OP_READ</code>事件到来的时候在进行读取了</p><h2 id="源码核心框架总览"><a href="#源码核心框架总览" class="headerlink" title="源码核心框架总览"></a>源码核心框架总览</h2><h3 id="分配DirectByteBuffer接收网络数据"><a href="#分配DirectByteBuffer接收网络数据" class="headerlink" title="分配DirectByteBuffer接收网络数据"></a>分配DirectByteBuffer接收网络数据</h3><p><code>NioSocketChannel</code>的2个<code>ByteBufAllocator</code></p><ul><li><code>ByteBufAllocator</code>是一个<code>PooledByteBufAllocator</code>的实例, 内存池, 用来管理堆外内存<code>DirectByteBuffer</code></li><li><code>RecvByteBufAllocator</code>是一个<code>AdaptiveRecvByteBufAllocator</code>类的实例, 可以动态调整ByteBuffer的容量, 初始为2048</li></ul><p><code>RecvByteBufAllocator</code>计算大小, 然后<code>ByteBufAllocator</code>进行内存分配</p><h2 id="ByteBuffer动态自适应括缩容机制"><a href="#ByteBuffer动态自适应括缩容机制" class="headerlink" title="ByteBuffer动态自适应括缩容机制"></a>ByteBuffer动态自适应括缩容机制</h2><p>容量索引表</p><ol><li>当索引容量小于512时, 容量索引从16开始按16递增</li><li>当索引容量大于512时, 容量索引按前一个索引容量的2倍递增</li></ol><p><code>AdaptiveRecvByteBufAllocator</code>类中定义的扩容步长<code>INDEX_INCREMENT = 4</code>, 缩容步长<code>INDEX_DECREMENT = 1</code></p><ul><li>扩容: 取容量索引向后走4步对应的size</li><li>缩容: 取容量索引向前走1步对应的size, 满足两次缩容条件才会进行缩容</li></ul><h2 id="使用堆外内存为ByteBuffer分配内存"><a href="#使用堆外内存为ByteBuffer分配内存" class="headerlink" title="使用堆外内存为ByteBuffer分配内存"></a>使用堆外内存为ByteBuffer分配内存</h2><p>JDK接收请求的拷贝次数</p><ol><li><code>网卡</code> -&gt; <code>内核空间</code>, 使用DMA</li><li><code>内核空间</code> -&gt; <code>用户空间</code>, 系统调用触发</li><li><code>堆外内存</code> -&gt; <code>堆内存</code>, JVM拷贝</li></ol><p>Netty使用堆外内存的好处</p><ol><li>减少一次拷贝</li><li>手动引用计数维护内存可以减少FGC</li></ol><h1 id="Recycler对象池"><a href="#Recycler对象池" class="headerlink" title="Recycler对象池"></a>Recycler对象池</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Netty选择使用堆外内存存储网络通信数据</p><ol><li>在JVM堆中创建一个用于引用native memory的引用对象<code>DirectByteBuffer</code></li><li>使用native方法<code>unsafe.allocateMemory</code>通过底层<code>malloc</code>系统调用申请一块堆外内存, 然后被<code>DirectByteBuffer</code>引用</li></ol><p>Netty面对的高并发网络通信场景下, 申请堆外内存是一个非常频繁的操作, 这种大量频繁的内存申请释放操作对程序的性能影响是巨大的, 所以Netty就引入了内存池对内存相关的操作进行统一的管理</p><h2 id="对象在JVM中创建和回收开销"><a href="#对象在JVM中创建和回收开销" class="headerlink" title="对象在JVM中创建和回收开销"></a>对象在JVM中创建和回收开销</h2><p>略过</p><h2 id="对象池Recycler"><a href="#对象池Recycler" class="headerlink" title="对象池Recycler"></a>对象池Recycler</h2><p><img src="/../../../../image/netty7-1.png" alt="对象池接口"></p><p>Netty中每个被池化的对象中都会引用对象池的实例<code>RECYCLER</code></p><p>每个池化对象中都会包含一个<code>recyclerHandle</code>, 是池化对象在对象池中的句柄, 是由对象池在创建对象后传递进来的</p><ul><li>获取对象: <code>RECYCLER.get()</code></li><li>删除对象: <code>recyclerHandle.recycle(this)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Channel#write使用的缓存ChannelOutboundBuffer中保存的对象Entry</span></span><br><span class="line"><span class="comment">// 以Entry为例看一下如何使用对象池</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(handle -&gt; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(handle));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;Entry&gt; recyclerHandle;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Entry</span><span class="params">(Handle&lt;Entry&gt; recyclerHandle)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.recyclerHandle = recyclerHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请对象</span></span><br><span class="line">    <span class="keyword">static</span> Entry <span class="title function_">newInstance</span><span class="params">(Object msg, <span class="type">int</span> size, <span class="type">long</span> total, ChannelPromise promise)</span> &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> RECYCLER.get();</span><br><span class="line">        entry.msg = msg;</span><br><span class="line">        entry.pendingSize = size + CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD;</span><br><span class="line">        entry.total = total;</span><br><span class="line">        entry.promise = promise;</span><br><span class="line">        <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">        bufs = <span class="literal">null</span>;</span><br><span class="line">        buf = <span class="literal">null</span>;</span><br><span class="line">        msg = <span class="literal">null</span>;</span><br><span class="line">        promise = <span class="literal">null</span>;</span><br><span class="line">        progress = <span class="number">0</span>;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">        pendingSize = <span class="number">0</span>;</span><br><span class="line">        count = -<span class="number">1</span>;</span><br><span class="line">        cancelled = <span class="literal">false</span>;</span><br><span class="line">        handle.recycle(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Recycler总体设计"><a href="#Recycler总体设计" class="headerlink" title="Recycler总体设计"></a>Recycler总体设计</h2><p><img src="/../../../../image/netty7-2.png" alt="Recycler总体设计"></p><h3 id="获取对象无锁化设计"><a href="#获取对象无锁化设计" class="headerlink" title="获取对象无锁化设计"></a>获取对象无锁化设计</h3><p>每个线程拥有一个独立Stack, 这样当多个线程并发从对象池中获取对象时, 都是从自己线程中的Stack中获取, 全程无锁化运行, JVM的堆内存分配也是这样(TLAB), 但是JVM提供的堆外内存分配为了防止内存泄漏是全局加锁的(堆外不能自动GC)</p><h3 id="释放对象无锁化设计"><a href="#释放对象无锁化设计" class="headerlink" title="释放对象无锁化设计"></a>释放对象无锁化设计</h3><p>thread2释放thread1获取的对象, 就需要操作thread1的stack, 可能产生多线程冲突</p><p>引入<code>WeakOrderQueue</code>链表, 每个<code>WeakOrderQueue</code>表示一个其他线程回收的该线程的对象, 获取对象时取不到对象就去<code>WeakOrderQueue</code>取</p><p>对象池回收对象的一个原则就是对象由谁创建的, 最终就要被回收到创建线程对应的<code>Stack</code>结构中的数组栈中, 数组栈中存放的才是真正被回收的池化对象, 可以直接被取出复用, 回收线程只能将待回收对象暂时存放至创建线程对应的<code>Stack</code>结构中的<code>WeakOrderQueue</code>链表中, 当数组栈中没有对象时, 由创建线程将<code>WeakOrderQueue</code>链表中的待回收对象转移至数组栈中</p><p><code>WeakOrderQueue</code>链表, <code>创建线程</code>使用head指针获取可以被回收的对象, <code>回收线程</code>使用tail指针插入需要被回收的对象, Netty这里为了不引入多线程同步的开销, 只会保证待回收对象的最终可见性, 会存在线程可见性的问题(维护线程之间操作的原子性, 可见性都是需要开销的, netty为了提高多线程的运行效率, 避免引入不必要的同步开销)</p><h2 id="Recycler实现"><a href="#Recycler实现" class="headerlink" title="Recycler实现"></a>Recycler实现</h2><p>Handle是池化对象在对象池中的一个模型, 默认实现是DefaultHandle</p><p><code>stack</code>和<code>WeakOrderQueue</code>中存的就是handle</p><p>在创建对象池的时候, 需要通过<code>ObjectCreator#newObject</code>方法指定对象池创建对象的行为即<code>Handle</code></p><p><img src="/../../../../image/netty7-3.png" alt="创建ObjectPool"></p><h1 id="Netty发送数据流程"><a href="#Netty发送数据流程" class="headerlink" title="Netty发送数据流程"></a>Netty发送数据流程</h1><h2 id="write方法发送数据"><a href="#write方法发送数据" class="headerlink" title="write方法发送数据"></a>write方法发送数据</h2><p><img src="/../../../../image/netty8-1.png" alt="write事件传播流程"></p><ul><li><code>channelHandlerContext.write()</code>方法会从<code>当前ChannelHandler</code>开始在pipeline中向前传播write事件直到<code>HeadContext</code></li><li><code>channelHandlerContext.channel().write()</code>会从pipeline的尾结点<code>TailContext</code>开始在pipeline中向前传播write事件直到<code>HeadContext</code></li></ul><p>Netty的写操作是一个异步操作, 当我们在业务线程中调用<code>channelHandlerContext.write()</code>后, Netty会给我们返回一个<code>ChannelFuture</code>, 我们可以在这个<code>ChannelFutrue</code>中添加<code>ChannelFutureListener</code>, 这样要发送的数据发送到底层Socket中时, Netty会通过<code>ChannelFutureListener</code>通知我们写入结果</p><p>当异步事件在pipeline传播的过程中发生异常时就会停止传播。所以我们在日常开发中, 需要对写操作异常情况进行处理</p><h2 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h2><h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><h2 id="Socket写满16次未写完"><a href="#Socket写满16次未写完" class="headerlink" title="Socket写满16次未写完"></a>Socket写满16次未写完</h2><h2 id="处理OP-WRITE"><a href="#处理OP-WRITE" class="headerlink" title="处理OP_WRITE"></a>处理OP_WRITE</h2><h2 id="writeAndFlush"><a href="#writeAndFlush" class="headerlink" title="writeAndFlush"></a>writeAndFlush</h2><h1 id="Pipeline-详解所有-IO-事件的触发时机以及传播路径"><a href="#Pipeline-详解所有-IO-事件的触发时机以及传播路径" class="headerlink" title="Pipeline, 详解所有 IO 事件的触发时机以及传播路径"></a>Pipeline, 详解所有 IO 事件的触发时机以及传播路径</h1><h2 id="Pipeline的创建"><a href="#Pipeline的创建" class="headerlink" title="Pipeline的创建"></a>Pipeline的创建</h2><h3 id="HeadContext"><a href="#HeadContext" class="headerlink" title="HeadContext"></a>HeadContext</h3><h3 id="TailContext"><a href="#TailContext" class="headerlink" title="TailContext"></a>TailContext</h3><p><code>TailContext</code>作为一个<code>ChannelHandlerContext</code></p><p><code>TailContext</code>作为一个<code>ChannelInbondHandler</code></p><h2 id="Pipeline中的事件"><a href="#Pipeline中的事件" class="headerlink" title="Pipeline中的事件"></a>Pipeline中的事件</h2><h3 id="Inbond事件"><a href="#Inbond事件" class="headerlink" title="Inbond事件"></a>Inbond事件</h3><h3 id="OutBond事件"><a href="#OutBond事件" class="headerlink" title="OutBond事件"></a>OutBond事件</h3><h2 id="向Pipeline添加ChannelHandler"><a href="#向Pipeline添加ChannelHandler" class="headerlink" title="向Pipeline添加ChannelHandler"></a>向Pipeline添加ChannelHandler</h2><h2 id="ChannelHandlerContext的创建"><a href="#ChannelHandlerContext的创建" class="headerlink" title="ChannelHandlerContext的创建"></a>ChannelHandlerContext的创建</h2><h2 id="从pipeline删除ChannelHandler"><a href="#从pipeline删除ChannelHandler" class="headerlink" title="从pipeline删除ChannelHandler"></a>从pipeline删除ChannelHandler</h2><h2 id="初始化pipeline"><a href="#初始化pipeline" class="headerlink" title="初始化pipeline"></a>初始化pipeline</h2><h2 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h2><h1 id="Netty-如何处理-TCP-连接的正常关闭-异常关闭-半关闭场景"><a href="#Netty-如何处理-TCP-连接的正常关闭-异常关闭-半关闭场景" class="headerlink" title="Netty 如何处理 TCP 连接的正常关闭, 异常关闭, 半关闭场景"></a>Netty 如何处理 TCP 连接的正常关闭, 异常关闭, 半关闭场景</h1><h2 id="TCP连接正常关闭"><a href="#TCP连接正常关闭" class="headerlink" title="TCP连接正常关闭"></a>TCP连接正常关闭</h2><h2 id="Netty处理TCP连接正常关闭"><a href="#Netty处理TCP连接正常关闭" class="headerlink" title="Netty处理TCP连接正常关闭"></a>Netty处理TCP连接正常关闭</h2><h2 id="TCP连接异常关闭"><a href="#TCP连接异常关闭" class="headerlink" title="TCP连接异常关闭"></a>TCP连接异常关闭</h2><h2 id="Netty对RST包的处理"><a href="#Netty对RST包的处理" class="headerlink" title="Netty对RST包的处理"></a>Netty对RST包的处理</h2><h2 id="TCP连接半关闭HalfClosure"><a href="#TCP连接半关闭HalfClosure" class="headerlink" title="TCP连接半关闭HalfClosure"></a>TCP连接半关闭HalfClosure</h2><h2 id="主动关闭方发起TCP半关闭"><a href="#主动关闭方发起TCP半关闭" class="headerlink" title="主动关闭方发起TCP半关闭"></a>主动关闭方发起TCP半关闭</h2><h2 id="被动关闭放处理TCP半关闭"><a href="#被动关闭放处理TCP半关闭" class="headerlink" title="被动关闭放处理TCP半关闭"></a>被动关闭放处理TCP半关闭</h2><hr><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483737&idx=1&sn=7ef3afbb54289c6e839eed724bb8a9d6">聊聊Netty那些事儿之从内核角度看IO模型</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483907&idx=1&sn=084c470a8fe6234c2c9461b5f713ff30">聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484005&idx=1&sn=52f51269902a58f40d33208421109bc3">详细图解Netty Reactor启动全流程</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484087&idx=1&sn=0c065780e0f05c23c8e6465ede86cba0">一文聊透Netty核心引擎Reactor的运转架构</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484184&idx=1&sn=726877ce28cf6e5d2ac3225fae687f19">抓到Netty一个Bug, 聊一下Netty是如何高效接收网络连接的</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484244&idx=1&sn=831060fc38caa201d69f87305de7f86a">Netty如何高效接收网络数据？ByteBuffer动态自适应扩缩容机制</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484419&idx=1&sn=3a75a495f0f117cca1548da1e0f3e6e6">抓到Netty一个内存泄露Bug | 详解Recycler对象池的设计与实现</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484532&idx=1&sn=c3a8b37a2eb09509d9914494ef108c68">Netty发送数据全流程</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484823&idx=1&sn=9396fb0f5dbac5e32d0fa1129d385fbc">Netty IO 事件的编排利器 pipeline | 所有 IO 事件的触发时机以及传播路径</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247485060&idx=1&sn=736360af6eb3a4db496de2d6665ebd3c">Netty 如何应对 TCP 连接的正常关闭, 异常关闭, 半关闭场景</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理HTTP接口上传文件大小超限异常</title>
      <link href="/2022-05-13-HTTP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%B6%85%E9%99%90%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9EHTTP-body.html"/>
      <url>/2022-05-13-HTTP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%B6%85%E9%99%90%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9EHTTP-body.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一个上传文件的HTTP POST接口，传参使用form-data格式，后端Java服务使用<code>MultipartFile</code>接收，在上传大文件后接口返回nginx 413错误</p><p>测试环境浏览器的请求直接发到应用服务器，请求发到80端口后nginx根据不同前缀将请求转发到对应Java服务的监听端口</p><h1 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h1><h2 id="nginx限制"><a href="#nginx限制" class="headerlink" title="nginx限制"></a>nginx限制</h2><p>nginx限制请求的大小，配置<code>client_max_body_size</code>生效，判断HTTP请求的大小依据是header中的<code>Content-Length</code>值</p><ul><li>size &lt; client_body_buffer_size, 请求留在内存中</li><li>client_body_buffer_size &lt; size &lt; client_max_body_size, 请求保存在临时文件中</li><li>client_max_body_size &lt; size, 返回413 Request Entity Too Large错误</li></ul><p><a href="https://blog.51cto.com/tinywan/2867647">Nginx系列 | [转]Nginx 上传文件：client_max_body_size 、client_body_buffer_size_Tinywan的技术博客_51CTO博客</a></p><p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size">Module ngx_http_core_module client_body_buffer_size</a></p><p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">Module ngx_http_core_module client_max_body_size</a></p><p>调大<code>client_max_body_size</code>值后，请求成功发送到后端服务，但是返回的response body为空</p><h2 id="文件过大抛出异常"><a href="#文件过大抛出异常" class="headerlink" title="文件过大抛出异常"></a>文件过大抛出异常</h2><p>查看后端服务日志，系统抛出了异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.multipart.MaxUploadSizeExceededException: Maximum upload size of 104857600 bytes exceeded; nested exception is org.apache.commons.fileupload.FileUploadBase$SizeLimitExceededException: the request was rejected because its size (113107647) exceeds the configured maximum (104857600)</span><br><span class="line">at org.springframework.web.multipart.commons.CommonsMultipartResolver.parseRequest(CommonsMultipartResolver.java:162)</span><br><span class="line">at org.springframework.web.multipart.commons.CommonsMultipartResolver$1.initializeMultipart(CommonsMultipartResolver.java:134)</span><br><span class="line">at org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest.getMultipartFiles(AbstractMultipartHttpServletRequest.java:140)</span><br><span class="line">at org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest.getFiles(AbstractMultipartHttpServletRequest.java:92)</span><br><span class="line">Caused by: org.apache.commons.fileupload.FileUploadBase$SizeLimitExceededException: the request was rejected because its size (113107647) exceeds the configured maximum (104857600)</span><br><span class="line">at org.apache.commons.fileupload.FileUploadBase$FileItemIteratorImpl.&lt;init&gt;(FileUploadBase.java:968)</span><br><span class="line">at org.apache.commons.fileupload.FileUploadBase.getItemIterator(FileUploadBase.java:310)</span><br><span class="line">at org.apache.commons.fileupload.FileUploadBase.parseRequest(FileUploadBase.java:334)</span><br><span class="line">at org.apache.commons.fileupload.servlet.ServletFileUpload.parseRequest(ServletFileUpload.java:115)</span><br><span class="line">at org.springframework.web.multipart.commons.CommonsMultipartResolver.parseRequest(CommonsMultipartResolver.java:158)</span><br><span class="line">... 50 common frames omitted</span><br></pre></td></tr></table></figure><p>可以看到，spring-web使用commons-fileupload包处理文件上传，限制文件大小<code>FileUploadBase</code>的<code>sizeMax</code>，参考类<code>CommonsFileUploadSupport</code>的相关初始化逻辑和<code>DispatcherServletAutoConfiguration.DispatcherServletConfiguration</code>的<code>multipartResolver</code>的注入逻辑，可以自定义一个MultipartResolver设置size限制并注入框架</p><p>本系统自定义一个<code>multipartResolver</code>并<code>setMaxUploadSize(100 * 1024 * 1024)</code>，限制文件最大100M，文件过大就会抛出上面的<code>MaxUploadSizeExceededException</code>和<code>FileUploadBase$SizeLimitExceededException</code></p><p>因此我在自定义的<code>GlobalExceptionResolver</code>中加入对这两个exception的处理，打印日志并返回错误信息</p><p>上传大文件后在<strong>测试</strong>环境进行测试，该异常被捕获并执行了处理逻辑，但是前端收到的response依然没有HTTP body。奇怪的是，使用postman请求<strong>本地</strong>的后端服务可以正常返回错误信息</p><h2 id="跟踪写HTTP-response的过程"><a href="#跟踪写HTTP-response的过程" class="headerlink" title="跟踪写HTTP response的过程"></a>跟踪写HTTP response的过程</h2><p>初步排查思路是跟踪spring-web把对象写到http body中的过程，查找是哪一步出了问题</p><p>debug排查发现，我们在<code>DispatcherServlet</code>中处理的<code>HttpServletRequest request</code>实体是tomcat的<code>RequestFacade</code>，使用facade外观模式，核心是<code>org.apache.catalina.connector.Request request</code>的<code>org.apache.coyote.Request coyoteRequest</code></p><p>将对象写入http body的json序列化流程正常，但是我注意到本地环境的response header有一项<code>Transfer-Encoding: chunked</code>，测试环境的response header中没有这一项而多了<code>Connection: close</code>。body的写入使用outputStream，导致本地调试无法看到body值，header中的这个区别有可能就是导致测试环境异常的原因，因此我们开始检查是哪一步设置的connection&#x3D;close</p><p>跟踪调用栈：</p><ul><li>DispatcherServlet.doService()</li><li>DispatcherServlet.doDispatch()</li><li>DispatcherServlet.processDispatchResult()</li><li>DispatcherServlet.render()</li><li>AbstractView.render()</li><li>AbstractJackson2View.renderMergedOutputModel(), 从这里开始就是单纯的对象序列化为json字符串</li><li>AbstractJackson2View.writeContent()</li><li>com.fasterxml.jackson.databind.ObjectMapper.writeValue()</li><li>DefaultSerializerProvider.serializeValue()</li><li>DefaultSerializerProvider._serialize()</li><li>serialize()</li></ul><p>但是流程中观察到的对body流的写入都是正常的，各种字段类型的序列化也都使用了正确的序列化类，也没有找到设置connection的逻辑</p><h2 id="监测HTTP-header的写操作"><a href="#监测HTTP-header的写操作" class="headerlink" title="监测HTTP header的写操作"></a>监测HTTP header的写操作</h2><p>从序列化流程开始逐步跟踪没有找到修改时机，我们改为监控所有修改response header操作，找到目标后再根据调用栈查看修改操作的调用方</p><p>response header最终保存在<code>org.apache.coyote.Request coyoteRequest</code>的<code>headers</code>字段中，所以我们在<code>MimeHeaders</code>类的<code>addValue()</code>和<code>setValue()</code>中打断点观察，最终发现是tomcat的<code>Http11Processor</code>在返回response前对消息体进行了统一修改，以符合各种RFC协议的要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When committing the response, we have to validate the set of headers, as well as setup the response filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">entityBody</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    contentDelimitation = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    OutputFilter[] outputFilters = outputBuffer.getFilters();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http09 == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// HTTP/0.9</span></span><br><span class="line">        outputBuffer.addActiveFilter(outputFilters[Constants.IDENTITY_FILTER]);</span><br><span class="line">        outputBuffer.commit();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> response.getStatus();</span><br><span class="line">    <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode == <span class="number">204</span> || statusCode == <span class="number">205</span> ||</span><br><span class="line">            statusCode == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="comment">// No entity body</span></span><br><span class="line">        outputBuffer.addActiveFilter</span><br><span class="line">            (outputFilters[Constants.VOID_FILTER]);</span><br><span class="line">        entityBody = <span class="literal">false</span>;</span><br><span class="line">        contentDelimitation = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="number">205</span>) &#123;</span><br><span class="line">            <span class="comment">// RFC 7231 requires the server to explicitly signal an empty response in this case</span></span><br><span class="line">            response.setContentLength(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setContentLength(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for compression</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isCompressible</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">useCompression</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (entityBody &amp;&amp; (compressionLevel &gt; <span class="number">0</span>) &amp;&amp; sendfileData == <span class="literal">null</span>) &#123;</span><br><span class="line">        isCompressible = isCompressible();</span><br><span class="line">        <span class="keyword">if</span> (isCompressible) &#123;</span><br><span class="line">            useCompression = useCompression();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Change content-length to -1 to force chunking</span></span><br><span class="line">        <span class="keyword">if</span> (useCompression) &#123;</span><br><span class="line">            response.setContentLength(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">MimeHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> response.getMimeHeaders();</span><br><span class="line">    <span class="comment">// A SC_NO_CONTENT response may include entity headers</span></span><br><span class="line">    <span class="keyword">if</span> (entityBody || statusCode == HttpServletResponse.SC_NO_CONTENT) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> response.getContentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">            headers.setValue(<span class="string">&quot;Content-Type&quot;</span>).setString(contentType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentLanguage</span> <span class="operator">=</span> response.getContentLanguage();</span><br><span class="line">        <span class="keyword">if</span> (contentLanguage != <span class="literal">null</span>) &#123;</span><br><span class="line">            headers.setValue(<span class="string">&quot;Content-Language&quot;</span>)</span><br><span class="line">                .setString(contentLanguage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add date header unless application has already set one (e.g. in a Caching Filter)</span></span><br><span class="line">    <span class="keyword">if</span> (headers.getValue(<span class="string">&quot;Date&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        headers.addValue(<span class="string">&quot;Date&quot;</span>).setString(</span><br><span class="line">                FastHttpDateFormat.getCurrentDate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entityBody) &amp;&amp; (!contentDelimitation)) &#123;</span><br><span class="line">        <span class="comment">// Mark as close the connection after the request, and add the connection: close header</span></span><br><span class="line">        keepAlive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This may disabled keep-alive to check before working out the Connection header.</span></span><br><span class="line">    checkExpectationAndResponseStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know that the request is bad this early, add the Connection: close header.</span></span><br><span class="line">    <span class="keyword">if</span> (keepAlive &amp;&amp; statusDropsConnection(statusCode)) &#123;</span><br><span class="line">        keepAlive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!keepAlive) &#123;</span><br><span class="line">        <span class="comment">// Avoid adding the close header twice</span></span><br><span class="line">        <span class="keyword">if</span> (!connectionClosePresent) &#123;</span><br><span class="line">            headers.addValue(Constants.CONNECTION).setString(Constants.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!http11 &amp;&amp; !getErrorState().isError()) &#123;</span><br><span class="line">        headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outputBuffer.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么本地环境和测试环境的区别在哪里呢？在最后判断Connection为close还是keep-alive的时候，processor根据请求的http版本执行不同操作，本地环境读到的是HTTP1.1，而测试环境读到的是HTTP1.0，就设置为了close。在浏览器的控制台-network中看到的protocol明明是h2，为什么后端服务读取到的是1.0呢？</p><p><a href="https://www.zhihu.com/question/321943562">浏览器发起http请求时候，如何知道服务器支持什么http 版本？ - 知乎</a><br><a href="https://segmentfault.com/q/1010000010612052">HTTP的版本是什么决定的，浏览器，服务器？ - SegmentFault 思否</a></p><p>越过nginx直接指定端口请求测试环境的服务，正常返回response body，因此判断是浏览器客户端和服务器协商HTTP版本时由于nginx限制没有成功使用</p><p>nginx增加配置项<code>proxy_http_version 1.1;</code>后，测试环境接口返回成功</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在找到了设置header的代码后再看下之前为什么debug没有跟踪到，设置header的调用栈：</p><ul><li>UTF8JsonGenerator.flush()</li><li>CoyoteOutputStream.flush()</li><li>org.apache.catalina.connector.OutputBuffer.flush()</li><li>OutputBuffer.doFlush()</li><li>org.apache.coyote.Response.sendHeaders()</li><li>Response.action(), 这里的hook是<code>Http11Processor</code></li><li>AbstractProcessor.prepareResponse()</li><li>Http11Processor.prepareResponse()</li></ul><p>谁能想到名为<code>OutputStream</code>和<code>OutputBuffer</code>的类的flush方法竟然会执行这么多业务操作呢:(</p><p>POSTMAN不支持指定HTTP1.0，有这个需求可以导出curl指令后使用curl实现，增加<code>-0</code>参数</p><p><a href="https://community.postman.com/t/how-to-change-http-protocol-version-to-http-1-0/3963">How to change HTTP protocol version to HTTP 1.0 - Help - Postman</a></p><p>在网上看到其他人遇到的相似问题</p><p><a href="https://blog.csdn.net/qq_38531706/article/details/117448200">Nginx proxy_http_version默认值引发的问题__alone_的博客-CSDN博客_proxy_http_version</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《凤凰架构》读书摘要</title>
      <link href="/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
      <url>/2022-01-14-%E3%80%8A%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://icyfenix.cn/summary/">原文链接</a></p><h1 id="服务架构演进史"><a href="#服务架构演进史" class="headerlink" title="服务架构演进史"></a>服务架构演进史</h1><h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><blockquote><p>UNIX 的分布式设计哲学 保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要</p></blockquote><p>在 20 世纪 70 年代末期到 80 年代初，计算机科学刚经历了从以大型机为主向以微型机为主的蜕变，当时计算机硬件局促的运算处理能力，已直接妨碍到了在单台计算机上信息系统软件能够达到的最大规模</p><p>某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果</p><p>20 世纪 80 年代正是摩尔定律开始稳定发挥作用的黄金时期，信息系统进入了以单台或少量几台计算机即可作为服务器来支撑大型信息系统运作的单体时代</p><h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><blockquote><p>单体架构（Monolithic） “单体”只是表明系统中主要的过程调用都是进程内调用，不会发生进程间通信，仅此而已</p></blockquote><p>对于小型系统——即由单台机器就足以支撑其良好运行的系统，单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信（Inter-Process Communication，IPC），因此也是运行效率最高的一种架构风格</p><p><strong>优点</strong></p><ul><li><p>易于开发、易于测试、易于部署</p></li><li><p>由于所有代码都运行在同一个进程空间之内，所有模块、方法的调用都无须考虑网络分区、对象复制这些麻烦的事和性能损失</p></li></ul><p><strong>缺点</strong></p><ul><li><p>如果任何一部分代码出现了缺陷，过度消耗了进程空间内的资源，所造成的影响也是全局性的、难以隔离的。譬如内存泄漏、线程爆炸、阻塞、死循环等问题，都将会影响整个程序，而不仅仅是影响某一个功能、模块本身的正常运作。如果消耗的是某些更高层次的公共资源，譬如端口号或者数据库连接池泄漏，影响还将会波及整台机器，甚至是集群中其他单体副本的正常工作</p></li><li><p>由于所有代码都共享着同一个进程空间，不能隔离，也就无法（其实还是有办法的，譬如使用 OSGi 这种运行时模块化框架，但是很别扭、很复杂）做到单独停止、更新、升级某一部分代码，所以从可维护性来说，单体系统也是不占优势的</p></li><li><p>难以技术异构，每个模块的代码都通常需要使用一样的程序语言，乃至一样的编程框架去开发。单体系统的技术栈异构并非一定做不到，譬如 JNI 就可以让 Java 混用 C 或 C++，但这通常是迫不得已的，并不是优雅的选择</p></li><li><p>单体系统很难兼容“Phoenix”的特性。这种架构风格潜在的观念是希望系统的每一个部件，每一处代码都尽量可靠，靠不出或少出缺陷来构建可靠系统。然而战术层面再优秀，也很难弥补战略层面的不足，单体靠高质量来保证高可靠性的思路，在小规模软件上还能运作良好，但系统规模越大，交付一个可靠的单体系统就变得越来越具有挑战性</p></li></ul><h2 id="SOA时代"><a href="#SOA时代" class="headerlink" title="SOA时代"></a>SOA时代</h2><blockquote><p>SOA 架构（Service-Oriented Architecture） 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式</p></blockquote><ol><li>烟囱式架构, 完全不与其他相关信息系统进行互操作或者协调工作的设计模式</li><li>微内核架构（Microkernel Architecture）：也被称为插件式架构（Plug-in Architecture）将主数据，连同其他可能被各子系统使用到的公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心（Kernel），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样可提供可扩展的、灵活的、天然隔离的功能特性</li><li>事件驱动架构（Event-Driven Architecture）：在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去，如此，每一个消息的处理者都是独立的，高度解耦的，但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动</li></ol><ul><li>领导制定技术标准的组织 Open CSA</li><li>明确了采用 SOAP 作为远程调用的协议，依靠 SOAP 协议族（WSDL、UDDI 和一大票 WS-*协议）来完成服务的发布、发现和治理</li><li>利用一个被称为企业服务总线（的消息管道来实现各个子系统之间的通信交互</li><li>使用服务数据对象来访问和表示数据</li><li>使用服务组件架构来定义服务封装的形式和服务运行的容器</li></ul><p><strong>缺点</strong></p><p>过于严格的规范定义带来过度的复杂性。而构建在 SOAP 基础之上的 ESB、BPM、SCA、SDO 等诸多上层建筑，进一步加剧了这种复杂性</p><h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><blockquote><p>微服务架构（Microservices）<br>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</p></blockquote><p>微服务追求的是更加自由的架构风格，摒弃了几乎所有 SOA 里可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”</p><h2 id="后微服务时代"><a href="#后微服务时代" class="headerlink" title="后微服务时代"></a>后微服务时代</h2><blockquote><p>后微服务时代（Cloud Native）<br>从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”</p></blockquote><p>以 Docker Swarm、Apache Mesos 与 Kubernetes 为主要竞争者的“容器编排战争”终于有了明确的结果，Kubernetes 登基加冕是容器发展中一个时代的终章，也将是软件架构发展下一个纪元的开端</p><p>传统 Spring Cloud 与 Kubernetes 提供的解决方案对比</p><table><thead><tr><th>Kubernetes</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>弹性伸缩</td><td>Autoscaling N&#x2F;A</td></tr><tr><td>服务发现</td><td>KubeDNS, CoreDNS Spring Cloud Eureka</td></tr><tr><td>配置中心</td><td>ConfigMap, Secret Spring Cloud Config</td></tr><tr><td>服务网关</td><td>Ingress Controller Spring Cloud Zuul</td></tr><tr><td>负载均衡</td><td>Load Balancer Spring Cloud Ribbon</td></tr><tr><td>服务安全</td><td>RBAC API Spring Cloud Security</td></tr><tr><td>跟踪监控</td><td>Metrics API, Dashboard Spring Cloud Turbine</td></tr><tr><td>降级熔断</td><td>N&#x2F;A Spring Cloud Hystrix</td></tr></tbody></table><p>仅从功能上看，单纯的 Kubernetes 反而不如之前的 Spring Cloud 方案。这是因为有一些问题处于应用系统与基础设施的边缘，使得完全在基础设施层面中确实很难精细化地处理。通过 Spring Cloud 这类应用代码实现的微服务中并不难处理，既然是使用程序代码来解决问题，只要合乎逻辑，想要实现什么功能，只受限于开发人员的想象力与技术能力，但基础设施是针对整个容器来管理的，粒度相对粗旷，只能到容器层面，对单个远程服务就很难有效管控</p><p>为了解决这一类问题，虚拟化的基础设施很快完成了第二次进化，引入了今天被称为“服务网格”（Service Mesh）的“边车代理模式”（Sidecar Proxy）</p><p>由系统自动在服务容器（通常是指 Kubernetes 的 Pod）中注入一个通信代理服务器，以类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理</p><h2 id="无服务时代"><a href="#无服务时代" class="headerlink" title="无服务时代"></a>无服务时代</h2><blockquote><p>无服务架构（Serverless）如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布式”的云端系统这条路的起点</p></blockquote><p>只涉及两块内容：后端设施（Backend）和函数（Function）</p><ul><li>后端设施是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，无服务中称其为“后端即服务”（Backend as a Service，BaaS）</li><li>函数是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，不必考虑容量规划（从技术角度可以不考虑，从计费的角度你的钱包够不够用还是要掂量一下的），无服务中称其为“函数即服务”（Function as a Service，FaaS）</li></ul><p>无服务架构对一些适合的应用确实能够降低开发和运维环节的成本，譬如不需要交互的离线大规模计算，又譬如多数 Web 资讯类网站、小程序、公共 API 服务、移动应用服务端等都契合于无服务架构所擅长的短链接、无状态、适合事件驱动的交互形式；但另一方面，对于那些信息管理系统、网络游戏等应用，又或者说所有具有业务逻辑复杂，依赖服务端状态，响应速度要求较高，需要长链接等这些特征的应用，至少目前是相对并不适合的</p><p>顺序上笔者将“无服务”安排到了“微服务”和“云原生”时代之后，但它们两者并没有继承替代关系，笔者相信软件开发的未来不会只存在某一种“最先进的”架构风格，多种具针对性的架构风格同时并存，是软件产业更有生命力的形态</p><h1 id="架构师的视角"><a href="#架构师的视角" class="headerlink" title="架构师的视角"></a>架构师的视角</h1><h2 id="访问远程服务"><a href="#访问远程服务" class="headerlink" title="访问远程服务"></a>访问远程服务</h2><h3 id="远程服务调用"><a href="#远程服务调用" class="headerlink" title="远程服务调用"></a>远程服务调用</h3><h4 id="调用本地方法"><a href="#调用本地方法" class="headerlink" title="调用本地方法"></a>调用本地方法</h4><ol><li>传递方法参数</li><li>确定方法版本</li><li>执行被调方法</li><li>返回执行结果</li></ol><p>1&#x2F;4依赖栈内存, 2依赖程序语言定义</p><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ol><li>管道, 在进程间传递少量的字符流或字节流</li><li>信号, 通知目标进程有某种事件发生, kill即shell向进程发送信号</li><li>信号量, wait() notify()</li><li>共享内存</li><li>Socket, 支持远程</li></ol><h4 id="分布式计算的八宗罪"><a href="#分布式计算的八宗罪" class="headerlink" title="分布式计算的八宗罪"></a>分布式计算的八宗罪</h4><ol><li>The network is reliable —— 网络是可靠的</li><li>Latency is zero —— 延迟是不存在的</li><li>Bandwidth is infinite —— 带宽是无限的</li><li>The network is secure —— 网络是安全的</li><li>Topology doesn’t change —— 拓扑结构是一成不变的</li><li>There is one administrator —— 总会有一个管理员</li><li>Transport cost is zero —— 不必考虑传输成本</li><li>The network is homogeneous —— 网络是同质化的</li></ol><h4 id="RPC的三个基本问题"><a href="#RPC的三个基本问题" class="headerlink" title="RPC的三个基本问题"></a>RPC的三个基本问题</h4><ol><li>如何表示数据, 各种协议</li><li>如何传递数据, 除了传输层的UDP&#x2F;TCP, 还包括应用层的wire protocal, 异常、超时、安全、认证、授权、事务等</li><li>如何确定方法</li></ol><h4 id="RPC的发展方向"><a href="#RPC的发展方向" class="headerlink" title="RPC的发展方向"></a>RPC的发展方向</h4><ol><li>面向对象, 不满足于 RPC 将面向过程的编码方式带到分布式，希望在分布式系统中也能够进行跨进程的面向对象编程，代表为 RMI、.NET Remoting</li><li>性能, 代表为 gRPC 和 Thrift, 决定 RPC 性能的主要就两个因素：序列化效率和信息密度。序列化效率很好理解，序列化输出结果的容量越小，速度越快，效率自然越高；信息密度则取决于协议中有效荷载（Payload）所占总传输数据的比例大小，使用传输协议的层次越高，信息密度就越低，SOAP 使用 XML 拙劣的性能表现就是前车之鉴。gRPC 和 Thrift 都有自己优秀的专有序列化器，而传输协议方面，gRPC 是基于 HTTP&#x2F;2 的，支持多路复用和 Header 压缩，Thrift 则直接基于传输层的 TCP 协议来实现，省去了额外应用层协议的开销</li><li>简化, 代表为 JSON-RPC</li></ol><h3 id="REST-设计风格"><a href="#REST-设计风格" class="headerlink" title="REST 设计风格"></a>REST 设计风格</h3><p>表征状态转移</p><ul><li>面向过程编程时，为什么要以算法和处理过程为中心，输入数据，输出结果？是为了符合计算机世界中主流的交互方式</li><li>面向对象编程时，为什么要将数据和行为统一起来、封装成对象？是为了符合现实世界的主流的交互方式</li><li>面向资源编程时，为什么要将数据（资源）作为抽象的主体，把行为看作是统一的接口？是为了符合网络世界的主流的交互方式</li></ul><h4 id="REST六大原则"><a href="#REST六大原则" class="headerlink" title="REST六大原则"></a>REST六大原则</h4><ul><li>服务端与客户端分离</li><li>无状态</li><li>可缓存</li><li>分层系统</li><li>统一接口</li><li>按需代码</li></ul><h4 id="REST好处"><a href="#REST好处" class="headerlink" title="REST好处"></a>REST好处</h4><ol><li>降低的服务接口的学习成本</li><li>资源天然具有集合与层次结构</li><li>REST 绑定于 HTTP 协议</li></ol><h4 id="REST缺点"><a href="#REST缺点" class="headerlink" title="REST缺点"></a>REST缺点</h4><ol><li>REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中</li><li>REST 没有传输可靠性支持</li><li>REST 缺乏对资源进行“部分”和“批量”的处理能力</li></ol><p>一种理论上较优秀的可以解决以上这几类问题的方案是GraphQL，这是由 Facebook 提出并开源的一种面向资源 API 的数据查询语言。比起依赖 HTTP 无协议的 REST，GraphQL 可以说是另一种“有协议”的、更彻底地面向资源的服务方式。然而凡事都有两面，离开了 HTTP，它又面临着几乎所有 RPC 框架所遇到的那个如何推广交互接口的问题。</p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul><li>一致性（Consistency）系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾</li><li>原子性（Atomic）在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销</li><li>隔离性（Isolation）在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响</li><li>持久性（Durability）事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据</li></ul><p>A、I、D 是手段，C 是目的</p><p>当一个服务只使用一个数据源时，通过 A、I、D 来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为__内部一致性__</p><p>当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，问题就变得相对困难了许多。此时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为__外部一致性__</p><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>直接依赖于数据源本身提供的事务能力来工作的，在程序代码层面，最多只能对事务接口做一层标准化的包装（如 JDBC 接口），与后续介绍的 XA、TCC、SAGA 等主要靠应用程序代码来实现的事务有着十分明显的区别</p><h4 id="实现原子性和隔离性"><a href="#实现原子性和隔离性" class="headerlink" title="实现原子性和隔离性"></a>实现原子性和隔离性</h4><p>写入中间状态与崩溃都不可能消除，所以如果不做额外保障措施的话，将内存中的数据写入磁盘，并不能保证原子性与持久性</p><p>使用 <strong>Commit Logging</strong> 实现</p><p>Commit Logging基于ARIES理论</p><p>将修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等，以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化</p><p>Write-Ahead Logging, 当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除</p><h4 id="实现隔离性"><a href="#实现隔离性" class="headerlink" title="实现隔离性"></a>实现隔离性</h4><p>现代数据库均提供了以下三种锁</p><ul><li>写锁（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）</li><li>读锁（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）</li><li>范围锁（Range Lock）, 在MySQL中实现为gap lock</li></ul><p>四个隔离级别</p><table><thead><tr><th>隔离级别</th><th>使用的锁</th><th>存在问题</th></tr></thead><tbody><tr><td>读未提交(Read Uncommitted)</td><td>写锁持续至事务结束,无读锁</td><td>脏读:在事务执行过程中,一个事务读取到了另一个事务未提交的数据(读数据不需要加读锁,写锁就限制不了读操作了)</td></tr><tr><td>读已提交(Read Committed)</td><td>写锁持续至事务结束,读锁在操作完成后马上释放</td><td>不可重复读:在事务执行过程中,对同一行数据的两次查询得到了不同的结果,即读到了另一个事务已提交的数据(写锁释放太早,限制不到其他事务加读锁)</td></tr><tr><td>可重复读(Repeatable Read)</td><td>写锁、读锁持续至事务结束</td><td>幻读:在事务执行过程中,两个完全相同的范围查询得到了不同的结果集,没有范围锁来禁止在该范围内插入新的数据</td></tr><tr><td>可串行化(Serializable)</td><td>写锁、读锁、范围所持续至事务结束</td><td>-</td></tr></tbody></table><h4 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h4><p>幻读、不可重复读、脏读等问题都是由于一个事务在读数据过程中，受另外一个写数据的事务影响而破坏了隔离性，针对这种“一个事务读+另一个事务写”的隔离问题，近年来有一种名为“多版本并发控制”（Multi-Version Concurrency Control，MVCC）的无锁优化方案被主流的商业数据库广泛采用。MVCC 是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的</p><h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><p>单个服务使用多个数据源场景</p><p>X&#x2F;Open组织（后来并入了The Open Group）提出了一套名为X&#x2F;Open XA（XA 是 eXtended Architecture 的缩写）的处理事务架构，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口</p><p>Java 中专门定义了JSR 907 Java Transaction API，基于 XA 模式在 Java 语言中的实现了全局事务处理的标准，这也就是我们现在所熟知的 JTA。JTA 最主要的两个接口是：</p><ol><li>事务管理器的接口：javax.transaction.TransactionManager。这套接口是给 Java EE 服务器提供容器事务（由容器自动负责事务管理）使用的，还提供了另外一套javax.transaction.UserTransaction接口，用于通过程序代码手动开启、提交和回滚事务。</li><li>满足 XA 规范的资源定义接口：javax.transaction.xa.XAResource，任何资源（JDBC、JMS 等等）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可</li></ol><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>XA 将事务提交拆分成为两阶段过程，“两段式提交”（2 Phase Commit，2PC）协议，协调者、参与者都是可以由数据库自己来扮演的，不需要应用程序介入。协调者一般是在参与者之间选举产生的，而应用程序相对于数据库来说只扮演客户端的角色</p><ol><li><p>准备阶段：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态</p></li><li><p>提交阶段：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作</p></li></ol><p>2PC的前提条件: </p><ol><li><p>必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息</p></li><li><p>必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态，当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，并向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作</p></li></ol><p>2PC的缺点:</p><ol><li><p>单点问题：协调者</p></li><li><p>性能问题：要经过两次远程服务调用，三次数据持久化</p></li><li><p>一致性风险：需要前提条件</p></li></ol><h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ol><li>canCommit，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成</li><li>preCommit</li><li>doCommit，未收到协调者返回，参与者默认的操作策略将是提交事务</li></ol><p>将2PC的prepare阶段分成两部分，增加了评估阶段，在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的，但在事务能够正常提交的场景中，两者的性能都依然很差，甚至三段式因为多了一次询问，还要稍微更差一些</p><p>缺点：单点问题、性能问题优于2PC，一致性风险大于2PC</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>多个服务同时访问多个数据源</p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>一个分布式的系统中，涉及共享数据问题时，以下三个特性最多只能同时满足其中两个：</p><ol><li><p>一致性（Consistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的</p></li><li><p>可用性（Availability）：代表系统不间断地提供服务的能力，可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A&#x3D;MTBF&#x2F;（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999%可用，即代表平均年故障修复时间为 32 秒</p></li><li><p>分区容忍性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力</p></li></ol><p>CAP舍弃其中一个:</p><ol><li><p>CA，不追求分区容忍性即认为节点之间通信永远可靠，不是分布式系统</p></li><li><p>CP，网络分区后服务不可用，退化为全局事务，使用2PC&#x2F;3PC，用于对数据要求很高的系统，HBase</p></li><li><p>AP，网络分区后服务可用但不同实例返回的数据可能不同，大部分nosql系统和分布式缓存</p></li></ol><h4 id="可靠事件队列-BASE"><a href="#可靠事件队列-BASE" class="headerlink" title="可靠事件队列 BASE"></a>可靠事件队列 BASE</h4><h4 id="TCC-事务"><a href="#TCC-事务" class="headerlink" title="TCC 事务"></a>TCC 事务</h4><h4 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h4><h2 id="透明多级分流系统"><a href="#透明多级分流系统" class="headerlink" title="透明多级分流系统"></a>透明多级分流系统</h2><p>系统中不同的组件:</p><ul><li>有一些部件位于客户端或网络的边缘，能够迅速响应用户的请求，避免给后方的 I&#x2F;O 与 CPU 带来压力，典型如本地缓存、内容分发网络、反向代理等。</li><li>有一些部件的处理能力能够线性拓展，易于伸缩，可以使用较小的代价堆叠机器来获得与用户数量相匹配的并发性能，应尽量作为业务逻辑的主要载体，典型如集群中能够自动扩缩的服务节点。</li><li>有一些部件稳定服务对系统运行有全局性的影响，要时刻保持着容错备份，维护着高可用性，典型如服务注册中心、配置中心。</li><li>有一些设施是天生的单点部件，只能依靠升级机器本身的网络、存储和运算性能来提升处理能力，如位于系统入口的路由、网关或者负载均衡器（它们都可以做集群，但一次网络请求中无可避免至少有一个是单点的部件）、位于请求调用链末端的传统关系数据库等</li></ul><p>两条原则:</p><ol><li><p>尽可能减少单点部件</p></li><li><p>奥卡姆剃刀原则</p></li></ol><p>几种优化:</p><ul><li>客户端缓存</li><li>域名解析</li><li>传输链路</li><li>内容分发网络</li><li>负载均衡</li><li><a href="http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cache-middleware.html">服务端缓存</a>, 介绍了传统意义上缓存的各个方面</li></ul><h2 id="架构安全性"><a href="#架构安全性" class="headerlink" title="架构安全性"></a>架构安全性</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><ul><li>RBAC, user&#x2F;role&#x2F;authority&#x2F;permission&#x2F;resource</li><li>OAuth2, 解决第三方应用的认证授权协议</li></ul><h3 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h3><ul><li>Cookie-Session, 受制于CAP理论</li><li>JWT, header+payload+sign</li></ul><h3 id="保密"><a href="#保密" class="headerlink" title="保密"></a>保密</h3><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h1 id="分布式的基石"><a href="#分布式的基石" class="headerlink" title="分布式的基石"></a>分布式的基石</h1><h2 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>Multi Paxos 对 Basic Paxos 的核心改进是增加了“选主”的过程</p><p>Raft 算法: 分布式系统中如何对某个值达成一致</p><ol><li>如何选主（Leader Election）</li><li>如何把数据复制到各个节点上（Entity Replication）</li><li>如何保证过程是安全的（Safety）</li></ol><p>Raft 是 Etcd、LogCabin、Consul 等重要分布式程序的实现基础, ZooKeeper 的 ZAB 算法与 Raft 的思路也非常类似，这些算法都被认为是 Multi Paxos 的等价派生实现。</p><h3 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h3><ul><li>强一致性, 尽管系统内部节点可以存在不一致的状态，但从系统外部看来不一致的情况并不会被观察到，所以整体上看系统是强一致性的, Paxos、Raft、ZAB</li><li>最终一致性, 系统中不一致的状态有可能会在一定时间内被外部直接观察到, DNS, Gossip</li></ul><h2 id="从类库到服务"><a href="#从类库到服务" class="headerlink" title="从类库到服务"></a>从类库到服务</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>实现</p><ol><li>全限定名(定位到主机)</li><li>端口号(tcp&#x2F;udp服务)</li><li>服务标识(具体接口)</li></ol><p>功能</p><ol><li>服务注册</li><li>服务维护</li><li>服务发现</li></ol><p>服务注册中心一旦崩溃，整个系统都不再可用，因此必须尽最大努力保证服务发现的可用性</p><p>CAP矛盾</p><ul><li>Eureka，AP，客户端拿到了已经发生变动的错误地址依赖故障转移（Failover）或者快速失败（Failfast）</li><li>Consul，CP</li></ul><p>选择AP&#x2F;CP</p><blockquote><p>假设系统形成了 A、B 两个网络分区后，A 区的服务只能从区域内的服务发现节点获取到 A 区的服务坐标，B 区的服务只能取到在 B 区的服务坐标，这对你的系统会有什么影响？</p></blockquote><ul><li>没有影响，AP</li><li>影响非常之大，甚至可能带来比整个系统宕机更坏的结果，CP</li></ul><p>实现方式</p><ul><li>在分布式 K&#x2F;V 存储框架上自己开发, ZooKeeper(CP), Etcd(CP), Redis(AP)</li><li>以基础设施（主要是指 DNS 服务器）来实现服务发现, SkyDNS、CoreDNS, AP&#x2F;CP取决于怎样实现</li><li>专门用于服务发现的框架和工具, Eureka(AP)、Consul(CP) 和 Nacos(AP&#x2F;CP)</li></ul><h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><p>网关 &#x3D; 路由器（基础职能） + 过滤器（可选职能）</p><p>网关是网络访问中的单点, 地址具有唯一性不能像服务中心一样做集群</p><h4 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h4><p>[以买饭为例]</p><ul><li>同步IO(Synchronous I&#x2F;O)<ul><li>阻塞IO(Blocking I&#x2F;O), 节省 CPU 资源(Java传统IO模型)</li><li>非阻塞IO(Non-Blocking I&#x2F;O), 浪费 CPU 资源(Java的NIO)</li><li>多路复用IO(Multiplexing I&#x2F;O), 主流(通过NIO实现的Reactor模式)</li><li>信号驱动IO(Signal-Driven I&#x2F;O), 需要自己从缓冲区获取数据</li></ul></li><li>异步IO(Asynchronous I&#x2F;O)(通过AIO实现的Proactor模式)</li></ul><h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p>请求的完整路径</p><ol><li>服务发现</li><li>网关路由</li><li>负载均衡</li><li>服务容错</li></ol><p>客户端指集群内部发起服务的进程</p><ul><li>Java, Netflix Ribbon, Spring Cloud Load Balancer</li><li>其他, 代理均衡器</li></ul><h2 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h2><p>服务降级</p><ul><li>出错后弥补</li><li>主动降级</li></ul><h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><p>失败如何弥补</p><ul><li>故障转移, 重试, 服务具备幂等性, 如果调用的服务器出现故障, 自动切换到其他副本</li><li>快速失败, 非幂等的服务, 拒绝重试, 抛出异常</li><li>安全失败, 不影响核心业务的旁路逻辑失败的话返回默认值</li><li>沉默失败, 当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响</li><li>故障恢复, 异步的故障转移<br>调用之前尽量获得最大的成功概率</li><li>并行调用, 同时调用多个副本, 返回一个成功即可</li><li>广播调用, 同时调用多个副本, 必须全部返回成功, 刷新分布式缓存</li></ul><table><thead><tr><th>容错策略</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>故障转移</td><td>系统自动处理，调用者对失败的信息不可见</td><td>增加调用时间，额外的资源开销</td><td>调用幂等服务, 对调用时间不敏感的场景</td></tr><tr><td>快速失败</td><td>调用者有对失败的处理完全控制权, 不依赖服务的幂等性</td><td>调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩</td><td>调用非幂等的服务, 超时阈值较低的场景</td></tr><tr><td>安全失败</td><td>不影响主路逻辑</td><td>只适用于旁路调用</td><td>调用链中的旁路服务</td></tr><tr><td>静默失败</td><td>控制错误不影响全局</td><td>出错的地方将在一段时间内不可用</td><td>频繁超时的服务</td></tr><tr><td>故障恢复</td><td>调用失败后自动重试，也不影响主路逻辑</td><td>重试任务可能产生堆积，重试仍然可能失败</td><td>调用链中的旁路服务, 对实时性要求不高的主路逻辑也可以使用</td></tr><tr><td>并行调用</td><td>尽可能在最短时间内获得最高的成功率</td><td>额外消耗机器资源，大部分调用可能都是无用功</td><td>资源充足且对失败容忍度低的场景</td></tr><tr><td>广播调用</td><td>支持同时对批量的服务提供者发起调用</td><td>资源消耗大，失败概率高</td><td>只适用于批量操作的场景</td></tr></tbody></table><h4 id="容错设计模式"><a href="#容错设计模式" class="headerlink" title="容错设计模式"></a>容错设计模式</h4><ul><li>断路器模式, 快速失败</li><li>舱壁隔离模式, 静默失败<ul><li>局部的线程池来控制服务, 缺点增加了 CPU 的开销, 增加请求延时</li><li>信号量机制, 为每个远程服务维护一个线程安全的计数器</li></ul></li><li>重试模式, 故障转移, 故障恢复<ul><li>仅在主路逻辑的关键服务上进行同步的重试, 尤其不该进行同步重试</li><li>仅对由瞬时故障导致的失败进行重试, 例如用http状态码来判断</li><li>仅对具备幂等性的服务进行重试</li><li>重试必须有明确的终止条件<ul><li>超时</li><li>次数限制</li></ul></li></ul></li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量统计指标</p><ul><li>TPS</li><li>HPS</li><li>QPS</li><li>流量, 登录用户数等</li></ul><p>限流设计模式</p><ul><li>流量计数器, 针对时间点进行离散的统计</li><li>滑动时间窗, 只适用于否决式限流，超过阈值的流量就必须强制失败或降级，很难进行阻塞等待处理</li><li>漏桶, 首先在缓冲区中暂存，然后再在控制算法的调节下均匀地发送这些被缓冲的报文, 不支持支持变动请求处理速率</li><li>令牌桶, 请求获取令牌</li></ul><p>分布式限流</p><ul><li>单机限流模式+各主机共享信息, 网络开销大</li><li>单机限流模式+本地缓存部分信息, 网络开销小, 不准确</li></ul><h3 id="可靠通讯"><a href="#可靠通讯" class="headerlink" title="可靠通讯"></a>可靠通讯</h3><p>基于边界的安全模型: 把网络划分为不同的区域，不同的区域对应于不同风险级别和允许访问的网络资源权限，将安全防护措施集中部署在各个区域的边界之上，重点关注跨区域的网络流量<br>零信任安全模型: 除非明确得到了能代表请求来源的身份凭证，否则一律不会有默认的信任关系</p><h4 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h4><ul><li>日志, Elasticsearch, Logstash(Fluentd), Kibana</li><li>追踪</li><li>度量, Java的JMX(单机), Kubernetes的Prometheus, Zabbix</li></ul><h1 id="不可变基础设施"><a href="#不可变基础设施" class="headerlink" title="不可变基础设施"></a>不可变基础设施</h1><p>云原生: 微服务, 容器网格, 不可变基础设施, 声明式API</p><p>软件兼容性</p><ul><li>ISA兼容: 机器指令集, x86&#x2F;ARM</li><li>ABI兼容: 操作系统或二进制库, Windows&#x2F;Linux, DirectX9&#x2F;DirectX12</li><li>环境兼容: 配置文件等</li></ul><p>虚拟化技术</p><ul><li>指令集虚拟化, 软件模拟指令集</li><li>硬件抽象层虚拟化, 以软件或者直接通过硬件来模拟处理器、芯片组、内存、磁盘控制器、显卡等设备, 虚拟机, VMware ESXi和Hyper-V</li><li>操作系统层虚拟化, 容器化, 只能提供操作系统内核以上的部分 ABI 兼容性与完整的环境兼容性</li><li>运行库虚拟化, 以一个独立进程来代替操作系统内核来提供目标软件运行所需的全部能力, WINE, WSL1</li><li>语言层虚拟化, 由虚拟机将高级语言生成的中间代码转换为目标机器可以直接执行的指令，Java 的 JVM 和.NET 的 CLR</li></ul><h2 id="虚拟化容器"><a href="#虚拟化容器" class="headerlink" title="虚拟化容器"></a>虚拟化容器</h2><p>容器的最初目的: 隔离资源</p><ul><li>隔离文件: chroot, 当某个进程经过chroot操作之后，它或者它的子进程将不能再访问和操作该目录之外的其他文件</li><li>隔离访问：namespaces, 由内核直接提供的全局资源封装，是内核针对进程设计的访问隔离机制, 不仅文件系统是独立的，还有着独立的 PID 编号、UID&#x2F;GID 编号、网络</li><li>隔离资源：cgroups, 由内核提供的功能，用于隔离或者说分配并限制某个进程组能够使用的资源配额，包括处理器时间、内存大小、磁盘 I&#x2F;O 速度等</li><li>封装系统：LXC, LXC封装系统, Docker封装应用</li><li>封装应用：Docker</li><li>封装集群：Kubernetes, Docker Engine 经历从不可或缺、默认依赖、可选择、直到淘汰是大概率事件</li></ul><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Docker 提倡单个容器封装单进程应用, 因为 Docker 只能通过监视 PID 为 1 的进程（即由 ENTRYPOINT 启动的进程）的运行状态来判断容器的工作状态是否正常</p><p>Docker Compose 可以设置不同的容器共享volume, 共享 IPC 名称空间</p><p>容器的本质是对 cgroups 和 namespaces 所提供的隔离能力的一种封装，然而 Linux 的 cgroups 和 namespaces 原本都是针对进程组而不仅仅是单个进程来设计的，同一个进程组中的多个进程天然就可以共享着相同的访问权限与资源配额, Kubernetes 里的 Pod</p><p>容器协作</p><ul><li>普通非亲密的容器, 以网络交互方式（其他譬如共享分布式存储来交换信息也算跨网络）</li><li>亲密协作的容器，被调度到同一个集群节点上，可以通过共享本地磁盘等方式协作</li><li>超亲密的协作, 特指多个容器位于同一个 Pod, 共享: UTS 名称空间, 网络名称空间, IPC 名称空间, 时间名称空间</li></ul><p>Kubernetes 将一切皆视为资源，不同资源之间依靠层级关系相互组合协作</p><ul><li>container, 延续了自 Docker 以来一个容器封装一个应用进程的理念，是镜像管理的最小单位</li><li>Pod, 补充了容器化后缺失的与进程组对应的“容器组”的概念，是资源调度的最小单位</li><li>Node, 对应于集群中的单台机器，这里的机器即可以是生产环境中的物理机，也可以是云计算环境中的虚拟节点，节点是处理器和内存等资源的资源池，是硬件单元的最小单位</li><li>Cluster, 当你要部署应用的时候，只需要通过声明式 API 将你的意图写成一份元数据, 是处理元数据的最小单位</li></ul><p>资源附加上了期望状态与实际状态两项属性，用户要想使用这些资源来实现某种需求，并不提倡像平常编程那样去调用某个或某一组方法来达成目的，而是通过描述清楚这些资源的期望状态，由 Kubernetes 中对应监视这些资源的控制器来驱动资源的实际状态逐渐向期望状态靠拢，这种交互风格被称为是 Kubernetes 的声明式 API</p><p>以应用(集群)为中心的封装</p><ul><li>Kustomize, 根据环境来生成不同的部署配置</li><li>Helm, Chart, 应用商店与包管理工具, 无法很好地管理这种有状态的依赖关系</li><li>Operator, CRD, 要求开发者自己实现一个专门针对该自定义资源的控制器，在控制器中维护自定义资源的期望状态</li><li>开放应用模型</li></ul><h2 id="容器间网络"><a href="#容器间网络" class="headerlink" title="容器间网络"></a>容器间网络</h2><h3 id="Linux网络虚拟化"><a href="#Linux网络虚拟化" class="headerlink" title="Linux网络虚拟化"></a>Linux网络虚拟化</h3><h4 id="网络通信模型"><a href="#网络通信模型" class="headerlink" title="网络通信模型"></a>网络通信模型</h4><h4 id="干预网络通信"><a href="#干预网络通信" class="headerlink" title="干预网络通信"></a>干预网络通信</h4><h4 id="虚拟化网络设备"><a href="#虚拟化网络设备" class="headerlink" title="虚拟化网络设备"></a>虚拟化网络设备</h4><h4 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h4><h3 id="容器网络与生态"><a href="#容器网络与生态" class="headerlink" title="容器网络与生态"></a>容器网络与生态</h3><h4 id="CNM-与-CNI"><a href="#CNM-与-CNI" class="headerlink" title="CNM 与 CNI"></a>CNM 与 CNI</h4><h4 id="网络插件生态"><a href="#网络插件生态" class="headerlink" title="网络插件生态"></a>网络插件生态</h4><h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><h3 id="Kubernetes-存储设计"><a href="#Kubernetes-存储设计" class="headerlink" title="Kubernetes 存储设计"></a>Kubernetes 存储设计</h3><h4 id="Mount-和-Volume"><a href="#Mount-和-Volume" class="headerlink" title="Mount 和 Volume"></a>Mount 和 Volume</h4><h4 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h4><h4 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h4><h3 id="容器存储与生态"><a href="#容器存储与生态" class="headerlink" title="容器存储与生态"></a>容器存储与生态</h3><h4 id="Kubernetes-存储架构"><a href="#Kubernetes-存储架构" class="headerlink" title="Kubernetes 存储架构"></a>Kubernetes 存储架构</h4><h4 id="FlexVolume-与-CSI"><a href="#FlexVolume-与-CSI" class="headerlink" title="FlexVolume 与 CSI"></a>FlexVolume 与 CSI</h4><h4 id="从-In-Tree-到-Out-of-Tree"><a href="#从-In-Tree-到-Out-of-Tree" class="headerlink" title="从 In-Tree 到 Out-of-Tree"></a>从 In-Tree 到 Out-of-Tree</h4><h4 id="容器插件生态"><a href="#容器插件生态" class="headerlink" title="容器插件生态"></a>容器插件生态</h4><h2 id="资源与调度"><a href="#资源与调度" class="headerlink" title="资源与调度"></a>资源与调度</h2><h3 id="资源模型"><a href="#资源模型" class="headerlink" title="资源模型"></a>资源模型</h3><h3 id="服务质量与优先级"><a href="#服务质量与优先级" class="headerlink" title="服务质量与优先级"></a>服务质量与优先级</h3><h3 id="驱逐机制"><a href="#驱逐机制" class="headerlink" title="驱逐机制"></a>驱逐机制</h3><h3 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h3><h2 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h2><h3 id="透明通信的涅槃"><a href="#透明通信的涅槃" class="headerlink" title="透明通信的涅槃"></a>透明通信的涅槃</h3><h4 id="通信的成本"><a href="#通信的成本" class="headerlink" title="通信的成本"></a>通信的成本</h4><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><h4 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h4><h3 id="服务网格与生态"><a href="#服务网格与生态" class="headerlink" title="服务网格与生态"></a>服务网格与生态</h3><h4 id="服务网格接口"><a href="#服务网格接口" class="headerlink" title="服务网格接口"></a>服务网格接口</h4><h4 id="通用数据平面-API"><a href="#通用数据平面-API" class="headerlink" title="通用数据平面 API"></a>通用数据平面 API</h4><h4 id="服务网格生态"><a href="#服务网格生态" class="headerlink" title="服务网格生态"></a>服务网格生态</h4><h1 id="技术方法论"><a href="#技术方法论" class="headerlink" title="技术方法论"></a>技术方法论</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的目的是有效的拆分应用，实现敏捷开发和部署</p><p>前提条件</p><ol><li>决策者与执行者都能意识到康威定律在软件设计中的关键作用(系统的架构趋同于组织的沟通结构)</li><li>组织中具备一些对微服务有充分理解、有一定实践经验的技术专家</li><li>系统应具有以自治为目标的自动化与监控度量能力</li><li>复杂性已经成为制约生产力的主要矛盾</li></ol><p>微服务的粒度: 领域驱动设计, DDD</p><ul><li>能够独立发布、独立部署、独立运行与独立测试</li><li>强相关的功能与数据在同一个服务中处理</li><li>一个服务包含至少一项业务实体与对应的完整操作</li><li>一个 2 Pizza Team (6-12) 能够在一个研发周期内完成的全部需求范围</li></ul><p>系统复杂性来源</p><ul><li>认知负担, 微服务&gt;单体服务</li><li>合作成本, 随人数的上升而上升, 单体服务上升比例远大于微服务</li></ul><p>架构腐化</p><blockquote><p>项目在开始的时候，团队会花很多时间去决策该选择用什么技术体系、哪种架构、怎样的平台框架、甚至具体到开发、测试和持续集成工具。此时就像小孩子们在选择自己所钟爱的玩具，笔者相信无论决策的结果如何，团队都会欣然选择他们所选择的，并且坚信他们的选择是正确的。事实也确实如此，团队选择的解决方案通常能够解决技术选型时就能预料到的那部分困难。但真正困难的地方在于，随着时间的流逝，团队对该项目质量的持续保持能力会逐渐下降，一方面是高级技术专家不可能持续参与软件稳定之后的迭代过程，反过来，如果持续绑定在同一个达到稳定之后的项目上，也很难培养出技术专家。老人的退出新人的加入使得团队总是需要理解旧代码的同时完成新功能，技术专家偶尔来评审一下或救一救火，充其量只能算临时抱佛脚；另一方面是代码会逐渐失控，时间长了一定会有某些并不适合放进最初设计中的需求出现，工期紧任务重业务复杂代码不熟悉都会成为欠下一笔技术债的妥协理由，原则底线每一次被细微地突破，都可能被破窗效应撕裂放大成触目惊心的血痕，最终累积到每个新人到来就马上能嗅出老朽腐臭味道的程度。</p></blockquote><p>架构腐化是软件动态发展中出现的问题，任何静态的治理方案都只能延缓，不能根治，唯一有效的办法是演进式的设计</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算计算大于等于给定数字a的最小二次幂</title>
      <link href="/2022-01-07-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97a%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E6%AC%A1%E5%B9%82.html"/>
      <url>/2022-01-07-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97a%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E6%AC%A1%E5%B9%82.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a href="https://zh.wikipedia.org/wiki/2%E7%9A%84%E5%B9%82">二次幂</a> 是指底数为2且指数为整数n的幂, 如2, 4, 8, 16等</p><p><code>大于等于给定数字a的最小二次幂</code> 即输入[5, 8]的数均输出8, 输入[9, 16]的数均输出16</p><p>在Java的HashMap中, 为了方便计算hash值、减少hash碰撞, hash的范围都是二次幂, 在初始化map和map扩容时需要根据给定的初始值计算<code>大于等于给定数字a的最小二次幂</code>, 即 <code>HashMap.java</code> 中的 <code>int tableSizeFor(int cap)</code></p><p>Java中int的最大值为2^31-1, 即<code>0x7fffffff</code>, 即<code>01111111 11111111 11111111 11111111</code></p><p>HashMap的capacity最大值为2^30, 即<code>1 &lt;&lt; 30</code>, 即<code>0x40000000</code>, 即<code>01000000 00000000 00000000 00000000</code></p><h1 id="Java8中的实现"><a href="#Java8中的实现" class="headerlink" title="Java8中的实现"></a>Java8中的实现</h1><p>看二进制的数, <code>大于给定数字a的最小二次幂</code>即从左到右数第一个值为1的位, 再左一位为1其他为0</p><p>5-&gt;8  0101-&gt;1000</p><p>7-&gt;8  0111-&gt;1000</p><p>目标值减1的数, 即从第一个值为1的位开始所有位的值均为1</p><p>5-&gt;7  0101-&gt;0111</p><p>7-&gt;7  0111-&gt;0111</p><p>考虑到输入即为二次幂的情况, 先将输入减1, 再计算从第一个值为1的位开始所有位的值均为1, 不需要考虑等于的情况, 最后得到的数再加1</p><p>0010 1001-&gt;0011 1111 即 41-&gt;63, 输出64</p><p>如何将一个数最高位1后面的1全部置为1呢? 使用右移+取或, 例如<code>0100</code>右移1位并和自身取或<code>0100 | 0010 = 0110</code>就将最高位的后一位置为了1, 不断重复这个过程</p><p>输入的最大值为<code>1 &lt;&lt; 30</code>即<code>01000000 00000000 00000000 00000000</code></p><p>减1后为<code>00111111 11111111 11111111 11111111</code>, 不断右移取或后还是自己, 加1后为<code>01000000 00000000 00000000 00000000</code></p><p>假设输入<code>1 &lt;&lt; 29 + 1</code>即<code>00100000 00000000 00000000 00000001</code></p><p>右移1位后和自己取或<code>00110000 00000000 00000000 00000000</code></p><p>右移2位后和自己取或<code>00111100 00000000 00000000 00000000</code></p><p>右移4位后和自己取或<code>00111111 11000000 00000000 00000000</code></p><p>右移8位后和自己取或<code>00111111 11111111 11000000 00000000</code></p><p>右移16位后和自己取或<code>00111111 11111111 11111111 11111111</code></p><p>加1后为<code>01000000 00000000 00000000 00000001</code>即<code>1 &lt;&lt; 30</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java11中的实现"><a href="#Java11中的实现" class="headerlink" title="Java11中的实现"></a>Java11中的实现</h1><p>目标同样是将最高位1后面的0计算出前导0的个数, 最后加1</p><p>先求出a前导0的数量, 使用比较和移位求出, 然后直接将-1 <code>0xffffffff</code>进行无符号右移</p><p>其中<code>numberOfLeadingZeros()</code>方法在OracleJDK中含注解<code>@IntrinsicCandidate</code>, OpenJDK中含注解<code>@HotSpotIntrinsicCandidate</code>, 均表示HotspotJVM会根据当前处理器平台对运算进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Integer.numberOfLeadingZeros()</code>的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Count leading 0&#x27;s</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中几种常用的异步工具</title>
      <link href="/2021-11-05-Java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E5%B7%A5%E5%85%B7.html"/>
      <url>/2021-11-05-Java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E5%B7%A5%E5%85%B7.html</url>
      
        <content type="html"><![CDATA[<p>几种异步工具的演化</p><ul><li>new线程, <code>Runnable</code> &#x2F; <code>Callable</code></li><li>线程池, <code>Executor</code> &#x2F; <code>ExecutorService</code> + <code>Future</code> &#x2F; <code>FutureTask</code></li><li>ForkJoin, <code>ForkJoinPool</code></li><li>CompletableFuture</li></ul><p>使用自定义的forkJoinPool运行parallelStream<br>new ForkJoinPool(16).submit(() -&gt; list.parallelStream())</p><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>new线程</td><td></td><td>线程创建和销毁消耗资源</td><td></td></tr><tr><td>线程池</td><td>降低线程创建和销毁的资源消耗, 统一管理线程</td><td></td><td></td></tr><tr><td>forkjoin</td><td>使用worksteal算法, 效率高于普通线程池</td><td></td><td>数据集大且可拆分, 并行的子集逻辑相对独立, CPU密集</td></tr><tr><td>CompletableFuture</td><td>链式写法, 支持自定义线程池</td><td></td><td>多个调用有逻辑依赖关系</td></tr><tr><td>RxJava</td><td>链式写法, 性能比CompletableFuture高, 支持back_pressure</td><td>学习成本高</td><td></td></tr></tbody></table><p><a href="https://v2ex.com/t/811364">发现了个很奇怪的现象，关于 parallelStream 的 - V2EX</a></p><p><a href="https://hahahaha123567.github.io/2018-08-13-java-util-concurrent.html">java.util.concurrent | hahahaha123567’s Blog</a></p><p><a href="https://mp.weixin.qq.com/s/tS0U7NzsZ4MA-mg-2ZgAxw">来，带你鸟瞰 Java 中的并发框架！</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读Spring源码(1) - 上下文启动</title>
      <link href="/2021-07-22-%E9%98%85%E8%AF%BBSpring%E6%BA%90%E7%A0%811.html"/>
      <url>/2021-07-22-%E9%98%85%E8%AF%BBSpring%E6%BA%90%E7%A0%811.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring的整体架构和环境搭建"><a href="#Spring的整体架构和环境搭建" class="headerlink" title="Spring的整体架构和环境搭建"></a>Spring的整体架构和环境搭建</h1><p><a href="https://www.cnblogs.com/java-chen-hao/p/11046190.html">spring5 源码深度解析—–Spring的整体架构和环境搭建 - chen_hao - 博客园</a></p><p>Spring的整体架构</p><ul><li>Core Container<ul><li>Core</li><li>Beans</li><li>Context</li><li>SpEL</li></ul></li><li>AOP</li><li>Aspect</li><li>Instrumentation</li><li>Messaging</li><li>Web<ul><li>Web</li><li>Servlet</li><li>Websocket</li><li>Portlet</li></ul></li><li>Data Access&#x2F;Integration<ul><li>JDBC</li><li>ORM</li><li>OXM</li><li>JMS</li><li>Transactions</li></ul></li><li>Test</li></ul><p>阅读步骤</p><ol><li>安装gradle</li><li>下载源码</li><li>build项目</li><li>创建测试模块并debug</li></ol><h1 id="IOC注册"><a href="#IOC注册" class="headerlink" title="IOC注册"></a>IOC注册</h1><p><a href="https://www.cnblogs.com/java-chen-hao/p/11113340.html">spring5 源码深度解析—– IOC 之 容器的基本实现 - chen_hao - 博客园</a></p><p><a href="https://www.cnblogs.com/java-chen-hao/p/11115300.html">spring5 源码深度解析—– IOC 之 默认标签解析（上） - chen_hao - 博客园</a></p><p><a href="https://www.cnblogs.com/java-chen-hao/p/11120677.html">spring5 源码深度解析—– IOC 之 默认标签解析（下） - chen_hao - 博客园</a></p><p>ClassPathResource, Resource 配置资源的抽象</p><p>示例使用 XmlBeanFactory</p><blockquote><p>BeanFactoryAware&#x2F;ApplicationContextAware 在构建BeanFactory的时候就进行了相关配置</p></blockquote><p>XmlBeanDefinitionReader 解析XML文件, 返回 <code>org.w3c.dom.Document</code></p><p>BeanDefinitionDocumentReader 使用 BeanDefinitionParserDelegate 解析Document, 包含defaultElement&#x2F;customElement, 返回 <code>BeanDefinitionHolder</code> (包含 <code>GenericBeanDefinition</code>)</p><p>BeanDefinitionDocumentReader 将 &lt;beanName, beanDefinition&gt; 注册到 <code>BeanDefinitionRegistry</code>(beanFactory), 实际使用 <code>DefaultListableBeanFactory</code> 的 <code>registerBeanDefinition</code>, 映射关系保存在一个ConcurrentHashMap中</p><h1 id="IOC注入-BeanFactory"><a href="#IOC注入-BeanFactory" class="headerlink" title="IOC注入(BeanFactory)"></a>IOC注入(BeanFactory)</h1><p><a href="https://www.cnblogs.com/java-chen-hao/p/11137571.html">spring5 源码深度解析—– IOC 之 开启 bean 的加载 - chen_hao - 博客园</a></p><p><strong>BeanFactory</strong></p><p><img src="/../../../../image/bean_factory.png" alt="BeanFactory类图"></p><p><code>BeanFactory</code> 和 <code>FactoryBean</code> 的区别:</p><ul><li>BeanFactory, 访问 Spring bean 容器的根接口, 是应用程序组件的中央注册表</li><li>FactoryBean, 如果一个 bean 实现了这个接口，它就被用作一个对象暴露的工厂</li></ul><h2 id="获取bean名称"><a href="#获取bean名称" class="headerlink" title="获取bean名称"></a>获取bean名称</h2><p><code>AbstractBeanFactory</code> 的 <code>transformedBeanName</code></p><ol><li>FactoryBean的&amp;名称解引用</li><li>alias转换</li></ol><h2 id="获取单例缓存sharedInstance"><a href="#获取单例缓存sharedInstance" class="headerlink" title="获取单例缓存sharedInstance"></a>获取单例缓存sharedInstance</h2><p><code>DefaultSingletonBeanRegistry</code> 的 <code>getSingleton()</code></p><p>几个缓存(使用时不加锁的是ConcurrentHashMap, 使用时加锁的是HashMap)</p><ul><li>singletonObjects:用于保存BeanName和创建bean实例之间的关系，beanName–&gt;bean Instance</li><li>singletonFactories:用于保存BeanName和创建bean的工厂之间的关系，banName–&gt;ObjectFactory</li><li>earlySingletonObjects:也是保存BeanName和创建bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例bean被放到这里面后，那么当bean还在创建过程中，就可以通过getBean方法获取到了，其目的是用来检测循环引用</li></ul><p>如果有单例缓存, 则使用单例缓存获取bean</p><p>如果单例缓存不是FactoryBean则说明为bean直接返回</p><p>如果单例缓存是FactoryBean则调用getBean, <code>DefaultSingletonBeanRegistry</code> 的 <code>beforeSingletonCreation</code> <code>afterSingletonCreation</code> 继续使用缓存判断是否创建中(检测循环引用), <code>postProcessObjectFromFactoryBean</code> 调用bean的 <code>BeanPostProcessors</code> 方法</p><h2 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h2><p><a href="https://www.cnblogs.com/java-chen-hao/p/11139157.html">spring5 源码深度解析—– IOC 之 bean 创建 - chen_hao - 博客园</a></p><p>未获取到单例缓存的话就要创建bean</p><p>入口 <code>AbstractBeanFactory</code> 的 <code>doGetBean()</code></p><h3 id="scope-x3D-singleton"><a href="#scope-x3D-singleton" class="headerlink" title="scope&#x3D;singleton"></a>scope&#x3D;singleton</h3><ol><li>synchronized全局锁</li><li>检查缓存</li><li>beforeSingletonCreation()</li><li>createBean()</li><li>afterSingletonCreation()</li><li>加入缓存</li></ol><h3 id="scope-x3D-prototype"><a href="#scope-x3D-prototype" class="headerlink" title="scope&#x3D;prototype"></a>scope&#x3D;prototype</h3><ol><li>beforeSingletonCreation()</li><li>createBean()</li><li>afterSingletonCreation()</li><li>getObjectForBeanInstance()</li></ol><h3 id="scope-x3D-other"><a href="#scope-x3D-other" class="headerlink" title="scope&#x3D;other"></a>scope&#x3D;other</h3><ol><li>beforeSingletonCreation()</li><li>scope.get() -&gt; createBean()</li><li>afterSingletonCreation()</li><li>getObjectForBeanInstance()</li></ol><h3 id="实现的方法createBean"><a href="#实现的方法createBean" class="headerlink" title="实现的方法createBean()"></a>实现的方法createBean()</h3><p><code>AbstractAutowireCapableBeanFactory</code> 的 <code>createBean()</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java各版本更新介绍</title>
      <link href="/2021-07-01-Java%E5%90%84%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D.html"/>
      <url>/2021-07-01-Java%E5%90%84%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://xie.infoq.cn/article/655943e5f85e6f79ffbd03047">新时代背景下的Java语法特性(9-14) - InfoQ 写作平台</a></p><p><a href="https://xie.infoq.cn/article/92ba88c7926b5f5c6fbc11830">剖析Java15新语法特性 - InfoQ 写作平台</a></p><p><a href="https://xie.infoq.cn/article/8304c894c4e38318d38ceb116">实操 | 剖析 Java16 新语法特性 - InfoQ 写作平台</a></p><hr><p>2022-12-14更新</p><p><a href="https://mp.weixin.qq.com/s/IaUQrkxvaeEjujDe5-DVfA">一文详解｜从JDK8飞升到JDK17，再到未来的JDK21</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA将文件标记为文本文件及取消</title>
      <link href="/2021-06-28-IDEA%E5%B0%86%E6%96%87%E4%BB%B6%E6%A0%87%E8%AE%B0%E4%B8%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%8F%8A%E5%8F%96%E6%B6%88.html"/>
      <url>/2021-06-28-IDEA%E5%B0%86%E6%96%87%E4%BB%B6%E6%A0%87%E8%AE%B0%E4%B8%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%8F%8A%E5%8F%96%E6%B6%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用IDEA编辑文件时，在修改文件名时有时会修改文件后缀，此时IDE会弹出 <code>Register New File Type Association</code> 让你设置一些文件后缀的识别规则</p><p>这个时候我经常没看清楚误触导致IDE不再智能识别某种特定后缀的文件，编辑起来很不舒服</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="以前"><a href="#以前" class="headerlink" title="以前"></a>以前</h2><p>在文件上右键，选择 <code>mark as plain text</code> 或相反的选项</p><p>但是最近IDEA似乎移除了这个选项</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p><code>Preferences</code> -&gt; <code>Editor</code> -&gt; <code>File Types</code> 这里可以任意修改文件后缀的识别规则，包括 <code>Recognized</code> 和 <code>Ignored</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud的一些常用组件</title>
      <link href="/2021-06-25-SpringCloud%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html"/>
      <url>/2021-06-25-SpringCloud%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="服务组成"><a href="#服务组成" class="headerlink" title="服务组成"></a>服务组成</h1><p><img src="/../../../../image/spring_cloud_architecture_highlights.svg" alt="spring_cloud_architecture_highlights"></p><h2 id="service-discovery-服务发现"><a href="#service-discovery-服务发现" class="headerlink" title="service discovery 服务发现"></a>service discovery 服务发现</h2><ul><li>Eureka (netflix)</li><li>Consul</li><li>Zookeeper</li><li>Kubernetes</li><li>nacos (alibaba)</li></ul><h2 id="API-gateway-API网关"><a href="#API-gateway-API网关" class="headerlink" title="API gateway API网关"></a>API gateway API网关</h2><ul><li>spring cloud gateway</li></ul><h2 id="cloud-configuration-云配置"><a href="#cloud-configuration-云配置" class="headerlink" title="cloud configuration 云配置"></a>cloud configuration 云配置</h2><ul><li>spring cloud config</li><li>nacos (alibaba)</li></ul><h2 id="circuit-breaker-服务熔断"><a href="#circuit-breaker-服务熔断" class="headerlink" title="circuit breaker 服务熔断"></a>circuit breaker 服务熔断</h2><ul><li>Hystrix (netflix)</li><li>Resilience4J</li><li>Sentinel (alibaba)</li><li>Spring Retry</li></ul><h2 id="tracing-链路跟踪"><a href="#tracing-链路跟踪" class="headerlink" title="tracing 链路跟踪"></a>tracing 链路跟踪</h2><ul><li>Spring Cloud Sleuth</li><li>zipkin</li></ul><h2 id="test-测试"><a href="#test-测试" class="headerlink" title="test 测试"></a>test 测试</h2><ul><li>Spring Cloud Contract</li></ul><h2 id="others-其他"><a href="#others-其他" class="headerlink" title="others 其他"></a>others 其他</h2><h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><ul><li>Kafka</li><li>RabbitMQ</li><li>Feign</li></ul><h3 id="Distributed-Transaction"><a href="#Distributed-Transaction" class="headerlink" title="Distributed Transaction"></a>Distributed Transaction</h3><ul><li>Seata</li></ul><h1 id="套件"><a href="#套件" class="headerlink" title="套件"></a>套件</h1><h2 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h2><p>原组件</p><ul><li>Hystrix(熔断器)</li><li>Hystrix Dashboard(监控)</li><li>Ribbon(客户端负载均衡)</li><li>Zuul(网关)</li><li>Archaius(云配置)</li></ul><p>现在项目内只有Eureka</p><h2 id="Netflix替代"><a href="#Netflix替代" class="headerlink" title="Netflix替代"></a>Netflix替代</h2><p>Spring Cloud 2020.0.0版本彻底删除掉了Netflix除Eureka外的所有组件, 推荐的替代品如下</p><ul><li>Resilience4j</li><li>Micrometer + Monitoring System</li><li>Spring Cloud Loadbalancer</li><li>Spring Cloud Gateway</li><li>Spring Cloud Config</li></ul><p>Feign从Netflix转交给OpenFeign, 当前可以使用Spring Cloud Loadbalancer作为http-client实现</p><hr><p><strong>reference</strong></p><p><a href="https://spring.io/cloud">Spring | Cloud</a></p><p><a href="https://incoder.org/2020/11/11/microservices-alibaba1/#SpringCloud-VS-SpringCloud-Alibaba">微服务架构 - Alibaba 生态整合（一） | BladeCode</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现gRPC的部分进阶功能</title>
      <link href="/2021-06-24-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E9%83%A8%E5%88%86%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD.html"/>
      <url>/2021-06-24-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E9%83%A8%E5%88%86%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章内容均基于gRPC<a href="https://grpc.io/docs/languages/java/quickstart/">官方文档</a>提供的<a href="https://github.com/grpc/grpc-java/archive/v1.38.0.zip">代码示例v1.38.0</a></p><p>你也可以直接看<a href="https://github.com/grpc/grpc-java/tree/master/examples">github上的最新版本</a></p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p><code>StatusException</code> gRPC常用的异常类型, 扩展自 <code>Exception</code> , 包含状态信息 <code>Status status</code> 和扩展信息 <code>Metadata trailers</code></p><p><code>StatusRuntimeException</code> gRPC常用的异常类型, 扩展自 <code>RuntimeException</code> , 包含状态信息 <code>Status status</code> 和扩展信息 <code>Metadata trailers</code></p><h2 id="服务端返回错误"><a href="#服务端返回错误" class="headerlink" title="服务端返回错误"></a>服务端返回错误</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误扩展信息key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Metadata.Key&lt;DebugInfo&gt; DEBUG_INFO_TRAILER_KEY = ProtoUtils.keyForProto(DebugInfo.getDefaultInstance());</span><br><span class="line"><span class="comment">// 错误扩展信息value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DebugInfo</span> <span class="variable">DEBUG_INFO</span> <span class="operator">=</span> DebugInfo.newBuilder()</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_1&quot;</span>)</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_2&quot;</span>)</span><br><span class="line">                                                    .addStackEntries(<span class="string">&quot;stack_entry_3&quot;</span>)</span><br><span class="line">                                                    .setDetail(<span class="string">&quot;detailed error info.&quot;</span>).build();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;</span><br><span class="line">    <span class="comment">// 错误扩展信息</span></span><br><span class="line">    <span class="type">Metadata</span> <span class="variable">trailers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Metadata</span>();</span><br><span class="line">    trailers.put(DEBUG_INFO_TRAILER_KEY, DEBUG_INFO);</span><br><span class="line">    <span class="comment">// 返回错误</span></span><br><span class="line">    responseObserver.onError(</span><br><span class="line">        Status.INTERNAL.withDescription(DEBUG_DESC).asRuntimeException(trailers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端处理错误"><a href="#客户端处理错误" class="headerlink" title="客户端处理错误"></a>客户端处理错误</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Metadata.Key&lt;DebugInfo&gt; DEBUG_INFO_TRAILER_KEY = ProtoUtils.keyForProto(DebugInfo.getDefaultInstance());</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> Status.fromThrowable(t);</span><br><span class="line">    <span class="type">Metadata</span> <span class="variable">trailers</span> <span class="operator">=</span> Status.trailersFromThrowable(t);</span><br><span class="line">    <span class="comment">// 不符合条件则抛出VerifyException</span></span><br><span class="line">    Verify.verify(status.getCode() == Status.Code.INTERNAL);</span><br><span class="line">    Verify.verify(trailers.containsKey(DEBUG_INFO_TRAILER_KEY));</span><br><span class="line">    Verify.verify(status.getDescription().contains(<span class="string">&quot;Overbite&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端请求重试"><a href="#客户端请求重试" class="headerlink" title="客户端请求重试"></a>客户端请求重试</h2><p>配置重试参数需要在构建channel时传入配置, 具体参数等可以参考 <code>ManagedChannelServiceConfig</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重试参数</span></span><br><span class="line">Map&lt;String, Object&gt; name0 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">name0.put(<span class="string">&quot;service&quot;</span>, <span class="string">&quot;helloworld.Greeter&quot;</span>);</span><br><span class="line">name0.put(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;SayHello&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; retryPolicies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">retryPolicies.put(<span class="string">&quot;backoffMultiplier&quot;</span>, <span class="number">2.0</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;maxAttempts&quot;</span>, <span class="number">5.0</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;initialBackoff&quot;</span>, <span class="string">&quot;0.5s&quot;</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;maxBackoff&quot;</span>, <span class="string">&quot;30s&quot;</span>);</span><br><span class="line">retryPolicies.put(<span class="string">&quot;retryableStatusCodes&quot;</span>, Arrays.stream(Status.Code.values()).filter(code -&gt; !Status.Code.OK.equals(code)).map(Enum::name).collect(Collectors.toList()));</span><br><span class="line">Map&lt;String, Object&gt; methodConfig0 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">methodConfig0.put(<span class="string">&quot;name&quot;</span>, Collections.singletonList(name0));</span><br><span class="line">methodConfig0.put(<span class="string">&quot;retryPolicy&quot;</span>, retryPolicies);</span><br><span class="line">Map&lt;String, Object&gt; defaultServiceConfig = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">defaultServiceConfig.put(<span class="string">&quot;methodConfig&quot;</span>, Collections.singletonList(methodConfig0));</span><br><span class="line"><span class="comment">// 构建channel</span></span><br><span class="line">helloWorldChannel = ManagedChannelBuilder.forTarget(<span class="string">&quot;localhost:50051&quot;</span>)</span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .enableRetry()</span><br><span class="line">        .defaultServiceConfig(defaultServiceConfig)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>以上为Java代码方式构造参数, 官方提供的是使用json配置文件+gson解析的方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;methodConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;helloworld.Greeter&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SayHello&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;retryPolicy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;maxAttempts&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;initialBackoff&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.5s&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;maxBackoff&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30s&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;backoffMultiplier&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;retryableStatusCodes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;UNAVAILABLE&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">JsonReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(RetryingHelloWorldClient.class.getResourceAsStream(<span class="string">&quot;retrying_service_config.json&quot;</span>), UTF_8)),Map.class);</span><br></pre></td></tr></table></figure><h2 id="服务端拦截器"><a href="#服务端拦截器" class="headerlink" title="服务端拦截器"></a>服务端拦截器</h2><p>gRPC支持服务端设置拦截器链</p><p>继承 <code>ServerInterceptor</code> 接口并实现 <code>interceptCall</code> 方法, 在创建 <code>server</code> 时进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LatencyInjectionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ServerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;HelloRequestT, HelloReplyT&gt; Listener&lt;HelloRequestT&gt; <span class="title function_">interceptCall</span><span class="params">(ServerCall&lt;HelloRequestT, HelloReplyT&gt; call, Metadata headers, ServerCallHandler&lt;HelloRequestT, HelloReplyT&gt; next)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个Interceptor制造了长尾延迟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (random &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            delay = <span class="number">10_000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (random &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            delay = <span class="number">5_000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (random &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            delay = <span class="number">2_000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(delay);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next.startCall(call, headers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> ServerBuilder.forPort(port)</span><br><span class="line">        .addService(<span class="keyword">new</span> <span class="title class_">GreeterImpl</span>())</span><br><span class="line">        .intercept(<span class="keyword">new</span> <span class="title class_">LatencyInjectionInterceptor</span>())</span><br><span class="line">        .build()</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure><h2 id="请求对冲"><a href="#请求对冲" class="headerlink" title="请求对冲"></a>请求对冲</h2><p><code>对冲请求</code> 是一种优化 <code>长尾延迟</code> 的方法, 参考 <a href="https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577">Hedged requests — Tackling tail latency | by Ricardo Linck | The Startup | Medium</a></p><p>gRPC自带对冲请求的支持, 类似上面的重试请求, 需要在构造channel时进行配置, 配置粒度精确到方法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;helloworld.Greeter&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SayHello&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hedgingPolicy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;maxAttempts&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;hedgingDelay&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;retryThrottling&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;maxTokens&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tokenRatio&quot;</span><span class="punctuation">:</span> <span class="number">0.1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>gRPC提供的示例还包括</p><ul><li>client自定义请求头</li><li>server自定义请求头</li><li>请求压缩</li><li>响应压缩</li><li>client自定义序列化反序列化逻辑</li><li>server自定义序列化反序列化逻辑</li><li>背压流量控制</li><li>TLS</li><li>ALTS(Google’s Application Layer Transport Security)</li><li>jwt</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> gRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现gRPC的服务端和客户端</title>
      <link href="/2021-06-23-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF.html"/>
      <url>/2021-06-23-Java%E5%AE%9E%E7%8E%B0gRPC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF.html</url>
      
        <content type="html"><![CDATA[<h1 id="gRPC简介"><a href="#gRPC简介" class="headerlink" title="gRPC简介"></a>gRPC简介</h1><p>gRPC是一种 <a href="https://hahahaha123567.github.io/2020/04/17/2020-04-17-RPC%E6%A6%82%E5%BF%B5/">RPC</a> 框架,特点:</p><ol><li>序列化&#x2F;反序列化使用Protocol Buffers,比起json等格式更高效</li><li>支持多种语言编写服务端&#x2F;客户端</li></ol><p><a href="https://grpc.io/">gRPC官网</a></p><h1 id="Java开发gRPC流程"><a href="#Java开发gRPC流程" class="headerlink" title="Java开发gRPC流程"></a>Java开发gRPC流程</h1><p>本章节内容基于 <a href="https://grpc.io/docs/languages/java/basics/">Basics tutorial | Java | gRPC</a></p><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><p>protocol buffer使用proto文件定义接口,参考 <a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3)  |  Protocol Buffers  |  Google Developers</a></p><p>以下为示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 协议版本</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">// 编译后是否生成多个Java类</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">// 编译后生成Java类的package路径</span><br><span class="line">option java_package = &quot;idol.elie.grpc.routeguide.protobuf&quot;;</span><br><span class="line">// 编译后生成的配置基类名</span><br><span class="line">option java_outer_classname = &quot;RouteGuideProto&quot;;</span><br><span class="line"></span><br><span class="line">// proto内部使用的package</span><br><span class="line">package routeguide;</span><br><span class="line"></span><br><span class="line">// 接口</span><br><span class="line">service RouteGuide &#123;</span><br><span class="line">    // 客户端同步请求,服务端单次返回</span><br><span class="line">    rpc GetFeature(Point) returns (Feature) &#123;&#125;;</span><br><span class="line">    // 客户端同步请求,服务端流式返回</span><br><span class="line">    rpc ListFeatures(Rectangle) returns (stream Feature);</span><br><span class="line">    // 客户端流式异步请求,服务端单次返回</span><br><span class="line">    rpc RecordRoute(stream Point) returns (RouteSummary);</span><br><span class="line">    // 客户端流式异步请求,服务端流式返回</span><br><span class="line">    rpc RouteChat(stream RouteNote) returns (stream RouteNote);</span><br><span class="line">&#125;</span><br><span class="line">// 数据类</span><br><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude = 1;</span><br><span class="line">  int32 longitude = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Rectangle &#123;</span><br><span class="line">  Point p1 = 1;</span><br><span class="line">  Point p2 = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Feature &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  Point location = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FeatureDatabase &#123;</span><br><span class="line">  repeated Feature features = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RouteNote &#123;</span><br><span class="line">  Point location = 1;</span><br><span class="line">  string message = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">  int32 point_count = 1;</span><br><span class="line">  int32 feature_count = 2;</span><br><span class="line">  int32 distance = 3;</span><br><span class="line">  int32 elapsed_time = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="proto编译生成Java类"><a href="#proto编译生成Java类" class="headerlink" title="proto编译生成Java类"></a>proto编译生成Java类</h2><p>Java版本推荐使用maven插件进行编译,<code>os-maven-plugin</code>判断当前运行平台,<code>protobuf-maven-plugin</code>使用对应平台的protoc进行编译</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">protoc.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">protoc.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protoc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:$&#123;grpc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将编译生成的类复制到src的对应目录下即可开始正式进行开发</p><h2 id="编写服务代码"><a href="#编写服务代码" class="headerlink" title="编写服务代码"></a>编写服务代码</h2><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  RouteGuideGrpc为编译生成的基础配置类, 我们需要继承并实现RouteGuideImplBase</span></span><br><span class="line"><span class="comment">  没有被继承实现的方法被调用后会向客户端报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteGuideImpl</span> <span class="keyword">extends</span> <span class="title class_">RouteGuideGrpc</span>.RouteGuideImplBase &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建web服务并监听</span></span><br><span class="line"><span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> ServerBuilder</span><br><span class="line">                .forPort(port)</span><br><span class="line">                .addService(<span class="keyword">new</span> <span class="title class_">RouteGuideImpl</span>())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">server.awaitTermination();</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteGuideClient</span> &#123;</span><br><span class="line"><span class="comment">// 同步调用stub</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteGuideGrpc.RouteGuideBlockingStub blockingStub;</span><br><span class="line"><span class="comment">// 异步调用stub</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteGuideGrpc.RouteGuideStub stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RouteGuideClient</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        blockingStub = RouteGuideGrpc.newBlockingStub(channel);</span><br><span class="line">        stub = RouteGuideGrpc.newStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ManagedChannel</span> <span class="variable">routeGuideChannel</span> <span class="operator">=</span> ManagedChannelBuilder</span><br><span class="line">.forTarget(<span class="string">&quot;localhost:25252&quot;</span>) <span class="comment">// target server</span></span><br><span class="line">                .usePlaintext() <span class="comment">// not ssl</span></span><br><span class="line">                .build();</span><br><span class="line"><span class="type">RouteGuideClient</span> <span class="variable">routeGuideClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteGuideClient</span>(routeGuideChannel);</span><br></pre></td></tr></table></figure><h3 id="客户端同步请求-服务端单次返回"><a href="#客户端同步请求-服务端单次返回" class="headerlink" title="客户端同步请求,服务端单次返回"></a>客户端同步请求,服务端单次返回</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFeature</span><span class="params">(Point request, StreamObserver&lt;Feature&gt; responseObserver)</span> &#123;</span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line">responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line"><span class="comment">// 处理完成</span></span><br><span class="line">responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFeature</span><span class="params">(<span class="type">int</span> latitude, <span class="type">int</span> longitude)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 使用阻塞stub直接调用</span></span><br><span class="line"><span class="type">Feature</span> <span class="variable">feature</span> <span class="operator">=</span> blockingStub.getFeature(Point.newBuilder().build());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.log(Level.WARNING, <span class="string">&quot;getFeature error&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端同步请求-服务端流式返回"><a href="#客户端同步请求-服务端流式返回" class="headerlink" title="客户端同步请求,服务端流式返回"></a>客户端同步请求,服务端流式返回</h3><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFeatures</span><span class="params">(Rectangle request, StreamObserver&lt;Feature&gt; responseObserver)</span> &#123;</span><br><span class="line"><span class="comment">// 返回流式响应</span></span><br><span class="line">responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line">responseObserver.onNext(Feature.newBuilder().build());</span><br><span class="line">responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFeatures</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Iterator&lt;Feature&gt; featureIterator = blockingStub.listFeatures(Rectangle.newBuilder().build());</span><br><span class="line"><span class="comment">// 用Iterator读取流式数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; featureIterator.hasNext(); ++i) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.log(Level.WARNING, <span class="string">&quot;listFeatures error&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端流式异步请求-服务端单次返回"><a href="#客户端流式异步请求-服务端单次返回" class="headerlink" title="客户端流式异步请求,服务端单次返回"></a>客户端流式异步请求,服务端单次返回</h3><h4 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StreamObserver&lt;Point&gt; <span class="title function_">recordRoute</span><span class="params">(StreamObserver&lt;RouteSummary&gt; responseObserver)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Point value)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 返回响应</span></span><br><span class="line">            responseObserver.onNext(RouteSummary.newBuilder().build());</span><br><span class="line">responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordRoute</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">// 异步响应处理</span></span><br><span class="line">StreamObserver&lt;RouteSummary&gt; responseObserver = <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteSummary value)</span> &#123;</span><br><span class="line"><span class="comment">// 处理返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用响应处理器生成请求</span></span><br><span class="line">StreamObserver&lt;Point&gt; requestObserver = stub.recordRoute(responseObserver);</span><br><span class="line"><span class="comment">// 流式请求</span></span><br><span class="line">requestObserver.onNext(Point.newBuilder().build());</span><br><span class="line">requestObserver.onNext(Point.newBuilder().build());</span><br><span class="line">requestObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端流式异步请求-服务端流式返回"><a href="#客户端流式异步请求-服务端流式返回" class="headerlink" title="客户端流式异步请求,服务端流式返回"></a>客户端流式异步请求,服务端流式返回</h3><h4 id="服务端-4"><a href="#服务端-4" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StreamObserver&lt;RouteNote&gt; <span class="title function_">routeChat</span><span class="params">(StreamObserver&lt;RouteNote&gt; responseObserver)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteNote value)</span> &#123;</span><br><span class="line"><span class="comment">// 流式返回</span></span><br><span class="line">responseObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理服务器返回的响应</span></span><br><span class="line">StreamObserver&lt;RouteNote&gt; responseStreamObserver = <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteNote value)</span> &#123;</span><br><span class="line">logger.info(value.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">StreamObserver&lt;RouteNote&gt; requestStreamObserver = stub.routeChat(responseStreamObserver);</span><br><span class="line"><span class="comment">// 流式请求</span></span><br><span class="line">requestStreamObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">requestStreamObserver.onNext(RouteNote.newBuilder().build());</span><br><span class="line">requestStreamObserver.onCompleted();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> gRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个redis-session的错误使用示例</title>
      <link href="/2021-06-01-%E4%B8%80%E4%B8%AAredis-session%E7%9A%84%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"/>
      <url>/2021-06-01-%E4%B8%80%E4%B8%AAredis-session%E7%9A%84%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>某个模块的几个子服务上线后会定时出现如下的异常日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">14:56:00.009 [ing-scheduled-1] [FJNJFVNG] ERROR o.s.s.s.TaskUtils$LoggingErrorHandler    - Unexpected error occurred in scheduled task </span><br><span class="line">org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:84)</span><br><span class="line">at org.springframework.data.redis.serializer.SerializationUtils.deserializeValues(SerializationUtils.java:54)</span><br><span class="line">at org.springframework.data.redis.serializer.SerializationUtils.deserialize(SerializationUtils.java:62)</span><br><span class="line">at org.springframework.data.redis.core.AbstractOperations.deserializeValues(AbstractOperations.java:223)</span><br><span class="line">at org.springframework.data.redis.core.DefaultSetOperations.members(DefaultSetOperations.java:216)</span><br><span class="line">at org.springframework.data.redis.core.DefaultBoundSetOperations.members(DefaultBoundSetOperations.java:152)</span><br><span class="line">at org.springframework.session.data.redis.RedisSessionExpirationPolicy.cleanExpiredSessions(RedisSessionExpirationPolicy.java:129)</span><br><span class="line">at org.springframework.session.data.redis.RedisIndexedSessionRepository.cleanupExpiredSessions(RedisIndexedSessionRepository.java:407)</span><br><span class="line">at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54)</span><br><span class="line">at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:93)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:78)</span><br><span class="line">at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:36)</span><br><span class="line">at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:82)</span><br><span class="line">... 16 common frames omitted</span><br><span class="line">Caused by: java.io.StreamCorruptedException: invalid stream header: 22657870</span><br><span class="line">at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:937)</span><br><span class="line">at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:395)</span><br><span class="line">at org.springframework.core.ConfigurableObjectInputStream.&lt;init&gt;(ConfigurableObjectInputStream.java:65)</span><br><span class="line">at org.springframework.core.ConfigurableObjectInputStream.&lt;init&gt;(ConfigurableObjectInputStream.java:51)</span><br><span class="line">at org.springframework.core.serializer.DefaultDeserializer.deserialize(DefaultDeserializer.java:70)</span><br><span class="line">at org.springframework.core.serializer.support.DeserializingConverter.convert(DeserializingConverter.java:73)</span><br><span class="line">... 18 common frames omitted</span><br></pre></td></tr></table></figure><h1 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h1><p>根据异常栈底的类名<code>DeserializingConverter</code>大概可以知道是反序列化的问题，但是什么反序列化会定时执行并抛出异常呢？</p><p>这个时候我们要看第一个异常栈，从栈底开始，忽略<code>ThreadPoolExecutor</code>等没有逻辑特征的类，往下看</p><p>首先是<code>ReschedulingRunnable</code>，是spring定时任务的默认接口，服务中用到定时任务的地方不算多，但是我们不能以此为依据，因为springboot本身也包含很多定时任务</p><p>接下来我们看<code>RedisIndexedSessionRepository</code>，找到异常栈中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanupExpiredSessions</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.expirationPolicy.cleanExpiredSessions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是服务在清理过期的session，继续往下debug可以看到服务使用代码里默认的<code>JdkSerializationRedisSerializer</code>执行redis的member操作检查过期key时产生的反序列化异常</p><p>再从异常栈顶往下跟踪，看看哪一步开始可以修改默认的serializer。要注意idea不支持外部库的变量引用查询，在跟踪字段的时候需要文件内搜索</p><p>发现在<code>RedisHttpSessionConfiguration</code>中调用了<code>RedisIndexedSessionRepository</code>的<code>setDefaultSerializer()</code>，Configuration在配置类中提供了serializer的注入方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;springSessionDefaultRedisSerializer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDefaultRedisSerializer</span><span class="params">(RedisSerializer&lt;Object&gt; defaultRedisSerializer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaultRedisSerializer = defaultRedisSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在spring配置中注入名为<code>springSessionDefaultRedisSerializer</code>的自定义serializer即可</p><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p>spring-session-data-redis和spring-data-redis相对独立，redis客户端的serializer等需要独立配置</p><p>RedisHttpSessionConfiguration 本身是一个 Spring 配置类, 会向 Spring 容器注册 sessionRepository, redisMessageListenerContainer 等实例</p><p>RedisHttpSessionConfiguration 会注册 Redis 消息监听器容器 RedisMessageListenerContainer, 并将 RedisIndexedSessionRepository 作为 Redis 消息订阅的监听器, 因为它实现了 MessageListener 接口。当 Redis 中 key 过期或销毁时, 会通知将 RedisIndexedSessionRepository 调用其onMessage() 方法来处理消息</p><p><a href="https://juejin.cn/post/6844904159091621901">Spring Session Data Redis 源码解析</a></p><p>排查问题的时候要灵活阅读异常栈的信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE 各大厂商JDK</title>
      <link href="/2021-04-07-JavaSE%E5%90%84%E5%A4%A7%E5%8E%82%E5%95%86JDK.html"/>
      <url>/2021-04-07-JavaSE%E5%90%84%E5%A4%A7%E5%8E%82%E5%95%86JDK.html</url>
      
        <content type="html"><![CDATA[<h1 id="2022-07-08-UPDATE"><a href="#2022-07-08-UPDATE" class="headerlink" title="2022-07-08 UPDATE"></a>2022-07-08 UPDATE</h1><p>资源站 <a href="https://www.injdk.cn/">Java I tell you-爪哇我话你知</a></p><h1 id="Oracle-JDK"><a href="#Oracle-JDK" class="headerlink" title="Oracle JDK"></a>Oracle JDK</h1><p>Oracle官方的商业JDK，收费。</p><h1 id="Oracle-OpenJDK"><a href="#Oracle-OpenJDK" class="headerlink" title="Oracle OpenJDK"></a>Oracle OpenJDK</h1><p>Oracle官方的商业JDK的社区版，免费。</p><h1 id="Amazon-Corretto"><a href="#Amazon-Corretto" class="headerlink" title="Amazon Corretto"></a>Amazon Corretto</h1><p>Amazon Corretto 是亚马逊基于 开放Java 开发工具包 (OpenJDK) 的免费、多平台、生产就绪型发行版。Corretto 提供长期支持，其中包括性能增强和安全修复。亚马逊在内部的数千种生产服务上运行 Corretto，并且 Corretto 已被证明能够兼容 Java SE 标准。借助 Corretto，您可以在常用操作系统（包括 Linux、Windows 和 macOS）上开发和运行 Java 应用程序。</p><h1 id="BellSoft-Liberica-JDK"><a href="#BellSoft-Liberica-JDK" class="headerlink" title="BellSoft Liberica JDK"></a>BellSoft Liberica JDK</h1><p>OpenJDK 的贡献者之一 BellSoft发布的基于OpenJDK的免费版。</p><h1 id="AdoptOpenJDK"><a href="#AdoptOpenJDK" class="headerlink" title="AdoptOpenJDK"></a>AdoptOpenJDK</h1><p>现属于Eclipse基金会的基于OpenJDK发布的免费版本，支持Oracle公司的HotSpot虚拟机和Eclipse基金会的OpenJ9虚拟机。</p><h1 id="Azul-Zulu-OpenJDK"><a href="#Azul-Zulu-OpenJDK" class="headerlink" title="Azul Zulu OpenJDK"></a>Azul Zulu OpenJDK</h1><p>Azul 成立于 2002 年，是一家私营软件公司，总部位于加州桑尼维尔，在全球设有销售、技术支持和工程办事处，基于OpenJDK发布，免费。</p><h1 id="SAP-SapMachine"><a href="#SAP-SapMachine" class="headerlink" title="SAP SapMachine"></a>SAP SapMachine</h1><p>SAP是OpenJDK项目的贡献者之一，基于OpenJDK发布，免费。</p><h1 id="Red-Hat-build-of-OpenJDK"><a href="#Red-Hat-build-of-OpenJDK" class="headerlink" title="Red Hat build of OpenJDK"></a>Red Hat build of OpenJDK</h1><p>Red Hat(红帽子)公司基于OpenJDK发布的免费版。</p><h1 id="阿里巴巴Dragonwell-JDK"><a href="#阿里巴巴Dragonwell-JDK" class="headerlink" title="阿里巴巴Dragonwell JDK"></a>阿里巴巴Dragonwell JDK</h1><p>Alibaba Dragonwell 是一款免费的, 生产就绪型Open JDK 发行版，提供长期支持，包括性能增强和安全修复。阿里巴巴拥有最丰富的Java应用场景，覆盖电商，金融，物流等众多领域，世界上最大的Java用户之一。Alibaba Dragonwell作为Java应用的基石，支撑了阿里经济体内所有的Java业务。Alibaba Dragonwell完全兼容 Java SE 标准，您可以在任何常用操作系统（包括 Linux、Windows 和 macOS）上开发 Java 应用程序， 运行时生产环境选择Alibaba Dragonwell。</p><h1 id="腾讯Kona-JDK"><a href="#腾讯Kona-JDK" class="headerlink" title="腾讯Kona JDK"></a>腾讯Kona JDK</h1><p>腾讯 Kona（Tencent Kona，TK）是免费、可立即投入生产的 OpenJDK 发行版。腾讯 Kona 基于 TencentJDK 开发，针对云应用场景定制新的功能及优化， 具备更快的云应用启动速度，更好的性能以及更为便捷的分析、诊断工具；此外，腾讯 Kona 服务于腾讯内部大量 Java 应用程序，提供稳定、高效的运行环境。 </p><h1 id="华为毕昇JDK"><a href="#华为毕昇JDK" class="headerlink" title="华为毕昇JDK"></a>华为毕昇JDK</h1><p>华为内部OpenJDK定制版的开源版本，是一个高性能、可用于生产环境的OpenJDK发行版。</p><p><img src="/../../../../image/jdk_1.png" alt="jdk_1"></p><p><img src="/../../../../image/jdk_2.png" alt="jdk_2"></p><p><img src="/../../../../image/jdk_3.png" alt="jdk_3"></p><hr><p>reference</p><p><a href="https://www.huoxiaoqiang.com/java/javahigh/2381.html">6.Java SE 各大厂商JDK大全一览表 | 霍小强博客</a></p><p><a href="https://developer.okta.com/blog/2019/01/16/which-java-sdk">Which Java SDK Should You Use? | Okta Developer</a></p><p><a href="https://snyk.io/blog/36-of-developers-switched-from-oracle-jdk-to-an-alternate-openjdk-distribution-over-the-last-year/">36% of developers switched from Oracle JDK to an alternate OpenJDK distribution, over the last year | Snyk</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读RocketMQ源码(2) - 基础通信模块</title>
      <link href="/2021-03-17-%E9%98%85%E8%AF%BBRocketMQ%E6%BA%90%E7%A0%812.html"/>
      <url>/2021-03-17-%E9%98%85%E8%AF%BBRocketMQ%E6%BA%90%E7%A0%812.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础通信模块"><a href="#基础通信模块" class="headerlink" title="基础通信模块"></a>基础通信模块</h1><p>依赖netty实现,引入了netty-tcnative</p><h2 id="协议内容"><a href="#协议内容" class="headerlink" title="协议内容"></a>协议内容</h2><ul><li>4byte msg length</li><li>1byte serialization type</li><li>3byte header length</li><li>header</li><li>body</li></ul><h2 id="序列化-x2F-反序列化"><a href="#序列化-x2F-反序列化" class="headerlink" title="序列化&#x2F;反序列化"></a>序列化&#x2F;反序列化</h2><p>在<code>RemotingCommand</code>类的<code>encode()</code>方法中可以看到序列化的过程</p><ul><li>RocketMQSerializable, 序列化为bytes, 用ByteBuffer实现</li><li>RemotingSerializable, 序列化为Json, 用fastjson实现</li></ul><p>在获取selector时针对Linux特殊处理, 尝试获取<code>sun.nio.ch.EPollSelectorProvider</code>, 笔者使用macOS装有Java1.8 HotSpotJVM, 使用了<code>sun.nio.ch.KQueueSelectorProvider</code></p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p><img src="/../../../../image/rocketmq_design_3.png" alt="rocketmq_design_3"></p><p>在<code>NettyRemotingAbstract</code>类中实现了三种通信方式</p><ul><li>sync</li><li>async</li><li>oneway</li></ul><h2 id="异步请求的流程"><a href="#异步请求的流程" class="headerlink" title="异步请求的流程"></a>异步请求的流程</h2><p><img src="/../../../../image/rocketmq_design_5.png" alt="rocketmq_design_5"></p><ol><li><p><strong>client</strong> Assemle remotingCommand and generate callbacks (MQClientAPIImpl.sendMessage())</p></li><li><p><strong>client</strong> create a chennel for communication based on addr (NettyRemotingClient.getAndCreateChannel())</p></li><li><p><strong>client</strong> Acquisition semaphore (NettyRemotingAbstract.invokeAsyncImpl())</p></li><li><p><strong>client</strong> give opaque access to ResponseFuture (NettyRemotingAbstract.invokeAsyncImpl())</p></li><li><p><strong>client</strong> call netty’s channel’s writeAndFlush (NettyRemotingAbstract.invokeAsyncImpl())</p></li></ol><h3 id="serverHandler-receive-and-process-message"><a href="#serverHandler-receive-and-process-message" class="headerlink" title="serverHandler: receive and process message"></a>serverHandler: receive and process message</h3><h3 id="server-the-processMessageReceived-method-process"><a href="#server-the-processMessageReceived-method-process" class="headerlink" title="server: the processMessageReceived method process"></a>server: the processMessageReceived method process</h3><h3 id="server-get-the-corresponding-processor-according-to-the-business-code"><a href="#server-get-the-corresponding-processor-according-to-the-business-code" class="headerlink" title="server: get the corresponding processor according to the business code"></a>server: get the corresponding processor according to the business code</h3><h3 id="server-the-business-processor-executes-and-gets-the-responds-result"><a href="#server-the-business-processor-executes-and-gets-the-responds-result" class="headerlink" title="server: the business processor executes and gets the responds result"></a>server: the business processor executes and gets the responds result</h3><h3 id="server-determines-whether-the-request-is-one-way"><a href="#server-determines-whether-the-request-is-one-way" class="headerlink" title="server: determines whether the request is one-way"></a>server: determines whether the request is one-way</h3><h3 id="server-set-opaque-to-the-response-and-send-it-to-the-client-side"><a href="#server-set-opaque-to-the-response-and-send-it-to-the-client-side" class="headerlink" title="server: set opaque to the response and send it to the client side"></a>server: set opaque to the response and send it to the client side</h3><h3 id="clientHandler-read-the-message-that-netty-receives-and-process"><a href="#clientHandler-read-the-message-that-netty-receives-and-process" class="headerlink" title="clientHandler: read the message that netty receives and process"></a>clientHandler: read the message that netty receives and process</h3><h3 id="client-get-responseFuture-based-on-opaque"><a href="#client-get-responseFuture-based-on-opaque" class="headerlink" title="client: get responseFuture based on opaque"></a>client: get responseFuture based on opaque</h3><h3 id="client-execute-the-callback-method"><a href="#client-execute-the-callback-method" class="headerlink" title="client: execute the callback method"></a>client: execute the callback method</h3><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="获取当前os版本"><a href="#获取当前os版本" class="headerlink" title="获取当前os版本"></a>获取当前os版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br></pre></td></tr></table></figure><hr><p>reference</p><p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#2-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6">2-通信机制 at master · apache&#x2F;rocketmq</a></p><p><a href="https://jaskey.github.io/blog/2016/12/19/rocketmq-network-protocol/">RocketMQ——通信协议 - 薛定谔的风口猪</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读RocketMQ源码(1) - 项目信息,本地日志模块</title>
      <link href="/2021-02-19-%E9%98%85%E8%AF%BBRocketMQ%E6%BA%90%E7%A0%811.html"/>
      <url>/2021-02-19-%E9%98%85%E8%AF%BBRocketMQ%E6%BA%90%E7%A0%811.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>源码: <a href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a></p><p>官网: <a href="https://rocketmq.apache.org/">https://rocketmq.apache.org</a></p><p>中文文档: <a href="https://github.com/apache/rocketmq/tree/master/docs/cn">https://github.com/apache/rocketmq/tree/master/docs/cn</a></p><p>版本: 4.8</p><h1 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h1><p>用idea的analyze module dependencies功能整理出依赖顺序,也是阅读顺序</p><ul><li>logging, 本地日志模块</li><li>remoting, 通信模块</li><li>common, 工具类</li><li>srvutil, 命令行交互工具类</li><li>acl, 网络控制工具</li><li>client, 客户端代码</li><li>filter, 过滤器解析代码</li><li>logappender, 对几种日志框架的适配</li><li>store, 落盘逻辑</li><li>tools, 监控工具</li><li>openmessaging, open-message协议实现</li><li>broker, broker代码</li><li>namesrv, 路由注册中心</li></ul><h1 id="本地日志模块"><a href="#本地日志模块" class="headerlink" title="本地日志模块"></a>本地日志模块</h1><p>Log4j的最精简fork</p><p>Appender -&gt; Logger(AppenderPipeline)</p><p>实现了<code>RollingFileAppender</code>等多种appender,用到writer和buffer</p><p><code>SysLogger</code>即标准输入输出兜底</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="获取当前系统的行分隔符"><a href="#获取当前系统的行分隔符" class="headerlink" title="获取当前系统的行分隔符"></a>获取当前系统的行分隔符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;line.separator&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>jvm回收该对象时执行,用来释放一些手动申请的资源</p><p>大量对象同时执行finalize可能引起执行队列堆积</p><p>Java9开始被java.lang.ref.Cleaner和java.lang.ref.PhantomReference代替</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>product</p><ul><li>InternalLogger</li></ul><p>concreate products</p><ul><li>InnerLogger</li><li>Slf4jLogger</li></ul><p>creator</p><ul><li>InternalLoggerFactory</li></ul><p>concreate creators</p><ul><li>InnerLoggerFactory</li><li>Slf4jLoggerFactory</li></ul><p>creator给concreate creators提供注册方法,给用户提供生产方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csrankings会议索引</title>
      <link href="/2021-02-07-csrankings%E4%BC%9A%E8%AE%AE%E7%B4%A2%E5%BC%95.html"/>
      <url>/2021-02-07-csrankings%E4%BC%9A%E8%AE%AE%E7%B4%A2%E5%BC%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><h2 id="Artificial-intelligence-人工智能"><a href="#Artificial-intelligence-人工智能" class="headerlink" title="Artificial intelligence 人工智能"></a>Artificial intelligence 人工智能</h2><ul><li>AAAI</li><li>IJCAI</li></ul><h2 id="Computer-vision-计算机视觉"><a href="#Computer-vision-计算机视觉" class="headerlink" title="Computer vision 计算机视觉"></a>Computer vision 计算机视觉</h2><ul><li>CVPR</li><li>ECCV</li><li>ICCV</li></ul><h2 id="Machine-learning-amp-data-mining-机器学习-amp-数据挖掘"><a href="#Machine-learning-amp-data-mining-机器学习-amp-数据挖掘" class="headerlink" title="Machine learning &amp; data mining 机器学习&amp;数据挖掘"></a>Machine learning &amp; data mining 机器学习&amp;数据挖掘</h2><ul><li>ICML</li><li>KDD</li><li>NIPS</li></ul><h2 id="Natural-language-processing-自然语言处理"><a href="#Natural-language-processing-自然语言处理" class="headerlink" title="Natural language processing 自然语言处理"></a>Natural language processing 自然语言处理</h2><ul><li>ACL</li><li>EMNLP</li><li>NAACL</li></ul><h2 id="The-Web-amp-information-retrieval-网络信息检索"><a href="#The-Web-amp-information-retrieval-网络信息检索" class="headerlink" title="The Web &amp; information retrieval 网络信息检索"></a>The Web &amp; information retrieval 网络信息检索</h2><ul><li>SIGIR</li><li>WWW</li></ul><h1 id="Systems"><a href="#Systems" class="headerlink" title="Systems"></a>Systems</h1><h2 id="Computer-architecture-计算机架构"><a href="#Computer-architecture-计算机架构" class="headerlink" title="Computer architecture 计算机架构"></a>Computer architecture 计算机架构</h2><ul><li>ASPLOS</li><li>ISCA</li><li>MICRO</li></ul><h2 id="Operating-systems-操作系统"><a href="#Operating-systems-操作系统" class="headerlink" title="Operating systems 操作系统"></a>Operating systems 操作系统</h2><ul><li>OSDI</li><li>SOSP</li></ul><h2 id="Computer-networks-计算机网络"><a href="#Computer-networks-计算机网络" class="headerlink" title="Computer networks 计算机网络"></a>Computer networks 计算机网络</h2><ul><li>SIGCOMM</li><li>NSDI</li></ul><h2 id="Computer-security-计算机安全"><a href="#Computer-security-计算机安全" class="headerlink" title="Computer security 计算机安全"></a>Computer security 计算机安全</h2><ul><li>CCS</li><li>IEEE S&amp;P</li><li>USENIX</li></ul><h2 id="Databases-数据库"><a href="#Databases-数据库" class="headerlink" title="Databases 数据库"></a>Databases 数据库</h2><ul><li>SIGMOD</li><li>VLDB</li></ul><h2 id="Programming-languages-编程语言"><a href="#Programming-languages-编程语言" class="headerlink" title="Programming languages 编程语言"></a>Programming languages 编程语言</h2><ul><li>PLDI</li><li>POPL</li></ul><h2 id="Design-automation-设计自动化"><a href="#Design-automation-设计自动化" class="headerlink" title="Design automation 设计自动化"></a>Design automation 设计自动化</h2><ul><li>DAC</li><li>ICCAD</li></ul><h2 id="Embedded-amp-real-time-systems-嵌入式和实时系统"><a href="#Embedded-amp-real-time-systems-嵌入式和实时系统" class="headerlink" title="Embedded &amp; real-time systems 嵌入式和实时系统"></a>Embedded &amp; real-time systems 嵌入式和实时系统</h2><ul><li>EMSOFT</li><li>RTAS</li><li>RTSS</li></ul><h2 id="High-performance-computing-高性能计算"><a href="#High-performance-computing-高性能计算" class="headerlink" title="High-performance computing 高性能计算"></a>High-performance computing 高性能计算</h2><ul><li>HPDC</li><li>ICS</li><li>SC</li></ul><h2 id="Mobile-computing-移动计算"><a href="#Mobile-computing-移动计算" class="headerlink" title="Mobile computing 移动计算"></a>Mobile computing 移动计算</h2><ul><li>MobiCom</li><li>MobiSys</li><li>SenSys</li></ul><h2 id="Measurement-amp-perf-analysis-测量与性能分析"><a href="#Measurement-amp-perf-analysis-测量与性能分析" class="headerlink" title="Measurement &amp; perf. analysis 测量与性能分析"></a>Measurement &amp; perf. analysis 测量与性能分析</h2><ul><li>IMC</li><li>SIGMETRICS</li></ul><h2 id="Software-engineering-软件工程"><a href="#Software-engineering-软件工程" class="headerlink" title="Software engineering 软件工程"></a>Software engineering 软件工程</h2><ul><li>FSE</li><li>ICSE</li></ul><h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1><h2 id="Algorithms-amp-complexity-算法与复杂度"><a href="#Algorithms-amp-complexity-算法与复杂度" class="headerlink" title="Algorithms &amp; complexity 算法与复杂度"></a>Algorithms &amp; complexity 算法与复杂度</h2><ul><li>FOCS</li><li>SODA</li><li>STOC</li></ul><h2 id="Cryptography-密码学"><a href="#Cryptography-密码学" class="headerlink" title="Cryptography 密码学"></a>Cryptography 密码学</h2><ul><li>CRYPTO</li><li>EuroCrypt</li></ul><h2 id="Logic-amp-verification-逻辑与验证"><a href="#Logic-amp-verification-逻辑与验证" class="headerlink" title="Logic &amp; verification 逻辑与验证"></a>Logic &amp; verification 逻辑与验证</h2><ul><li>CAV</li><li>LICS</li></ul><h1 id="Interdisciplinary-Areas"><a href="#Interdisciplinary-Areas" class="headerlink" title="Interdisciplinary Areas"></a>Interdisciplinary Areas</h1><h2 id="Computer-graphics-计算机图形学"><a href="#Computer-graphics-计算机图形学" class="headerlink" title="Computer graphics 计算机图形学"></a>Computer graphics 计算机图形学</h2><ul><li>SIGGRAPH</li><li>SIGGRAPH Asia</li></ul><h2 id="Economics-amp-computation-经济与计算"><a href="#Economics-amp-computation-经济与计算" class="headerlink" title="Economics &amp; computation 经济与计算"></a>Economics &amp; computation 经济与计算</h2><ul><li>EC</li><li>WINE</li></ul><h2 id="Comp-bio-amp-bioinformatics-生物信息学"><a href="#Comp-bio-amp-bioinformatics-生物信息学" class="headerlink" title="Comp. bio &amp; bioinformatics 生物信息学"></a>Comp. bio &amp; bioinformatics 生物信息学</h2><ul><li>ISMB</li><li>RECOMB</li></ul><h2 id="Human-computer-interaction-人机交互"><a href="#Human-computer-interaction-人机交互" class="headerlink" title="Human-computer interaction 人机交互"></a>Human-computer interaction 人机交互</h2><ul><li>CHI</li><li>UbiComp &#x2F; Pervasive &#x2F; IMWUT</li><li>UIST</li></ul><h2 id="Robotics-机器人技术"><a href="#Robotics-机器人技术" class="headerlink" title="Robotics 机器人技术"></a>Robotics 机器人技术</h2><ul><li>ICRA</li><li>IROS</li><li>RSS</li></ul><h2 id="Visualization-可视化"><a href="#Visualization-可视化" class="headerlink" title="Visualization 可视化"></a>Visualization 可视化</h2><ul><li>VIS</li><li>VR</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java几个常用的io类</title>
      <link href="/2021-01-28-Java%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84io%E7%B1%BB.html"/>
      <url>/2021-01-28-Java%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84io%E7%B1%BB.html</url>
      
        <content type="html"><![CDATA[<h1 id="字节流-InputStream-x2F-OutputStream"><a href="#字节流-InputStream-x2F-OutputStream" class="headerlink" title="字节流 InputStream&#x2F;OutputStream"></a>字节流 InputStream&#x2F;OutputStream</h1><h2 id="ByteArray"><a href="#ByteArray" class="headerlink" title="ByteArray"></a>ByteArray</h2><p>数据被写入一个byte数组, 缓冲区会随着数据的不断写入而自动增长</p><h2 id="Piped"><a href="#Piped" class="headerlink" title="Piped"></a>Piped</h2><p>多线程可以通过管道进行线程间的通讯</p><p>我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据</p><p>使用时需要注意设置合适的缓冲区大小, 不会自动增长</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>对基本数据和实现了 java.io.Serializable 接口的对象进行序列化操作支持</p><p>序列化不会自动保存static和transient变量”，因此我们若要保存它们，则需要通过writeObject()和readObject()去手动读写</p><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>读写文件</p><h2 id="Buffered"><a href="#Buffered" class="headerlink" title="Buffered"></a>Buffered</h2><p>继承自FileterStream，提供内部缓冲区数组</p><p>内部使用volatile和AtomicReferenceFieldUpdater保证字段更新的原子性</p><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型</p><h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><p>允许格式化打印流</p><p>System.out is instance of PrintStream</p><h1 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h1><p>支持对文件随机访问的读取和写入</p><hr><p>参考文章</p><p><a href="https://www.cnblogs.com/skywang12345/p/io_01.html">java io系列01之 “目录”</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot内置的tomcat</title>
      <link href="/2020-12-23-springboot%E5%86%85%E7%BD%AE%E7%9A%84tomcat.html"/>
      <url>/2020-12-23-springboot%E5%86%85%E7%BD%AE%E7%9A%84tomcat.html</url>
      
        <content type="html"><![CDATA[<h1 id="服务器接收到网络包"><a href="#服务器接收到网络包" class="headerlink" title="服务器接收到网络包"></a>服务器接收到网络包</h1><ol><li>网卡接收到网络包,使用DMA不经过CPU直接将数据包放到Circular buffer(圆形缓冲区,适合先进先出,旧数据读出后新数据不需要移位)</li><li>网卡发送硬中断信号,操作系统使用软中断处理多个数据包,没有新数据再恢复终端</li><li>操作系统将数据从Circular buffer拷贝到sk_buff缓冲区,网络层,传输层,通过socket转交给用户进程</li></ol><p>简单解析<br><a href="https://xie.infoq.cn/article/6ba14b756c3019cc737ed48a6">你不好奇 Linux 网络发包过程吗？ - InfoQ 写作平台</a><br><a href="https://segmentfault.com/a/1190000008836467">Linux网络 - 数据包的接收过程_Linux程序员 - SegmentFault 思否</a><br>源码解析<br><a href="https://zhuanlan.zhihu.com/p/256428917">图解Linux网络包接收过程 - 知乎</a><br><a href="https://plantegg.github.io/2019/05/08/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82%E7%BD%91%E7%BB%9C--%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84%E6%B5%81%E8%BD%AC/">就是要你懂网络–网络包的流转 | plantegg</a></p><h1 id="springboot支持不同的Java-servlet服务器"><a href="#springboot支持不同的Java-servlet服务器" class="headerlink" title="springboot支持不同的Java servlet服务器"></a>springboot支持不同的Java servlet服务器</h1><p>服务器接收到http请求, 操作系统建立了TCP连接之后</p><p>见 <a href="https://docs.spring.io/spring-boot/docs/2.1.10.RELEASE/reference/html/howto-embedded-web-servers.html">78. Embedded Web Servers</a> , springboot默认内置tomcat服务器, 可以通过修改pom配置切换为jetty或undertow</p><h1 id="tomcat内置线程池"><a href="#tomcat内置线程池" class="headerlink" title="tomcat内置线程池"></a>tomcat内置线程池</h1><p>springboot内置的tomcat <a href="https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-core">org.apache.tomcat.embed:tomcat-embed-core</a> 中,负责处理请求的线程池由AbstractEndpoint维护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    internalExecutor = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">TaskQueue</span> <span class="variable">taskqueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">    <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果使用springboot默认的参数,corePoolSize=<span class="number">10</span>,maxPoolSize=<span class="number">200</span>,keepAliveTime=60s,</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/l4642247/article/details/81631770">https://blog.csdn.net/l4642247/article/details/81631770</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU常识</title>
      <link href="/2020-11-23-CPU%E5%B8%B8%E8%AF%86.html"/>
      <url>/2020-11-23-CPU%E5%B8%B8%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="按指令集划分"><a href="#按指令集划分" class="headerlink" title="按指令集划分"></a>按指令集划分</h1><ul><li>CISC指令集<ul><li>X86架构<ul><li>Intel</li><li>AMD</li></ul></li></ul></li><li>RISC指令集<ul><li>ARM架构<ul><li>ARM</li></ul></li><li>MIPS架构</li><li>RISC-V</li></ul></li></ul><h1 id="Intel产品线"><a href="#Intel产品线" class="headerlink" title="Intel产品线"></a>Intel产品线</h1><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><ul><li>Xeon至强</li><li>Itanium安腾</li></ul><h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><ul><li>Core酷睿</li><li>Pentium奔腾</li><li>Celeron赛扬</li></ul><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><ul><li>Atom凌动</li><li>Quark SOC</li></ul><h1 id="Intel的后缀"><a href="#Intel的后缀" class="headerlink" title="Intel的后缀"></a>Intel的后缀</h1><ul><li>G, 附带AMD的GPU</li><li>K, 可超频</li><li>T, 低压版桌面</li><li>Y,M,U, 低压版移动</li><li>X, 当代最强</li></ul><h1 id="AMD产品线"><a href="#AMD产品线" class="headerlink" title="AMD产品线"></a>AMD产品线</h1><h2 id="PC-1"><a href="#PC-1" class="headerlink" title="PC"></a>PC</h2><ul><li>RyzenThreadripper锐龙线程撕裂者</li><li>Ryzen锐龙</li><li>Athlon速龙</li></ul><h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><ul><li>Radeon</li><li>Radeon Pro</li><li>FirePro</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见Linux发行版</title>
      <link href="/2020-06-17-%E5%B8%B8%E8%A7%81Linux%E5%8F%91%E8%A1%8C%E7%89%88.html"/>
      <url>/2020-06-17-%E5%B8%B8%E8%A7%81Linux%E5%8F%91%E8%A1%8C%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="派生关系"><a href="#派生关系" class="headerlink" title="派生关系"></a>派生关系</h1><p>Red Hat Enterprise Linux</p><ul><li>CentOS</li><li>Fedora</li></ul><p>Debian</p><ul><li>Ubuntu<ul><li>Elementary OS</li></ul></li><li>Deepin</li></ul><p>Arch</p><p>Gentoo</p><h1 id="版本简介"><a href="#版本简介" class="headerlink" title="版本简介"></a>版本简介</h1><h2 id="Red-Hat-Enterprise-Linux"><a href="#Red-Hat-Enterprise-Linux" class="headerlink" title="Red Hat Enterprise Linux"></a>Red Hat Enterprise Linux</h2><p>Red Hat Linux是由Red Hat公司发行的一个Linux发行包</p><p>Red Hat Linux中的RPM软件包格式可以说是Linux社区的一个事实标准，被广泛使用于其他Linux发行包中</p><p>Red Hat公司不再开发桌面版的Linux发行包，而将全部力量集中在服务器版的开发上</p><h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><p>CentOS（Community Enterprise Operating System）是Linux发行版之一，它是来自于Red Hat Enterprise Linux（RHEL）依照开放源代码规定发布的源代码所编译而成，两者的不同，在于CentOS并不包含封闭源代码软件。CentOS 对上游代码的主要修改是为了移除不能自由使用的商标。</p><p>CentOS和RHEL一样，都可以使用Fedora EPEL来补足软件</p><h2 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a>Fedora</h2><p>由Fedora项目社群开发、红帽公司赞助</p><p>Fedora对于用户而言，是一套功能完备、更新快速的免费操作系统；而对赞助者Red Hat公司而言，它是许多新技术的测试平台，被认为可用的技术最终会加入到Red Hat Enterprise Linux中</p><h2 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h2><p>作为最早的Linux发行版之一，Debian在创建之初便被定位为在GNU计划的精神指导下进行公开开发并自由发布的项目</p><p>dpkg是Debian中软件包管理的低级别基础工具。dpkg命令行工具并不知晓软件源的配置，其数据库仅存储已安装在当前系统中的软件包的信息</p><p>高级包装工具（APT）提供了管理Debian系统软件的功能，且可以从软件源获取并解析软件包依赖</p><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>Ubuntu基于Debian发行版和GNOME桌面环境</p><p>Ubuntu建基于Debian的不稳定分支：不论其软件格式（deb）还是软件管理与安装系统（Debian Apt）。Ubuntu的开发者会把对软件的修改即时反馈给Debian社群，而不是在发布新版时才宣布这些修改</p><p>Ubuntu所有系统相关的任务均需使用Sudo指令是它的一大特色，这种方式比传统的以系统管理员账号进行管理工作的方式更为安全</p><h2 id="Elementary-OS"><a href="#Elementary-OS" class="headerlink" title="Elementary OS"></a>Elementary OS</h2><p>elementary OS是一个基于Ubuntu的桌面Linux发行版。它采用自有的基于GNOME的名为Pantheon的桌面环境</p><p>这个桌面环境出众的原因是它深度集成了其他elementary OS应用程序，如Plank（一个基于Docky的Dock) 、Midori（默认的网页浏览器）或Scratch（一个简单的文本编辑器）</p><h2 id="Deepin"><a href="#Deepin" class="headerlink" title="Deepin"></a>Deepin</h2><p>deepin继承了来自Debian stable的所有软件包，并为自己的软件库提供了流行的软件</p><p>现在deepin的CrossOver授权已经到期，但是deepin又自主开发了基于wine的deepinwine，因此deepin仍可以较好的运行一些Windows上的软件</p><h2 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h2><p>Arch Linux 采用滚动发行模式，即没有所谓的大版本更新，每次常规更新都会将系统和软件保持在最新状态</p><p>通过二进制包管理系统pacman，仅需一个命令就能完成安装、升级等多个操作</p><h2 id="Gentoo"><a href="#Gentoo" class="headerlink" title="Gentoo"></a>Gentoo</h2><p>Gentoo Linux为用户提供了大量的应用程序源代码。Gentoo Linux的每一部分都可以在最终用户的系统上重新编译建造，甚至包括最基本的系统库和编译器自身，基于Portage包管理系统</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC的概念</title>
      <link href="/2020-04-17-RPC%E6%A6%82%E5%BF%B5.html"/>
      <url>/2020-04-17-RPC%E6%A6%82%E5%BF%B5.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>RPC</strong></p><ul><li>序列化&#x2F;反序列化</li><li>网络通讯</li></ul><p><strong>分布式RPC</strong></p><ul><li>服务注册&#x2F;查询</li><li>RPC</li></ul><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p><strong>GRPC</strong></p><ul><li>protobuf</li><li>http2, netty(Java)</li></ul><p><strong>dubbo</strong></p><ul><li>hessian等多种序列化</li><li>tcp, dubbo协议, netty</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2020-03-23-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"/>
      <url>/2020-03-23-%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Executor-与-线程池"><a href="#Executor-与-线程池" class="headerlink" title="Executor 与 线程池"></a>Executor 与 线程池</h1><h2 id="基本接口"><a href="#基本接口" class="headerlink" title="基本接口"></a>基本接口</h2><p>Java.util.concurrent 包定义了三种 executor 接口：</p><ul><li>Executor，支持加载新任务的简单接口</li><li>ExecutorService，Executor 的子接口，增加了帮助管理任务和executor本身的生命周期的功能</li><li>ScheduledExecutorService，ExecutorService 的子接口，支持周期性地执行任务</li></ul><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 接口只定义了一个方法 execute，被设计用来代替一般的创建线程惯例</p><pre><code>// r implements Runnable// 1. 自己控制线程(new Thread(r)).start();// 2. 用 executore.execute(r);</code></pre><p>对于 execute 方法的实现并没有特殊要求。低级的实现只是创建一个新的线程并立即执行</p><p>但更有可能是使用一个已经存在的工作线程（worker Threads）去执行 r，或者将 r 放在一个执行队列中等待工作线程有空的时候再执行</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>ExecutorService 接口提供了另一个相似的 submit 方法，但比 execute 更加通用</p><p>和 execute 一样，submit 接受 Runnable 对象，但也接受 Callable 对象，Callable 允许任务执行后返回一个值</p><p>Submit 方法返回 Future 对象，Future 对象被用来接收 Callable 返回的值，并管理 Callable 和 Runnable 对象所代表的任务</p><h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><p>ScheduledExecutorService 接口为它的父类 ExecutorService 的行为提供计划，允许在执行 Runnable 和 Callable 任务之前停顿一段时间</p><p>接口定义了 scheduleAtFixedRate 和 scheduleWithFixedDelay，这两个方法以特定的时间间隔重复地执行特定任务</p><h2 id="ThreadPoolExecutor-的构造参数"><a href="#ThreadPoolExecutor-的构造参数" class="headerlink" title="ThreadPoolExecutor 的构造参数"></a>ThreadPoolExecutor 的构造参数</h2><p>构造函数</p><pre><code>ThreadPoolExecutor(    int corePoolSize,                  // 核心线程数    int maximumPoolSize,               // 最大线程数    long keepAliveTime,                // 空闲线程存活时间：空闲线程即超过核心线程数的工作线程    TimeUnit unit,                     // keepAliveTime的单位    BlockingQueue&lt;Runnable&gt; workQueue, // 线程池内部的等待队列：工作线程数等于核心线程数时，新任务放到等待队列中    ThreadFactory threadFactory,       // 线程工厂，创建新线程的方式    RejectedExecutionHandler handler   // 饱和策略：工作线程数等于最大线程数，且等待队列已满，处理新任务);</code></pre><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>系统资源是有限的，任务的处理速度总有可能比不上任务的提交速度，因此，可以为ThreadPoolExecutor提供一个阻塞队列来保存因线程不足而等待的Runnable任务，这就是BlockingQueue</p><p>JDK为BlockingQueue提供了几种实现方式，常用的有：</p><ul><li>ArrayBlockingQueue：数组结构的阻塞队列</li><li>LinkedBlockingQueue：链表结构的阻塞队列</li><li>PriorityBlockingQueue：有优先级的阻塞队列</li><li>SynchronousQueue：不会存储元素的阻塞队列</li></ul><p>newFixedThreadPool 和 newSingleThreadExecutor 在默认情况下使用一个无界的 LinkedBlockingQueue</p><p>newCachedThreadPool 使用的 SynchronousQueue 十分有趣，看名称是个队列，但它却不能存储元素。要将一个任务放进队列，必须有另一个线程去接收这个任务，一个进就有一个出，队列不会存储任何东西。因此，SynchronousQueue 是一种移交机制，不能算是队列。newCachedThreadPool 生成的是一个没有上限的线程池，理论上提交多少任务都可以，使用 SynchronousQueue 作为等待队列正合适</p><h2 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h2><p>当有界的等待队列满了之后，就需要用到饱和策略去处理，ThreadPoolExecutor的饱和策略通过传入RejectedExecutionHandler来实现。如果没有为构造函数传入，将会使用默认的defaultHandler。</p><pre><code>private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();public static class AbortPolicy implements RejectedExecutionHandler &#123;    public AbortPolicy() &#123; &#125;    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString());    &#125;&#125;</code></pre><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>每当线程池需要创建一个新线程，都是通过线程工厂获取。如果不为ThreadPoolExecutor设定一个线程工厂，就会使用默认的 defaultThreadFactory：</p><pre><code>public static ThreadFactory defaultThreadFactory() &#123;    return new DefaultThreadFactory();&#125;static class DefaultThreadFactory implements ThreadFactory &#123;    private static final AtomicInteger poolNumber = new AtomicInteger(1);    private final ThreadGroup group;    private final AtomicInteger threadNumber = new AtomicInteger(1);    private final String namePrefix;    DefaultThreadFactory() &#123;        SecurityManager s = System.getSecurityManager();        group = (s != null) ? s.getThreadGroup() :        Thread.currentThread().getThreadGroup();        namePrefix = &quot;pool-&quot; +            poolNumber.getAndIncrement() +            &quot;-thread-&quot;;    &#125;    public Thread newThread(Runnable r) &#123;        Thread t = new Thread(group, r,                              namePrefix + threadNumber.getAndIncrement(),                              0);        if (t.isDaemon())            t.setDaemon(false);        if (t.getPriority() != Thread.NORM_PRIORITY)            t.setPriority(Thread.NORM_PRIORITY);        return t;    &#125;&#125;</code></pre><p>平时打印线程池里线程的name时，会输出形如pool-1-thread-1之类的名称，就是在这里设置的。这个默认的线程工厂，创建的线程是普通的非守护线程，如果需要定制，实现ThreadFactory后传给ThreadPoolExecutor即可</p><h2 id="ThreadPoolExecutor-类"><a href="#ThreadPoolExecutor-类" class="headerlink" title="ThreadPoolExecutor 类"></a>ThreadPoolExecutor 类</h2><h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><ul><li><p>AtomicInteger ctl  runState 是线程池运行状态，workerCount 是工作线程的数量，ctl 用一个32位的int来同时保存 runState 和 workerCount，其中高3位是 runState，其余29位是 workerCount，代码中会反复使用 runStateOf() 和 workerCountOf() 来获取 runState 和 workerCount </p><p>  &#x2F;&#x2F; ctl<br>  private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));<br>  private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;<br>  private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</p><p>  &#x2F;&#x2F; Packing and unpacking ctl<br>  private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }<br>  private static int workerCountOf(int c)  { return c &amp; CAPACITY; }<br>  private static int ctlOf(int rs, int wc) { return rs | wc; }</p></li><li><p>BlockingQueue<Runnable> workQueue  等待队列</p></li><li><p>HashSet<Worker> workers  工作线程</p></li></ul><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>线程池是由Worker类负责执行任务，Worker继承了AbstractQueuedSynchronizer，引出了Java并发框架的核心AQS。</p><p>AbstractQueuedSynchronizer，简称AQS，是Java并发包里一系列同步工具的基础实现，原理是根据状态位来控制线程的入队阻塞、出队唤醒来处理同步。</p><p>Worker利用AQS的功能实现对独占线程变量的设置，这是一个需要同步的过程</p><p>execute()</p><pre><code>public void execute(Runnable command) &#123;    // 参数检验    if (command == null)        throw new NullPointerException();    // 获取当前线程池状态    int c = ctl.get();    // 如果当前工作线程数 &lt; 核心线程数    if (workerCountOf(c) &lt; corePoolSize) &#123;        // 新建工作线程(worker)，若成功则返回        if (addWorker(command, true))            return;        // 若新建失败，更新线程池状态        c = ctl.get();    &#125;    // 在等待队列中新建线程成功    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        int recheck = ctl.get();        // 若线程池不处于RUNNING状态则删掉刚刚新建的线程并handle掉        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        // 如果此时没有工作线程(worker)，就添加个空的工作线程(worker)        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    &#125;    // 若之前在等待队列中新建线程失败，就新建为工作线程(worker)    else if (!addWorker(command, false))        // 如果新建工作线程(worker)失败就handle掉        reject(command);&#125;</code></pre><p>addWorker()</p><pre><code>// 用 lock 和 CAS 更新数据private boolean addWorker(Runnable firstTask, boolean core) &#123;    retry:    for (;;) &#123;        int c = ctl.get();        int rs = runStateOf(c);        // Check if queue empty only if necessary.        if (rs &gt;= SHUTDOWN &amp;&amp;            ! (rs == SHUTDOWN &amp;&amp;               firstTask == null &amp;&amp;               ! workQueue.isEmpty()))            return false;        for (;;) &#123;            int wc = workerCountOf(c);            if (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                return false;            if (compareAndIncrementWorkerCount(c))                break retry;            c = ctl.get();  // Re-read ctl            if (runStateOf(c) != rs)                continue retry;            // else CAS failed due to workerCount change; retry inner loop        &#125;    &#125;    boolean workerStarted = false;    boolean workerAdded = false;    Worker w = null;    try &#123;        w = new Worker(firstTask);        final Thread t = w.thread;        if (t != null) &#123;            final ReentrantLock mainLock = this.mainLock;            mainLock.lock();            try &#123;                // Recheck while holding lock.                // Back out on ThreadFactory failure or if                // shut down before lock acquired.                int rs = runStateOf(ctl.get());                if (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;                    if (t.isAlive()) // precheck that t is startable                        throw new IllegalThreadStateException();                    workers.add(w);                    int s = workers.size();                    if (s &gt; largestPoolSize)                        largestPoolSize = s;                    workerAdded = true;                &#125;            &#125; finally &#123;                mainLock.unlock();            &#125;            if (workerAdded) &#123;                t.start();                workerStarted = true;            &#125;        &#125;    &#125; finally &#123;        if (! workerStarted)            addWorkerFailed(w);    &#125;    return workerStarted;&#125;</code></pre><p>runWorker()</p><pre><code>final void runWorker(Worker w) &#123;    Thread wt = Thread.currentThread();    Runnable task = w.firstTask;    w.firstTask = null;    w.unlock(); // allow interrupts    boolean completedAbruptly = true;    try &#123;        // 从workQueue里拿task        while (task != null || (task = getTask()) != null) &#123;            w.lock();            // 保证了线程池在STOP状态下线程是中断的，非STOP状态下线程没有被中断            if ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            try &#123;                beforeExecute(wt, task);                Throwable thrown = null;                try &#123;                    task.run();                &#125; catch (RuntimeException x) &#123;                    thrown = x; throw x;                &#125; catch (Error x) &#123;                    thrown = x; throw x;                &#125; catch (Throwable x) &#123;                    thrown = x; throw new Error(x);                &#125; finally &#123;                    afterExecute(task, thrown);                &#125;            &#125; finally &#123;                task = null;                w.completedTasks++;                w.unlock();            &#125;        &#125;        completedAbruptly = false;    &#125; finally &#123;        processWorkerExit(w, completedAbruptly);    &#125;&#125;</code></pre><h2 id="工厂类-Executors"><a href="#工厂类-Executors" class="headerlink" title="工厂类 Executors"></a>工厂类 Executors</h2><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());&#125;</code></pre><p>FixedThreadPool 的优点是”优雅的缓冲”</p><p>考虑一个web应用服务，它的每一个线程只处理一个HTTP请求。如果这个应用简单地为每一个新来的请求创建一个新的处理线程，那么，当请求数量足够多时，线程占用的资源总和将超过系统的承受能力，服务器会因此忽然停止对所有请求的应答(常见的内存溢出)</p><p>而在使用固定大小线程池后，即使请求数量超出工作线程能够处理的请求上限，但是新来的HTTP请求会被暂时存放在消息队列中，当出现空闲的工作线程后，这些HTTP请求就会得到及时的处理</p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><pre><code>public static ExecutorService newSingleThreadExecutor() &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;</code></pre><p>newSingleThreadExecutor是线程数量固定为1的newFixedThreadPool版本，保证池内的任务串行 </p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><pre><code>public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre><p>newCachedThreadPool 生成一个会缓存的线程池，线程数量可以从0到 Integer.MAX_VALUE，超时时间为1分钟。线程池用起来的效果是：如果有空闲线程，会复用线程；如果没有空闲线程，会新建线程；如果线程空闲超过1分钟，将会被回收 </p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>使用完 ExecutorService 之后你应该将其关闭，以使其中的线程不再运行。</p><p>比如，如果你的应用是通过一个 main() 方法启动的，之后 main 方法退出了你的应用，如果你的应用有一个活动的 ExexutorService 它将还会保持运行。ExecutorService 里的活动线程阻止了 JVM 的关闭。</p><p>要终止 ExecutorService 里的线程你需要调用 ExecutorService 的 shutdown() 方法。ExecutorService 并不会立即关闭，但它将不再接受新的任务，而且一旦所有线程都完成了当前任务的时候，ExecutorService 将会关闭。在 shutdown() 被调用之前所有提交给 ExecutorService 的任务都被执行。如果你想要立即关闭 ExecutorService，你可以调用 shutdownNow() 方法。这样会立即尝试停止所有执行中的任务，并忽略掉那些已提交但尚未开始处理的任务。无法担保执行任务的正确执行。可能它们被停止了，也可能已经执行结束</p><hr><p>参考资料</p><p>分析Java线程池的创建 - 简书</p><p>分析Java线程池执行原理 - 简书</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误 [找不到或无法加载主类]排查流程</title>
      <link href="/2019-12-02-%5B%E9%94%99%E8%AF%AF%20%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB%5D%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B.html"/>
      <url>/2019-12-02-%5B%E9%94%99%E8%AF%AF%20%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB%5D%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$CLASSPATH</span></span><br></pre></td></tr></table></figure><p>结果均为空，将 CLASSPATH 初始化为<code>.</code>后报错不变</p><h1 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h1><p>maven package 出的 jar 包，想要直接 <code>java -jar</code> 运行的话需要在 <code>MANIFEST.MF</code> 中指定需要运行 main 的类 <code>Main-Class</code></p><p>maven 需要使用<code>maven-jar-plugin</code>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-jar-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.me.sip.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>以上均无误后还是报错，在服务器上尝试解压jar包直接运行</p><p>jar包本质是修改了后缀名的zip包，所以可以直接用 unzip 解压，尝试后依然不行</p><p>检查代码，期望调用的类是其他类的子类，形如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;SipMessageEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;niconiconi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, SipMessageEvent event)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将继承关系删掉后即可以正常执行</p><p>将两个版本的代码编译后的字节码进行反编译 <code>javap -c -l -v xx</code> 得到的信息来看 main 函数签名也没有区别</p><p>java8的jvm规范只说</p><blockquote><p>The Java Virtual Machine then links the initial class, initializes it, and invokes the public class method void main(String[])</p></blockquote><p>没有具体规定 main 函数的签名要求(也没有提 main 所在类的要求)，因此具体报错原因依然未知</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解NIO</title>
      <link href="/2019-10-18-%E7%90%86%E8%A7%A3NIO.html"/>
      <url>/2019-10-18-%E7%90%86%E8%A7%A3NIO.html</url>
      
        <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>以server处理socket连接为例, 标准的几步</p><ol><li>socket</li><li>bind</li><li>listen</li><li>accept  &lt;- block</li><li>receive</li></ol><p>不管是Java还是c, 在accept时都是阻塞等待操作系统返回新连接</p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><ol><li>socket</li><li>bind</li><li>listen</li><li>fcntl(O_NONBLOCK), accept  &lt;- unblock</li><li>receive</li></ol><p>手动设置fd(file_descriptor)的属性, 可以使用操作系统提供的非阻塞接口, 即无输入返回0, 有输入返回大于0, 如果需要处理数据, 需要循环检查返回值</p><p>接口立即返回, 程序可以执行下文, 所以是非阻塞</p><p>要等接口返回有效内容后才能执行期望的操作, 所以是同步的</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>上面两种模型, 都是一个线程对应一个连接</p><blockquote><p>在Java中创建线程，一个线程默认就会预留1M的空间，那么1G的内存也不过只能支持1000个线程创建而已。而且，随着线程数的增多，线程之间的调度和切换，引发的资源竞争也会加剧，使整个系统变得很慢</p></blockquote><p>IO多路复用, 支持一个线程管理多个连接, 所有连接均没有消息时, 对应的接口即阻塞</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol><li>socket</li><li>bind</li><li>listen</li><li>select &lt;- block</li><li>accept</li><li>receive</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123;</span><br><span class="line">    // 如果没有消息, 这里会阻塞</span><br><span class="line">    n = select(fd_set)</span><br><span class="line">    // 走到这里说明fd_set不为空, 有需要处理的连接, accept不会阻塞</span><br><span class="line">    accept()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ol><li>socket</li><li>bind</li><li>listen</li><li>poll &lt;- block</li><li>accept</li><li>receive</li></ol><p>和select基本相同, 只是fd_set从数组换成了链表, 支持的fd数超过1024</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><h4 id="对poll的优化"><a href="#对poll的优化" class="headerlink" title="对poll的优化"></a>对poll的优化</h4><ul><li>返回可读的fd, 不需要再遍历一遍哪些可读</li><li>接口拆分为 epoll_ctl 和 epoll_wait, 减少了用户空间到内核空间的拷贝</li></ul><p>只有较新的linux支持epoll</p><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><h5 id="Edge模式"><a href="#Edge模式" class="headerlink" title="Edge模式"></a>Edge模式</h5><p>空的接收缓冲区刚接收到数据时触发读事件; 满的缓冲区刚空出空间时触发读事件</p><h5 id="Level模式"><a href="#Level模式" class="headerlink" title="Level模式"></a>Level模式</h5><p>接收缓冲区不为空, 有数据可读, 则读事件一直触发; 发送缓冲区不满可以继续写入数据, 则写事件一直触发</p><h1 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h1><p>Java NIO的selector是对select&#x2F;poll&#x2F;epoll的封装</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>看讲Java IO的文章, 总是不理解为什么会有这么多模型, 既然有效率更高的, 直接用更好的不就行了吗?</p><p>所以说问题要看本质, Java IO能做什么, 取决于操作系统提供了什么接口</p><p>说到底还是大学课堂涉及的内容, 上课时不知道学了能干啥而知其然不知其所以然, 现在遇到了使用场景就得得好好补一补</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/24393775">进击的Java新人 - 知乎</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看完天安门纪录片的一点感受</title>
      <link href="/2019-04-21-%E7%9C%8B%E5%AE%8C%E5%A4%A9%E5%AE%89%E9%97%A8%E7%BA%AA%E5%BD%95%E7%89%87%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E5%8F%97.html"/>
      <url>/2019-04-21-%E7%9C%8B%E5%AE%8C%E5%A4%A9%E5%AE%89%E9%97%A8%E7%BA%AA%E5%BD%95%E7%89%87%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E5%8F%97.html</url>
      
        <content type="html"><![CDATA[<h1 id="最大感受"><a href="#最大感受" class="headerlink" title="最大感受"></a>最大感受</h1><p>对人类来说, 是一场残酷又真实的大型社会学实验</p><p>邓小平真的是”实干家”, 心狠手辣, 学运带来的阻力比起赵家内部的阻力恐怕还是小很多</p><p>我的观点和片子里的吴国光(前政府官员)梁晓燕(教师)差不多</p><p>但是假如我处于那个环境肯定也会前赴后继地假如(然后在清理的前几天跑路?是真的怂)</p><h1 id="负面情绪"><a href="#负面情绪" class="headerlink" title="负面情绪"></a>负面情绪</h1><h2 id="修宪"><a href="#修宪" class="headerlink" title="修宪"></a>修宪</h2><table><thead><tr><th>时间</th><th>事件</th><th>中国官方舆论</th></tr></thead><tbody><tr><td>2017-5-3</td><td>安倍晋三宣布将在2020年修宪</td><td><a href="http://world.people.com.cn/n1/2017/0708/c1002-29391510.html">铭记历史，防止悲剧重演–国际–人民网</a></td></tr><tr><td>2018-3-9</td><td>第十三届全国人民代表大会《宪法修正案》通过</td><td><a href="http://lianghui.people.com.cn/2018npc/n1/2018/0317/c417507-29872934.html">让宪法之树常青–中国人大新闻–人民网</a></td></tr></tbody></table><h2 id="舆论"><a href="#舆论" class="headerlink" title="舆论"></a>舆论</h2><p>在1989年的中国, 对于掌握了舆论渠道的国家权力来说, 几万几十万个人的静坐&#x2F;绝食可以被轻易抹消掉</p><p>假如发生在现在, 2019年, 互联网普及的时代, 又会是什么样子?</p><h2 id="大学生"><a href="#大学生" class="headerlink" title="大学生"></a>大学生</h2><p>不要真的相信宪法上的话, 要看实际发生的事</p><p>学生真的把自己当成了国家的主人, 采取的行动就显得过于天真</p><p>你是人民还是人民的敌人, 不是你说了算(实际上你做的事对这个国家的发展有没有利还真不一定)</p><p>这件事也许是最后一根稻草, 让顶尖大学的学生们失去了改造国家的志向</p><p>精致利己被骂就被骂吧, 总比上街丢了命好</p><h2 id="政治改革"><a href="#政治改革" class="headerlink" title="政治改革"></a>政治改革</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>为什么(那个年代)说”中国人的概念里革命是正面的但改革不一定”</p><p>任何改革的阻力都是既得利益者, 经济改革初期工人利益受损, 但改革并不需要工人的支持, 先富带动后富, 有能力推动改革的都是有能力先富的人; 政治改革则相反, 有能力推动改革的往往是既得利益者, 例如能够一人修宪的人</p><p>邓&#x2F;江&#x2F;胡重心在经济改革, 政治改革的优先级在之下; 到了维尼, 高度集权的政府似乎对其很反感</p><h3 id="改革"><a href="#改革" class="headerlink" title="改革?"></a>改革?</h3><p>所谓的政治改革, 改成什么样子才最好呢?</p><p>我不想要一个乌合之众的政体, 更不想要一个最高权力者随意修宪的政体——存在吗?</p><h1 id="正面想法"><a href="#正面想法" class="headerlink" title="正面想法"></a>正面想法</h1><p>权力会使人变质</p><p>任何时候都要知道自己在做什么, 自己的目的是什么, 别人期望你做什么, 他的逻辑是否严密</p><p>多换位思考, 如果你是对方, 你需要什么, 你可以提供什么</p><p>想要对政治事件有比较客观的认识, 还是要多综合各方面的观点, 再加上自己的三观(和自己的屁股)(不知道我查的相关资料够不够全面, 但应该不会和事实偏差太多)</p><h1 id="null"><a href="#null" class="headerlink" title="null"></a>null</h1><p>当年的柴玲有点黑版桂纶镁的意思(可惜后来变成坦克了)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《淘宝技术这十年》读书笔记</title>
      <link href="/2019-04-13-%E3%80%8A%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
      <url>/2019-04-13-%E3%80%8A%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="技术演变"><a href="#技术演变" class="headerlink" title="技术演变"></a>技术演变</h1><h2 id="个人网站-2003-x2F-05-2003-x2F-12"><a href="#个人网站-2003-x2F-05-2003-x2F-12" class="headerlink" title="个人网站 2003&#x2F;05-2003&#x2F;12"></a>个人网站 2003&#x2F;05-2003&#x2F;12</h2><h3 id="LAMP"><a href="#LAMP" class="headerlink" title="LAMP"></a>LAMP</h3><p>linux + apache + mysql + php</p><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p>读写分离, 备份</p><h2 id="个人网站的升级-2004-x2F-01-2004-x2F-05"><a href="#个人网站的升级-2004-x2F-01-2004-x2F-05" class="headerlink" title="个人网站的升级 2004&#x2F;01-2004&#x2F;05"></a>个人网站的升级 2004&#x2F;01-2004&#x2F;05</h2><h3 id="mysql-gt-Oracle"><a href="#mysql-gt-Oracle" class="headerlink" title="mysql-&gt;Oracle"></a>mysql-&gt;Oracle</h3><p>myISAM write的时候要lock整个表</p><h2 id="企业级Java网站-2004-x2F-06-2006-x2F-12"><a href="#企业级Java网站-2004-x2F-06-2006-x2F-12" class="headerlink" title="企业级Java网站 2004&#x2F;06-2006&#x2F;12"></a>企业级Java网站 2004&#x2F;06-2006&#x2F;12</h2><h3 id="php-gt-Java"><a href="#php-gt-Java" class="headerlink" title="php-&gt;Java"></a>php-&gt;Java</h3><p>php的sql relay会死锁</p><p>分模块同步开发, 开发完后分模块替换</p><h3 id="Java-MVC框架"><a href="#Java-MVC框架" class="headerlink" title="Java MVC框架"></a>Java MVC框架</h3><p>struts1.x-&gt;WebX</p><h3 id="iSearch"><a href="#iSearch" class="headerlink" title="iSearch"></a>iSearch</h3><h3 id="分库-1"><a href="#分库-1" class="headerlink" title="分库"></a>分库</h3><p>DBRoute</p><h3 id="缓存TBStore"><a href="#缓存TBStore" class="headerlink" title="缓存TBStore"></a>缓存TBStore</h3><p>Berkeley DB</p><p>key-&gt;hashed key-&gt;mod-&gt;server</p><p>缓存变动较少的信息</p><p>更新数据库的时候要同步更新缓存</p><h3 id="大字段存储位置"><a href="#大字段存储位置" class="headerlink" title="大字段存储位置"></a>大字段存储位置</h3><p>db -&gt; cache -&gt; fs</p><h3 id="CDN网络"><a href="#CDN网络" class="headerlink" title="CDN网络"></a>CDN网络</h3><h2 id="创造技术-2007-x2F-01-2007-x2F-12"><a href="#创造技术-2007-x2F-01-2007-x2F-12" class="headerlink" title="创造技术 2007&#x2F;01-2007&#x2F;12"></a>创造技术 2007&#x2F;01-2007&#x2F;12</h2><h3 id="文件系统TFS"><a href="#文件系统TFS" class="headerlink" title="文件系统TFS"></a>文件系统TFS</h3><p>针对小文件</p><p>图片处理在nginx上进行</p><p>图片读取多级缓存</p><h3 id="缓存Tair"><a href="#缓存Tair" class="headerlink" title="缓存Tair"></a>缓存Tair</h3><p>TBStore, TDBM</p><p>分布式, config server, data server</p><h3 id="iSearch-1"><a href="#iSearch-1" class="headerlink" title="iSearch"></a>iSearch</h3><p>多份相同数据, 单行-&gt;矩阵</p><h2 id="分布式电子商务操作系统-2008-x2F-01-2012-x2F-12"><a href="#分布式电子商务操作系统-2008-x2F-01-2012-x2F-12" class="headerlink" title="分布式电子商务操作系统 2008&#x2F;01-2012&#x2F;12"></a>分布式电子商务操作系统 2008&#x2F;01-2012&#x2F;12</h2><h3 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h3><p>标签服务&#x2F;属性服务&#x2F;用户信息服务&#x2F;交易服务 -&gt; 模块化</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="服务注册-HSF"><a href="#服务注册-HSF" class="headerlink" title="服务注册 HSF"></a>服务注册 HSF</h4><p>RPC(TCP&#x2F;IP)</p><p>OSGI</p><h4 id="消息-notify"><a href="#消息-notify" class="headerlink" title="消息 notify"></a>消息 notify</h4><p>异步</p><p>服务注册等</p><h4 id="分布式数据访问-TDDL"><a href="#分布式数据访问-TDDL" class="headerlink" title="分布式数据访问 TDDL"></a>分布式数据访问 TDDL</h4><p>分布式存储</p><p>访问路由</p><p>多向非对称复制</p><p>存储扩展</p><p>CommonDAO -&gt; TDDL -&gt; 愚公数据迁移, 精卫数据复制 </p><h3 id="session框架"><a href="#session框架" class="headerlink" title="session框架"></a>session框架</h3><h3 id="开放平台"><a href="#开放平台" class="headerlink" title="开放平台"></a>开放平台</h3><p>memcached</p><p>hadoop</p><h1 id="大牛的话"><a href="#大牛的话" class="headerlink" title="大牛的话"></a>大牛的话</h1><h2 id="正明"><a href="#正明" class="headerlink" title="正明"></a>正明</h2><p>找到自己感兴趣的, 花时间投进去, 通过实践后的知识积累比只看书本有用得多. 我看过一本操作系统方面的英文书, 其中引用了一段中国人的格言:”I hear and I forget. I see and I remember. I do and I understand.” 荀子说”不闻不若闻之, 闻之不若见之, 见之不若知之, 知之不若行之.”</p><h2 id="正祥"><a href="#正祥" class="headerlink" title="正祥"></a>正祥</h2><p>一个人如果把做成事作为目标, 该他得到的东西一定会顺理成章得到. 但是如果把上升作为主要目标, 做同样的事, 结果就会完全不一样. 你的心态会最终决定你的成就.</p><h2 id="毕玄"><a href="#毕玄" class="headerlink" title="毕玄"></a>毕玄</h2><p>现在如果没有什么特殊情况的话, 我会花很多时间看技术方面的文章或者图书, 写代码的时间可能每天只有两三个小时. 每隔一段时间回去想一想将来干什么比较好, 因为写代码时间会过的很快, 要经常跳出来想一想.</p><p>至于晋升, 重要的是在这个过程中你回顾了你一年做了什么事情, 对公司有什么贡献, 技术上有哪些成长. 我们要看技术方面的专业性, 然后看你的技术对公司的业务发展有多少贡献. 还有一点, 我比较看中的是, 也许你不在其位, 但能够跳出自己的范围, 想到公司未来会面临什么问题, 怎么解决, 如果能落实就最好了, 不管你落实的技术含量有多高, 关键是你解决了什么样的问题. 如果你能做到这些, 你这个人对公司就非常重要.</p><p>在校招的时候, 我比较欣赏的学生往往是那些”不务正业”类型的. 我经常会问他们, 你有没有利用业余时间处于自己的技术兴趣做的一些小东西. 这样的学生我们通常会比较感兴趣, 我认为这样的学生是真正喜欢技术. 聪明程度一般就可以的, 他能够进入这些不错的学校, 智商是不会有什么问题的.</p><h2 id="放翁"><a href="#放翁" class="headerlink" title="放翁"></a>放翁</h2><p>第一个是做事要自己思考后再去问别人, 而不是一遇到问题就找人求助. 第二个是不断地打破自己的一些想法, 你不要担心自己今天已经做了50%的工作, 要是推导重来, 前面的事情都白干了. 我现在带的两个新人成长很快, 但是都有类似的经历, 就是一个东西被我反复推翻重做, 在这个过程中就是不断地成长, 要思考我为什么让你推倒重做, 若想不清楚, 下次重做的概率会更大, 这样慢慢地就学会了思考.</p><h2 id="吴翰清"><a href="#吴翰清" class="headerlink" title="吴翰清"></a>吴翰清</h2><p>从基本功做起, 研究常见的漏洞, 把它查出来, 并去分析它, 不要用它来做坏事. 另外, 去看看公开的漏洞, 研究一下漏洞的利用技巧.</p><h2 id="云铮"><a href="#云铮" class="headerlink" title="云铮"></a>云铮</h2><p>兴趣是最好的老师, 坚持是达到梦想的唯一途径, 当然, 在个人发展的不同阶段寻找到合适的导师很重要, 看准方向会事半功倍. 在刚刚参加工作还没有形成自己的判断时, 方向有两个来源, 一个是个人的兴趣, 一个是找一个你非常佩服且能掌握未来方向的人. 当然, 如果这两者正好重合, 那么剩下的就是脚踏实地坚持.</p><h2 id="多隆"><a href="#多隆" class="headerlink" title="多隆"></a>多隆</h2><p>发现问题, 解决问题, 不要绕开问题的本身; 多做事情, 不会吃亏, 即使不是你的事情.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于freeswitch的unimrcp的demo</title>
      <link href="/2019-03-23-%E5%9F%BA%E4%BA%8Efreeswitch%E7%9A%84unimrcp%E7%9A%84demo.html"/>
      <url>/2019-03-23-%E5%9F%BA%E4%BA%8Efreeswitch%E7%9A%84unimrcp%E7%9A%84demo.html</url>
      
        <content type="html"><![CDATA[<h1 id="unimrcp"><a href="#unimrcp" class="headerlink" title="unimrcp"></a>unimrcp</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><a href="http://www.unimrcp.org/">unimrcp</a> 是一个开源的mrcp实现库</p><p>将业务代码以 <a href="http://www.unimrcp.org/manuals/html/PluginImplementationManual.html">plugin</a> 的形式插入到unimrcp中执行, 完成后编译, 运行&#x2F;usr&#x2F;bin&#x2F;unimrcp&#x2F;下的脚本即可启动mrcp服务器</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件 <code>/usr/bin/unimrcp/conf/unimrcpserver.xml</code></p><p>实现mrcpv2需要的基本配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">unimrcpserver</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;unimrcpserver.xsd&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ip</span>&gt;</span>172.19.**.171<span class="tag">&lt;/<span class="name">ip</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">components</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource-factory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span> <span class="attr">id</span>=<span class="string">&quot;speechsynth&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span> <span class="attr">id</span>=<span class="string">&quot;speechrecog&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span> <span class="attr">id</span>=<span class="string">&quot;recorder&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span> <span class="attr">id</span>=<span class="string">&quot;speakverify&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sip-uas</span> <span class="attr">id</span>=<span class="string">&quot;SIP-Agent-1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;SofiaSIP&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sip-port</span>&gt;</span>8060<span class="tag">&lt;/<span class="name">sip-port</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sip-transport</span>&gt;</span>udp,tcp<span class="tag">&lt;/<span class="name">sip-transport</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ua-name</span>&gt;</span>UniMRCP SofiaSIP<span class="tag">&lt;/<span class="name">ua-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sdp-origin</span>&gt;</span>UniMRCPServer<span class="tag">&lt;/<span class="name">sdp-origin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sip-session-expires</span>&gt;</span>600<span class="tag">&lt;/<span class="name">sip-session-expires</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sip-min-session-expires</span>&gt;</span>120<span class="tag">&lt;/<span class="name">sip-min-session-expires</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sip-uas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mrcpv2-uas</span> <span class="attr">id</span>=<span class="string">&quot;MRCPv2-Agent-1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mrcp-port</span>&gt;</span>1544<span class="tag">&lt;/<span class="name">mrcp-port</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">max-connection-count</span>&gt;</span>100<span class="tag">&lt;/<span class="name">max-connection-count</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">max-shared-use-count</span>&gt;</span>100<span class="tag">&lt;/<span class="name">max-shared-use-count</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">force-new-connection</span>&gt;</span>false<span class="tag">&lt;/<span class="name">force-new-connection</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rx-buffer-size</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">rx-buffer-size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tx-buffer-size</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">tx-buffer-size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inactivity-timeout</span>&gt;</span>600<span class="tag">&lt;/<span class="name">inactivity-timeout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">termination-timeout</span>&gt;</span>3<span class="tag">&lt;/<span class="name">termination-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mrcpv2-uas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">media-engine</span> <span class="attr">id</span>=<span class="string">&quot;Media-Engine-1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">realtime-rate</span>&gt;</span>1<span class="tag">&lt;/<span class="name">realtime-rate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">media-engine</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rtp-factory</span> <span class="attr">id</span>=<span class="string">&quot;RTP-Factory-1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rtp-port-min</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">rtp-port-min</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rtp-port-max</span>&gt;</span>6000<span class="tag">&lt;/<span class="name">rtp-port-max</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rtp-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin-factory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">engine</span> <span class="attr">id</span>=<span class="string">&quot;Demo-Synth-1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;demosynth&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">engine</span> <span class="attr">id</span>=<span class="string">&quot;my-Synth-1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my-synth&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">engine</span> <span class="attr">id</span>=<span class="string">&quot;Demo-Recog-1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;demorecog&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">engine</span> <span class="attr">id</span>=<span class="string">&quot;my-Recog-1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my-recog&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">engine</span> <span class="attr">id</span>=<span class="string">&quot;Demo-Verifier-1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;demoverifier&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">engine</span> <span class="attr">id</span>=<span class="string">&quot;Recorder-1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mrcprecorder&quot;</span> <span class="attr">enable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin-factory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">components</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rtp-settings</span> <span class="attr">id</span>=<span class="string">&quot;RTP-Settings-1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jitter-buffer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">adaptive</span>&gt;</span>1<span class="tag">&lt;/<span class="name">adaptive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">playout-delay</span>&gt;</span>50<span class="tag">&lt;/<span class="name">playout-delay</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">max-playout-delay</span>&gt;</span>600<span class="tag">&lt;/<span class="name">max-playout-delay</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">time-skew-detection</span>&gt;</span>1<span class="tag">&lt;/<span class="name">time-skew-detection</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">jitter-buffer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ptime</span>&gt;</span>20<span class="tag">&lt;/<span class="name">ptime</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">codecs</span> <span class="attr">own-preference</span>=<span class="string">&quot;false&quot;</span>&gt;</span>PCMU PCMA L16/96/8000 telephone-event/101/8000<span class="tag">&lt;/<span class="name">codecs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rtcp</span> <span class="attr">enable</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rtcp-bye</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rtcp-bye</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx-interval</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">tx-interval</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rx-resolution</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">rx-resolution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">rtcp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rtp-settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mrcpv2-profile</span> <span class="attr">id</span>=<span class="string">&quot;uni2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sip-uas</span>&gt;</span>SIP-Agent-1<span class="tag">&lt;/<span class="name">sip-uas</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mrcpv2-uas</span>&gt;</span>MRCPv2-Agent-1<span class="tag">&lt;/<span class="name">mrcpv2-uas</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">media-engine</span>&gt;</span>Media-Engine-1<span class="tag">&lt;/<span class="name">media-engine</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rtp-factory</span>&gt;</span>RTP-Factory-1<span class="tag">&lt;/<span class="name">rtp-factory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rtp-settings</span>&gt;</span>RTP-Settings-1<span class="tag">&lt;/<span class="name">rtp-settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mrcpv2-profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">unimrcpserver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到, 最后的profile分别指定了各参数使用的子配置; 基本上, 默认的配置修改了ip即可正常运行</p><p>注意: </p><ol><li><code>plugin-factory</code> 中添加自己的plugin, 禁用默认的相同功能的plugin</li><li>区分各端口的作用, 默认的8060是sip通信的端口, 1544是mrcp通信的端口, 5000-6000是rtp通信的端口; 另外默认1554为rtsp的端口, 是mrcpv1使用的</li></ol><h1 id="freeswitch"><a href="#freeswitch" class="headerlink" title="freeswitch"></a>freeswitch</h1><h2 id="安装unimrcp模块"><a href="#安装unimrcp模块" class="headerlink" title="安装unimrcp模块"></a>安装unimrcp模块</h2><p>源码路径&#x2F;modules.xml取消mod_unimrcp的注释</p><p>make mod_unimrcp-install</p><p>设置fs启动时自动加载该模块: 取消&#x2F;usr&#x2F;local&#x2F;freeswitch&#x2F;conf&#x2F;autoload_configs&#x2F;modules.conf.xml中mod_unimrcp的注释</p><h2 id="配置一份mrcp"><a href="#配置一份mrcp" class="headerlink" title="配置一份mrcp"></a>配置一份mrcp</h2><p>运行路径&#x2F;conf&#x2F;mrcp_profiles&#x2F;下新增unimrcpserver-mrcp-v2.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span> <span class="attr">name</span>=<span class="string">&quot;unimrcpserver-mrcp2&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MRCP 服务器地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;server-ip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MRCP SIP 端口号 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;server-port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;8060&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;resource-location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- FreeSWITCH IP, 端口以及 SIP 传输方式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;client-ip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;172.19.**.171&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;client-port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5069&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sip-transport&quot;</span> <span class="attr">value</span>=<span class="string">&quot;udp&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;speechsynth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;speechsynthesizer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;speechrecog&quot;</span> <span class="attr">value</span>=<span class="string">&quot;speechrecognizer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;rtp-ip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;172.19.46.171&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;rtp-port-min&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;rtp-port-max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;codecs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PCMU PCMA L16/96/8000&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- Add any default MRCP params for SPEAK requests here --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">synthparams</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">synthparams</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- Add any default MRCP params for RECOGNIZE requests here --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">recogparams</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--param name=&quot;start-input-timers&quot; value=&quot;false&quot;/--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">recogparams</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意: </p><ol><li>mrcp服务器的端口是提供sip通信的端口</li><li>指定的fs的端口是专门用来和mrcp服务器交换的, 和fs自己的internal&#x2F;external端口都不能相同</li></ol><h2 id="指定默认使用该mrcp配置"><a href="#指定默认使用该mrcp配置" class="headerlink" title="指定默认使用该mrcp配置"></a>指定默认使用该mrcp配置</h2><p>运行路径&#x2F;conf&#x2F;autoload_configs&#x2F;unimrcp.conf.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">name</span>=<span class="string">&quot;unimrcp.conf&quot;</span> <span class="attr">description</span>=<span class="string">&quot;UniMRCP Client&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;default-tts-profile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;unimrcpserver-mrcp2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;default-asr-profile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;unimrcpserver-mrcp2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;log-level&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;enable-profile-events&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max-connection-count&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;offer-new-connection&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;request-timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">X-PRE-PROCESS</span> <span class="attr">cmd</span>=<span class="string">&quot;include&quot;</span> <span class="attr">data</span>=<span class="string">&quot;../mrcp_profiles/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="写语法文件和脚本"><a href="#写语法文件和脚本" class="headerlink" title="写语法文件和脚本"></a>写语法文件和脚本</h2><p>略</p><p>总之, 要分清fs服务器和mrcp服务器, 清楚每个端口的区别</p><hr><p>参考资料</p><ol><li><a href="https://cotin.tech/AI/FreeswitchSetting/">构建简单的智能客服系统（一）——FreeSWITCH 搭建与配置 | Cotin’s Homepage</a></li><li><a href="https://cotin.tech/AI/UniMRCPASR/">构建简单的智能客服系统（二）——基于 UniMRCP 实现讯飞 ASR MRCP Server | Cotin’s Homepage</a></li><li><a href="https://cotin.tech/AI/UniMRCPTTS/">构建简单的智能客服系统（三）——基于 UniMRCP 实现讯飞 TTS MRCP Server | Cotin’s Homepage</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> freeswitch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的init整理</title>
      <link href="/2019-03-18-Linux%E7%9A%84init%E6%95%B4%E7%90%86.html"/>
      <url>/2019-03-18-Linux%E7%9A%84init%E6%95%B4%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux 操作系统的启动首先从 BIOS 开始, 接下来进入 boot loader, 由 bootloader 载入内核, 进行内核初始化</p><p>内核初始化的最后一步就是启动 pid 为 1 的 <a href="https://zh.wikipedia.org/wiki/Init">init</a> 进程. 这个进程是系统的第一个进程,  负责产生其他所有用户进程。</p><h1 id="Sysvinit"><a href="#Sysvinit" class="headerlink" title="Sysvinit"></a>Sysvinit</h1><p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html">浅析 Linux 初始化 init 系统，第 1 部分: sysvinit</a></p><h1 id="UpStart"><a href="#UpStart" class="headerlink" title="UpStart"></a>UpStart</h1><p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html">浅析 Linux 初始化 init 系统，第 2 部分: UpStart</a></p><h1 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h1><p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html">浅析 Linux 初始化 init 系统，第 3 部分: Systemd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个JDK工具</title>
      <link href="/2019-03-18-%E5%87%A0%E4%B8%AAJDK%E5%B7%A5%E5%85%B7.html"/>
      <url>/2019-03-18-%E5%87%A0%E4%B8%AAJDK%E5%B7%A5%E5%85%B7.html</url>
      
        <content type="html"><![CDATA[<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p>列出所有正在运行的JVM</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>jps命令列出目标系统上已检测的Java HotSpot VM, 该命令仅限于报告具有访问权限的JVM的信息</p><p>如果在未指定hostid的情况下运行jps命令, 则它将在本地主机上搜索已检测的JVM; 如果以hostid启动，则它使用指定的协议和端口在指定的主机上搜索JVM</p><p>jps命令报告在目标系统上找到的每个已检测JVM的本地JVM标识符或lvmid.  lvmid通常(但不一定)是JVM进程的操作系统进程标识符. 如果没有选项, jps会列出每个Java应用程序的lvmid, 后跟应用程序的类名或jar文件名的简短形式. 类名或JAR文件名的缩写形式省略了类的包信息或JAR文件路径信息</p><p>jps命令使用Java启动程序查找传递给main方法的类名和参数. 如果使用自定义启动程序启动目标JVM, 则类或JAR文件名和main方法的参数不可用. 在这种情况下, jps命令输出类名称或JAR文件名的字符串Unknown以及main方法的参数</p><p>jps命令生成的JVM列表可以由授予运行该命令的主体的权限限制. 该命令仅列出原则具有访问权限的JVM, 具体取决于操作系统特定的访问控制机制</p><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><p><code>-q</code> 只显示pid</p><p><code>-m</code> 显示传递给 main() 的参数</p><p><code>-l</code> 显示应用程序主类的完整包名或应用程序的JAR文件的完整路径名</p><p><code>-v</code> 显示传递给JVM的参数</p><h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>查看&#x2F;修改JVM参数信息</p><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><p>jinfo命令打印指定Java进程或核心文件或远程调试服务器的Java配置信息,  包括Java系统属性和JVM命令行标志 </p><p>如果指定的进程在64位JVM上运行, 可能需要指定-J-d64选项: jinfo-J-d64 -sysprops pid</p><p>该指令JDK以后可能不再支持</p><h2 id="options-1"><a href="#options-1" class="headerlink" title="options"></a>options</h2><p><code>no-option</code> 显示命令行和系统属性键值对</p><p><code>-flag name</code> 显示指定命令行键值对</p><p><code>-flag [+|-]name</code> 启用或禁用指定命令行属性</p><p><code>-flag name=value</code> 设置指定命令行属性值</p><p><code>-flags</code> 显示传递给JVM的命令行属性</p><p><code>-sysprops</code> 显示系统属性键值对</p><h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>监控JVM运行状态</p><h2 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h2><p>显示JVM性能统计信息, 目标JVM由vmid指定</p><h2 id="options-2"><a href="#options-2" class="headerlink" title="options"></a>options</h2><p><code>-options</code> 查看可用选项</p><p><code>-class</code> 类装载器统计</p><p><code>-compiler</code> jit编译器统计</p><p><code>-gc</code> 垃圾收集堆信息</p><p><code>-gccapacity</code> 内存池生成和空间容量</p><p><code>-gccause</code> <code>-gcutil</code>的内容+最后一次gc的原因</p><p><code>-gcnew</code> 新生代统计</p><p><code>-gcnewcapacity</code> 新生代空间大小统计</p><p><code>-gcold</code> 年老代和元空间行为统计</p><p><code>-gcoldcapacity</code> 年老代空间大小统计</p><p><code>-gcmetacapacity</code> 元空间大小统计</p><p><code>-gcutil</code> 垃圾回收统计概要</p><p><code>-printcompilation</code> JVM编译器方法统计</p><h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>打印JVM堆内存信息</p><h2 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h2><p>打印JVM堆内存信息, 如果指定的进程在64位JVM上运行, 可能需要指定-J-d64选项: jmap-J-d64 -heap pid</p><p>该指令JDK以后可能不再支持</p><h2 id="options-3"><a href="#options-3" class="headerlink" title="options"></a>options</h2><p><code>no option</code> 显示共享对象映射</p><p><code>-dump: format=b, file=filename</code> 将Java堆另存为hprof二进制格式, 可以使用jhat命令读取生成的文件</p><p><code>-heap</code> 打印使用的垃圾收集, 头部配置和生成方式堆使用的堆摘要</p><p><code>-histo</code> 打印堆的直方图, 对于每个Java类, 将打印对象数, 内存大小(以字节为单位)和完全限定的类名</p><p><code>-clstats</code> 打印class loader统计信息</p><h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>打印java线程堆栈</p><h2 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h2><p>jstack命令打印指定Java进程, 核心文件或远程调试服务器的Java线程的Java堆栈跟踪</p><p>对于每个Java帧, 将打印完整的类名, 方法名, 字节代码索引(BCI)和行号(如果可用)</p><p>如果指定的进程在64位JVM上运行, 可能需要指定-J-d64选项: jstack -J-d64 -m pid</p><h2 id="options-4"><a href="#options-4" class="headerlink" title="options"></a>options</h2><p><code>-l</code> 长列表, 打印锁的额外信息</p><p><code>-m</code> 打印java和native c&#x2F;c++框架的所有栈信息</p><h1 id="排查实战"><a href="#排查实战" class="headerlink" title="排查实战"></a>排查实战</h1><h2 id="频繁GC问题或内存溢出问题"><a href="#频繁GC问题或内存溢出问题" class="headerlink" title="频繁GC问题或内存溢出问题"></a>频繁GC问题或内存溢出问题</h2><ol><li>使用<code>jps</code>查看线程ID</li><li>使用<code>jstat -gc 25252 250 20</code>查看gc情况, 一般比较关注PERM区的情况, 查看GC的增长情况</li><li>使用<code>jstat -gccause</code>输出上次GC原因</li><li>使用<code>jmap -dump:format=b,file=heapDump 25252</code>生成堆转储文件</li><li>使用jhat或者可视化工具(Eclipse Memory Analyzer, IBM HeapAnalyzer)分析堆情况</li><li>结合代码解决内存溢出或泄露问题</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol><li>使用<code>jps</code>查看线程ID</li><li>使用<code>jstack 3331</code>查看线程情况</li></ol><hr><p>参考 <a href="https://www.hollischuang.com/archives/1561">Java开发必须掌握的线上问题排查命令-HollisChuang’s Blog</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logback的AsyncAppender产生的线程问题</title>
      <link href="/2019-03-18-logback%E7%9A%84AsyncAppender%E4%BA%A7%E7%94%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98.html"/>
      <url>/2019-03-18-logback%E7%9A%84AsyncAppender%E4%BA%A7%E7%94%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>项目里使用 logback+log4j 作为日志框架, 之前写了个mybatis插件处理日志, <a href="https://hahahaha123567.github.io/2019/03/18/2019-03-18-mybatis%E6%97%A5%E5%BF%97%E9%97%AE%E5%8F%B7%E6%9B%BF%E6%8D%A2/">mybatis日志问号替换</a></p><p>输出自定义日志后, 需要把框架默认的日志过滤掉, 原 <code>logback.xml</code> 如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;rollingFileAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;com.yiwise.core.log.MybatisFilter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;asyncRollingFileAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>512<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;rollingFileAppender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;com.yiwise.core.log.MybatisFilter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有console, rollingFileAppender, asyncRollingFileAppender三个appender, 最后生效的分别是console和日志文件asyncRollingFileAppender三个appender</p><p>在mybatis插件中, 因为担心字段映射出错抛异常的时候, 不显示自定义sql, 此时框架默认sql也被我过滤导致看不到sql情况, 所以在异常的try-catch中使用MDC控制MybatisFilter这个过滤器的开关(即出现异常时关闭这个filter显示框架默认日志)</p><p>但在测试时, ide里运行, console中日志被正常过滤, 但生成的日志文件里过滤却失败, 明明filter配置相同结果却不同, 花了很久才找到原因</p><h1 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h1><p>AsyncAppender有个线程类Worker, 它是一个简单的线程类, 是AsyncAppender的后台线程, 所要做的工作是: 从buffer中取出event交给对应的appender进行后面的日志推送</p><p>AsyncAppender并不处理日志, 只是将日志缓冲到一个BlockingQueue里面去, 并在内部创建一个工作线程从队列头部获取日志, 之后将获取的日志循环记录到附加的其他appender上去, 从而达到不阻塞主线程的效果。因此AsynAppender仅仅充当事件转发器, 必须引用另一个appender来工作</p><p>在业务流程中使用了logback MDC(Mapped Diagnostic Context), 即将一些运行时的上下文数据通过logback打印出来</p><p>MDC内部<a href="https://blog.csdn.net/a837199685/article/details/52712547">使用InheritableThreadLocal</a>实现, 默认实现从父线程到子线程的内容浅拷贝, 但filter是运行在asyncRollingFileAppender的线程中, 读不到业务在主线程中放到MDC的内容</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>filter中不再直接使用MDC, 而是用传进来的event去获取日志所记录的线程的MDC <code>getMDCPropertyMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> FilterReply <span class="title function_">decide</span><span class="params">(ILoggingEvent event)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; mdcPropertyMap = event.getMDCPropertyMap();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis日志问号替换</title>
      <link href="/2019-03-18-mybatis%E6%97%A5%E5%BF%97%E9%97%AE%E5%8F%B7%E6%9B%BF%E6%8D%A2.html"/>
      <url>/2019-03-18-mybatis%E6%97%A5%E5%BF%97%E9%97%AE%E5%8F%B7%E6%9B%BF%E6%8D%A2.html</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>项目里使用 logback+log4j 作为日志框架, mybatis 支持 log4j 作为日志框架, 默认即输出日志如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select * from idol where name = ?</span><br><span class="line">==&gt; Parameters: nico(String)</span><br><span class="line">&lt;==      Total: 1 </span><br></pre></td></tr></table></figure><p>每次验证sql都要手动替换问号很麻烦, 就写个插件直接打印实际执行的完整sql</p><h1 id="打印日志时机"><a href="#打印日志时机" class="headerlink" title="打印日志时机"></a>打印日志时机</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.ibatis.executor;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title class_">BaseExecutor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">            <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">            <span class="comment">// 打sql模板日志</span></span><br><span class="line">            stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">            <span class="comment">// 打实际参数</span></span><br><span class="line">            <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeStatement(stmt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.logging.jdbc;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConnectionLogger</span> <span class="keyword">extends</span> <span class="title class_">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> &#123;</span><br><span class="line">        <span class="comment">// log sql template</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.logging.jdbc;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title class_">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> &#123;</span><br><span class="line">        <span class="comment">// log paramaters</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.logging.jdbc;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ResultSetLogger</span> <span class="keyword">extends</span> <span class="title class_">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> &#123;</span><br><span class="line">        <span class="comment">// log total</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到的Logger: MapperRegistry &lt;-&gt; Configuration -&gt; MappedStatement -&gt; Log</p><p>org.apache.ibatis.executor.Executor: update(), query()<br>增&#x2F;删&#x2F;改查</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>本来想通过侵入打日志代码的方式实现, 后来发现mybatis提供了<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">插件</a>功能, 可以<a href="https://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html">自定义sql执行流程</a></p><p>最终实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hahahaha123567@qq.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 注解拦截接口可选方法</span></span><br><span class="line"><span class="comment"> * Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</span></span><br><span class="line"><span class="comment"> * ParameterHandler (getParameterObject, setParameters)</span></span><br><span class="line"><span class="comment"> * ResultSetHandler (handleResultSets, handleOutputParameters)</span></span><br><span class="line"><span class="comment"> * StatementHandler (prepare, parameterize, batch, update, query)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019/01/03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(</span></span><br><span class="line"><span class="meta">                type = Executor.class,</span></span><br><span class="line"><span class="meta">                method = &quot;update&quot;,</span></span><br><span class="line"><span class="meta">                args = &#123;MappedStatement.class, Object.class&#125;),</span></span><br><span class="line"><span class="meta">        @Signature(</span></span><br><span class="line"><span class="meta">                type = Executor.class,</span></span><br><span class="line"><span class="meta">                method = &quot;query&quot;,</span></span><br><span class="line"><span class="meta">                args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MybatisInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getParameterValue</span><span class="params">(Object param)</span> &#123;</span><br><span class="line">        String value;</span><br><span class="line">        <span class="keyword">if</span> (param == <span class="literal">null</span>) &#123;</span><br><span class="line">            value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = param.toString();</span><br><span class="line">            <span class="keyword">if</span> (param <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                value = <span class="string">&quot;&#x27;&quot;</span> + value + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param <span class="keyword">instanceof</span> CodeDescEnum) &#123;</span><br><span class="line">                value = ((CodeDescEnum) param).getCode().toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Matcher.quoteReplacement(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">showSql</span><span class="params">(Configuration configuration, BoundSql boundSql)</span> &#123;</span><br><span class="line">        <span class="comment">// 去掉空白字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql().replaceAll(<span class="string">&quot;[\\s]+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">parameterObject</span> <span class="operator">=</span> boundSql.getParameterObject();</span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(sql) &amp;&amp; Objects.nonNull(parameterObject) &amp;&amp; !CollectionUtils.isEmpty(parameterMappings)) &#123;</span><br><span class="line">            <span class="comment">// 替换参数</span></span><br><span class="line">            <span class="type">TypeHandlerRegistry</span> <span class="variable">typeHandlerRegistry</span> <span class="operator">=</span> configuration.getTypeHandlerRegistry();</span><br><span class="line">            <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                <span class="comment">// 有对应的typeHandler</span></span><br><span class="line">                sql = sql.replaceFirst(<span class="string">&quot;\\?&quot;</span>, getParameterValue(parameterObject));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有对应的typeHandler</span></span><br><span class="line">                <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> configuration.newMetaObject(parameterObject);</span><br><span class="line">                <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> parameterMapping.getProperty();</span><br><span class="line">                    <span class="keyword">if</span> (metaObject.hasGetter(propertyName)) &#123;</span><br><span class="line">                        <span class="comment">// 从metaObject里取值</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> metaObject.getValue(propertyName);</span><br><span class="line">                        sql = sql.replaceFirst(<span class="string">&quot;\\?&quot;</span>, getParameterValue(obj));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                        <span class="comment">// 从boundSql里取值</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                        sql = sql.replaceFirst(<span class="string">&quot;\\?&quot;</span>, getParameterValue(obj));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sql;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        MybatisInterceptor.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        MybatisFilter.enable();</span><br><span class="line">        <span class="type">MappedStatement</span> <span class="variable">mappedStatement</span> <span class="operator">=</span> (MappedStatement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sql参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">parameter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (invocation.getArgs().length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            parameter = invocation.getArgs()[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> mappedStatement.getBoundSql(parameter);</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> mappedStatement.getConfiguration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计sql执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">sqlException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnValue = invocation.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            MybatisFilter.disable();</span><br><span class="line">            sqlException = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> (end - start);</span><br><span class="line">        <span class="comment">// sql执行位置的logger</span></span><br><span class="line">        <span class="type">Log</span> <span class="variable">statementLog</span> <span class="operator">=</span> mappedStatement.getStatementLog();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (returnValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">                    <span class="comment">// executor.query()</span></span><br><span class="line">                    size = ((Collection) returnValue).size();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">                    <span class="comment">// executor.update()</span></span><br><span class="line">                    size = ((Number) returnValue).intValue();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;处理sql结果出错, returnValue类型为 &#123;&#125;&quot;</span>, returnValue.getClass().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> showSql(configuration, boundSql);</span><br><span class="line">            statementLog.debug(String.format(<span class="string">&quot;sql执行耗时: %dms, 结果数: %d, %s&quot;</span>, time, size, sql));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            MybatisFilter.disable();</span><br><span class="line">            statementLog.error(String.format(<span class="string">&quot;[LogHub]mybatis拦截器格式化sql出错, 调用位置%s, sql模板: %s&quot;</span>, mappedStatement.getId(), boundSql.getSql()), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sqlException != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> sqlException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把插件注册到mybatis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource, PageHelper pageHelper, MybatisInterceptor mybatisInterceptor)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;==== sqlSessionFactory execute ====&quot;</span>);</span><br><span class="line"></span><br><span class="line">    VFS.addImplClass(SpringBootVFS.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加插件</span></span><br><span class="line">    Interceptor[] plugins = <span class="keyword">new</span> <span class="title class_">Interceptor</span>[]&#123;pageHelper, mybatisInterceptor&#125;;</span><br><span class="line">    bean.setPlugins(plugins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据源</span></span><br><span class="line">    bean.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">// 注册 *Mapper.xml 配置文件</span></span><br><span class="line">    <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">    bean.setMapperLocations(resolver.getResources(<span class="string">&quot;classpath*:/mapper/**/*Mapper.xml&quot;</span>));</span><br><span class="line">    bean.setTypeHandlersPackage(<span class="string">&quot;com.haha.model.enums&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> bean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装机记录</title>
      <link href="/2019-03-15-%E8%A3%85%E6%9C%BA%E8%AE%B0%E5%BD%95.html"/>
      <url>/2019-03-15-%E8%A3%85%E6%9C%BA%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">类型</th><th align="center">型号</th><th align="right">价格</th><th align="right">出二手价格</th></tr></thead><tbody><tr><td align="left">cpu</td><td align="center">i5 8400</td><td align="right">1600</td><td align="right">700</td></tr><tr><td align="left">主板</td><td align="center">微星 B360M</td><td align="right">740</td><td align="right">50</td></tr><tr><td align="left">内存</td><td align="center">金士顿 DDR4 3000 8G</td><td align="right">400</td><td align="right">50(坏)</td></tr><tr><td align="left">显卡</td><td align="center">GTX1066</td><td align="right">1700</td><td align="right">800</td></tr><tr><td align="left">SSD</td><td align="center">intel 512G M.2</td><td align="right">800</td><td align="right"></td></tr><tr><td align="left">HDD</td><td align="center">希捷 2T7200转</td><td align="right">380</td><td align="right"></td></tr><tr><td align="left">电源</td><td align="center">鑫谷550w</td><td align="right">320</td><td align="right">0</td></tr><tr><td align="left">机箱</td><td align="center">追风者416PTG</td><td align="right">290</td><td align="right"></td></tr><tr><td align="left">显示器</td><td align="center">AOC I2779VH</td><td align="right">1000</td><td align="right"></td></tr><tr><td align="left">total</td><td align="center"></td><td align="right">7230</td><td align="right">1600</td></tr></tbody></table><p>大二第一次给笔记本加内存和SSD才第一次对计算机硬件有了概念, 知直到大四第一次组装台式机才知道了许多即使对非cs专业的人来说都算是常识的事情:</p><ol><li>cpu连着主板(废话), 内存插在主板上(24&gt;13&gt;1), SSD插在主板上, 显卡插在主板上, HDD插在机箱里</li><li>机箱正面的几个孔和按钮(耳机, 麦克风, 开机, 重启)要手动连到主板上的对应位置</li><li>显卡提供VGA, HDMI等接口</li><li>HDD要连数据线和电源线</li><li>最麻烦的是各个组件连电源</li></ol><p>各种电脑配件决定价格和质量的参数:</p><ul><li>cpu: 主频&#x2F;实际一般直接看代数</li><li>显卡: 计算力&#x2F;实际一般直接看代数, 显存</li><li>内存: 大小, 频率, DDR代数</li><li>SSD: 大小, 接口</li><li>HDD: 大小, 转速</li><li>显示器: 大小, 材质, 频率, 分辨率</li></ul><hr><p>2022-07 UPDATE</p><table><thead><tr><th align="left">类型</th><th align="center">型号</th><th align="right">价格</th></tr></thead><tbody><tr><td align="left">cpu</td><td align="center">i5 12490F</td><td align="right">1250</td></tr><tr><td align="left">主板</td><td align="center">华硕 TUF B660M WIFI6 重炮手D4</td><td align="right">1100</td></tr><tr><td align="left">内存</td><td align="center">金士顿 DDR4 3200 16G</td><td align="right">400*2</td></tr><tr><td align="left">显卡</td><td align="center">七彩虹 ULTRA W OC RTX3080 12G</td><td align="right">6300</td></tr><tr><td align="left">SSD</td><td align="center">金士顿KC3000 1T PCIE4.0</td><td align="right">900</td></tr><tr><td align="left">HDD</td><td align="center"></td><td align="right"></td></tr><tr><td align="left">电源</td><td align="center">鑫谷GN850w</td><td align="right">400</td></tr><tr><td align="left">机箱</td><td align="center"></td><td align="right"></td></tr><tr><td align="left">显示器</td><td align="center">AOC Q27G2S&#x2F;D</td><td align="right">1800</td></tr><tr><td align="left">total</td><td align="center"></td><td align="right">12550</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写Dockerfile中遇到的问题</title>
      <link href="/2019-02-21-%E5%86%99Dockerfile%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
      <url>/2019-02-21-%E5%86%99Dockerfile%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件映射"><a href="#文件映射" class="headerlink" title="文件映射"></a>文件映射</h1><p><a href="https://docs.docker.com/storage/volumes/">Use volumes | Docker Documentation</a></p><p><a href="http://dockone.io/article/128">深入理解Docker Volume（一） - DockOne.io</a></p><p><a href="http://dockone.io/article/129">深入理解Docker Volume（二） - DockOne.io</a></p><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 运行时指定</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -v /container/data hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Dockerfile中指定</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /container/data</span></span><br></pre></td></tr></table></figure><p>docker 会在 host 上创建一个目录并挂载到 container 的 <code>/container/data</code></p><p>创建的目录默认路径在 <code>/var/lib/docker</code></p><h2 id="bind-mount"><a href="#bind-mount" class="headerlink" title="bind-mount"></a>bind-mount</h2><p><code>docker run -v /host/data:/container/data hello</code> </p><p>将 <code>host</code> 的 <code>/host/data</code> 目录挂载到了 <code>container</code> 的 <code>/container/data</code> 目录下</p><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>因为是“挂载”, host 的目录内容会覆盖 container 的目录:</p><ul><li>如果是普通 mount 则 container 内的目录一定会被覆盖为空</li><li>如果是 bind-mount, 但指定的 host 目录原本不存在, 则 container 目录也会被覆盖为空</li></ul><p>todo: volume 的顺序是否会影响文件是否被覆盖</p><p><a href="https://segmentfault.com/a/1190000015684472">Docker volume 挂载时文件或文件夹不存在 - Keep Coding - SegmentFault 思否</a></p><h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><h2 id="终端打印彩色字体"><a href="#终端打印彩色字体" class="headerlink" title="终端打印彩色字体"></a>终端打印彩色字体</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[31m 我是红色 \033[0m&quot;</span></span><br></pre></td></tr></table></figure><h2 id="shell的比较选项"><a href="#shell的比较选项" class="headerlink" title="shell的比较选项"></a>shell的比较选项</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-bash-test.html">Linux 技巧: Bash 测试和比较函数</a></p><h2 id="shell读参数"><a href="#shell读参数" class="headerlink" title="shell读参数"></a>shell读参数</h2><p><a href="http://billie66.github.io/TLCL/book/chap33.html">位置参数 - TLCL</a></p><h2 id="星际选手"><a href="#星际选手" class="headerlink" title="星际选手"></a>星际选手</h2><p><code>sed</code> 写成了 <code>set</code>, 两个单词高亮一样, 查了几个小时, 一直以为是脚本没执行, 最后才发现是命令写错了</p><h1 id="持续运行"><a href="#持续运行" class="headerlink" title="持续运行"></a>持续运行</h1><p>docker 执行完脚本后就会自动停止</p><p>为了使其正常工作, 一般用 <code>CMD [&quot;...&quot;]</code> 显式使其执行命令, 或者使用 tailf 查看日志等</p><h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><h2 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a>容器运行时</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部查看程序的日志</span></span><br><span class="line">docker <span class="built_in">exec</span> -it hello bash</span><br></pre></td></tr></table></figure><h2 id="容器停止后"><a href="#容器停止后" class="headerlink" title="容器停止后"></a>容器停止后</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 host 上查看 hello 输出的日志, 即 hello 内部打印到 bash 的信息</span></span><br><span class="line">docker logs hello</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles | Docker Documentation</a></p><p><a href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html">附录四：Dockerfile 最佳实践 · Docker —— 从入门到实践</a></p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p><a href="https://hub.docker.com/_/redis">redis - Docker Hub</a></p><p><a href="https://hub.docker.com/_/nginx">nginx - Docker Hub</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的字符串替换</title>
      <link href="/2019-02-21-Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2.html"/>
      <url>/2019-02-21-Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2.html</url>
      
        <content type="html"><![CDATA[<h1 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h1><h2 id="简单替换"><a href="#简单替换" class="headerlink" title="简单替换"></a>简单替换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>;</span><br></pre></td></tr></table></figure><h2 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span>;</span><br></pre></td></tr></table></figure><p><code>str.replaceFirst(regex, repl)</code> 等价于 <code>Pattern.compile(regex).matcher(str).replaceFirst(repl)</code></p><p>replacement 中的反斜杠(\) 美元符号($) 可能会导致结果异常, 如果需要的话使用 <code>Matcher.quoteReplacement(java.lang.String)</code> 进行处理</p><h1 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceFirst</span><span class="params">(String replacement)</span>;</span><br></pre></td></tr></table></figure><p>replacement 中的反斜杠(\) 美元符号($) 可能会导致结果异常, 反斜杠可能会被用于转义, 美元符号可能会被当成被匹配到的子序列的引用</p><hr><p>参考资料</p><p><a href="https://www.cnblogs.com/ggjucheng/p/3423731.html">JAVA正则表达式：Pattern类与Matcher类详解(转) - ggjucheng - 博客园</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网</title>
      <link href="/2019-02-10-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.html"/>
      <url>/2019-02-10-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h1><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget</span><br><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line"><span class="built_in">chmod</span> +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | <span class="built_in">tee</span> shadowsocks-all.log</span><br></pre></td></tr></table></figure><p><strong>centos8</strong><br>编辑 <code>shadowsocks-all.sh</code> 将 <code>install_dependencies()</code> 中的python替换为python39</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python39 python39-devel python39-setuptools</span><br><span class="line"><span class="built_in">ln</span> -s /usr/bin/python3 /usr/bin/python</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h3 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h3><p><a href="https://teddysun.com/489.html">一键安装最新内核并开启 BBR 脚本 | 秋水逸冰</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启</span></span><br><span class="line">wget --no-check-certificate -O /opt/bbr.sh https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line"><span class="built_in">chmod</span> 755 /opt/bbr.sh</span><br><span class="line">/opt/bbr.sh</span><br><span class="line"><span class="comment"># 重启后检查是否开启</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>用以下命令在终端生成一个强密码: <code>openssl rand -base64 16</code></p><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p><a href="https://github.com/shadowsocks/ShadowsocksX-NG">https://github.com/shadowsocks/ShadowsocksX-NG</a></p><p><a href="https://github.com/shadowsocks/shadowsocks-windows">https://github.com/shadowsocks/shadowsocks-windows</a></p><p><a href="https://github.com/shadowsocks/shadowsocks-android">https://github.com/shadowsocks/shadowsocks-android</a></p><h1 id="机场"><a href="#机场" class="headerlink" title="机场"></a>机场</h1><p><a href="https://www.duyaoss.com/archives/1/">DuyaoSS-机场测速 [SS&#x2F;SSR&#x2F;V2Ray&#x2F;Trojan] 【电信】纯测速图 更新中 - DuyaoSS-机场测速和简介</a></p><h2 id="Kuromis"><a href="#Kuromis" class="headerlink" title="Kuromis"></a>Kuromis</h2><p><a href="https://kuromis-web.pages.dev/">https://kuromis-web.pages.dev/</a></p><p><a href="https://wiki.metacubex.one/client/">使用Meta的客户端 - Clash.Meta Wiki</a></p><ul><li>windows&#x2F;mac <a href="https://github.com/zzzgydi/clash-verge">https://github.com/zzzgydi/clash-verge</a></li><li>android <a href="https://github.com/MetaCubeX/ClashMetaForAndroid">https://github.com/MetaCubeX/ClashMetaForAndroid</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用字符串加锁</title>
      <link href="/2018-12-16-%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E9%94%81.html"/>
      <url>/2018-12-16-%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E9%94%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h1><p>使用 redis 做缓存, 在缓存中查询不到时要先加锁再去 db 中查, 这时用查询 redis 时的锁作为 key 进行加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;K, T&gt; T <span class="title function_">findCache</span><span class="params">(K key, <span class="type">long</span> timeout, TimeUnit unit, Class&lt;T&gt; clazz, Callable&lt;T&gt; loadBack)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> redisService.get(key, clazz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != result) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;load cache ======== &#123;&#125;.&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool.intern(key)) &#123;</span><br><span class="line">            result = redisService.get(key, clazz);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != result) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;load cache ======== &#123;&#125;.&quot;</span>, key);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = doLoadBack(loadBack);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                redisService.set(key, result, timeout, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不能直接用-String-对象作为锁"><a href="#不能直接用-String-对象作为锁" class="headerlink" title="不能直接用 String 对象作为锁"></a>不能直接用 String 对象作为锁</h1><p>synchronizd 加锁是基于对象进行的, value内容相同的两个 String, 如果不是同一个对象, 期望的加锁行为就无法完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NicoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NicoThread</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;: begin sleep&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;: end sleep&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;niconiconi&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;niconiconi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NicoThread</span>(s1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NicoThread</span>(s2).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">Thread-0: begin sleep</span><br><span class="line">Thread-1: begin sleep</span><br><span class="line">Thread-1: end sleep</span><br><span class="line">Thread-0: end sleep</span><br><span class="line">// 同步失败</span><br></pre></td></tr></table></figure><h1 id="使用-intern-对象加锁"><a href="#使用-intern-对象加锁" class="headerlink" title="使用 intern() 对象加锁?"></a>使用 intern() 对象加锁?</h1><p>value内容相同的两个 String, intern() 后得到的是 String 常量池中的同一个对象, 可以完成期望的锁操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// synchronized(s) &#123;&#125;</span><br><span class="line">synchronized(s.intern()) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="intern-的-gc-问题"><a href="#intern-的-gc-问题" class="headerlink" title="intern() 的 gc 问题"></a>intern() 的 gc 问题</h1><p><a href="https://www.cnblogs.com/yhlx/p/3498387.html">在jdk7下慎用String.intern()作为synchronized的对象锁 - 绝望生鱼片 - 博客园</a></p><p><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析String#intern</a></p><p>频繁调用 intern() 可能产生内存问题, 为了解决这个问题, 可以自定义一个 ConcurrentHashMap&lt;String, Object&gt; 用来储存传入的 key 与实际锁的对象</p><h1 id="guava-的-interner-实现"><a href="#guava-的-interner-实现" class="headerlink" title="guava 的 interner 实现"></a>guava 的 interner 实现</h1><p><a href="https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/Interner.html">api文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Interner&lt;String&gt; interner = Interners.&lt;String&gt;newWeakInterner();</span><br><span class="line"></span><br><span class="line">synchronized(interner.intern(str)) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="类似数据结构"><a href="#类似数据结构" class="headerlink" title="类似数据结构"></a>类似数据结构</h1><p>guava 的 cache 是在内存中用 map 做缓存</p><p><a href="https://google.github.io/guava/releases/23.5-jre/api/docs/">https://google.github.io/guava/releases/23.5-jre/api/docs/</a></p><hr><p>参考资料</p><p><a href="https://stackoverflow.com/questions/3972841/when-is-it-beneficial-to-flyweight-strings-in-java">When is it beneficial to flyweight Strings in Java? - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/133988/synchronizing-on-string-objects-in-java">multithreading - Synchronizing on String objects in Java - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/5639870/simple-java-name-based-locks">locking - Simple Java name based locks? - Stack Overflow</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java用注解做参数校验</title>
      <link href="/2018-12-15-Java%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%81%9A%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C.html"/>
      <url>/2018-12-15-Java%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%81%9A%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C.html</url>
      
        <content type="html"><![CDATA[<h1 id="JSR-303-Bean-Validation"><a href="#JSR-303-Bean-Validation" class="headerlink" title="JSR 303 Bean Validation"></a>JSR 303 Bean Validation</h1><p><code>javax.validation.constraints</code></p><ul><li>NotNull</li><li>NotEmpty</li><li>NotBlank</li><li>…</li></ul><p>常用 Hibernate Validator 实现, 在 controller 层用 @Validated 开启, 在运行时校验不通过则报错</p><h1 id="JSR-305-Annotations-for-Software-Defect-Detection"><a href="#JSR-305-Annotations-for-Software-Defect-Detection" class="headerlink" title="JSR 305 Annotations for Software Defect Detection"></a>JSR 305 Annotations for Software Defect Detection</h1><p><code>org.springframework.lang</code></p><ul><li>NonNull</li><li>Nullable</li></ul><p>提供给ide做判断提示, 在运行时不起作用</p><h1 id="Jetbrains-家的注解"><a href="#Jetbrains-家的注解" class="headerlink" title="Jetbrains 家的注解"></a>Jetbrains 家的注解</h1><p>涵盖了 JSR 305 的规范, 还有额外的 @Contract @TestOnly 等</p><p><a href="https://www.jetbrains.com/help/idea/annotating-source-code.html">官网英文文档</a><br>(Jetbrains 家的文档是真的好)</p><p><a href="https://zhuanlan.zhihu.com/p/24778947">中文文档(不)</a></p><h1 id="几个常识"><a href="#几个常识" class="headerlink" title="几个常识"></a>几个常识</h1><h3 id="JCP"><a href="#JCP" class="headerlink" title="JCP"></a>JCP</h3><p>Java Community Process, 由Sun创建, 用来发展和更新Java技术规范, 参考实现(RI), 技术兼容包(TCK)</p><h3 id="JSR"><a href="#JSR" class="headerlink" title="JSR"></a>JSR</h3><p>Java Specification Requests, JCP 成员向委员会提交的 Java 发展议案，经过一系列流程后，如果通过会成为 JEP</p><h3 id="JEP"><a href="#JEP" class="headerlink" title="JEP"></a>JEP</h3><p>JDK Enhancement Proposals, JDK的版本变化将从这些提案中选取</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.oschina.net/question/3838659_2278450">JAVA中@NotNull和@Nonnull有什么区别？ - 开源中国</a></p><p><a href="https://www.jianshu.com/p/31433bcaa1a5">JDK 版本变化 - 简书</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.util.concurrent</title>
      <link href="/2018-08-13-java-util-concurrent.html"/>
      <url>/2018-08-13-java-util-concurrent.html</url>
      
        <content type="html"><![CDATA[<h1 id="Concurrent-包"><a href="#Concurrent-包" class="headerlink" title="Concurrent 包"></a>Concurrent 包</h1><h2 id="1-Lock"><a href="#1-Lock" class="headerlink" title="1. Lock"></a>1. Lock</h2><p>Lock 对象的工作机制类似于同步代码块使用的 synchronized，在某一时刻只允许一个线程拥有锁对象</p><p>通过它们关联的 Condition 对象，锁对象也支持 wait&#x2F;notify 机制</p><p>一个 Lock 对象和一个 synchronized 代码块之间的主要不同点是：</p><ul><li>synchronized 代码块不能够保证进入访问等待的线程的先后顺序</li><li>你不能够传递任何参数给一个 synchronized 代码块的入口。因此，对于 synchronized 代码块的访问等待设置超时时间是不可能的事情</li><li>synchronized 块必须被完整地包含在单个方法里。而一个 Lock 对象可以把它的 lock() 和 unlock() 方法的调用放在不同的方法里</li></ul><p>Lock 加锁的方式很多：</p><ul><li>lock()</li><li>lockInterruptibly()</li><li>tryLock()</li><li>tryLock(long timeout, TimeUnit timeUnit)</li></ul><p>实现：<code>ReentrantLock</code> </p><h3 id="1-1-ReadWriteLock"><a href="#1-1-ReadWriteLock" class="headerlink" title="1.1 ReadWriteLock"></a>1.1 ReadWriteLock</h3><p>实现：<code>ReentrantReadWriteLock</code> </p><ul><li><strong>读锁</strong>：如果没有任何写操作线程锁定 ReadWriteLock，并且没有任何写操作线程要求一个写锁(但还没有获得该锁)。因此，可以有多个读操作线程对该锁进行锁定</li><li><strong>写锁</strong>：如果没有任何读操作或者写操作。因此，在写操作的时候，只能有一个线程对该锁进行锁定</li></ul><h2 id="2-Future"><a href="#2-Future" class="headerlink" title="2. Future"></a>2. Future</h2><p>Future 的核心思想是：一个方法 f，计算过程可能非常耗时，等待f返回，显然不明智</p><p>可以在调用 f 的时候，立马返回一个 Future，可以通过 Future 这个数据结构去控制方法f的计算过程。</p><p>这里的<strong>控制</strong>包括：</p><ol><li>get：获取计算结果（如果还没计算完，也是必须等待的）</li><li>cancel：还没计算完，可以取消计算过程</li><li>isDone：判断是否计算完</li><li>isCancelled：判断计算是否被取消</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = () -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;niconiconi&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="type">String</span> <span class="variable">say</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    say = task.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(say);</span><br></pre></td></tr></table></figure><p>源码分析见 <a href="https://www.cnblogs.com/cz123/p/7693064.html">彻底理解Java的Future模式 - 大诚挚 - 博客园</a></p><h2 id="3-Executor"><a href="#3-Executor" class="headerlink" title="3. Executor"></a>3. Executor</h2><p>Java.util.concurrent 包定义了三种 executor 接口： </p><ul><li>Executor，支持加载新任务的简单接口</li><li>ExecutorService，Executor 的子接口，增加了帮助管理任务和executor本身的生命周期的功能</li><li>ScheduledExecutorService，ExecutorService 的子接口，支持周期性地执行任务</li></ul><h3 id="3-1-Executor"><a href="#3-1-Executor" class="headerlink" title="3.1 Executor"></a>3.1 Executor</h3><p>Executor 接口只定义了一个方法 execute，被设计用来代替一般的创建线程惯例 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r implements Runnable</span></span><br><span class="line"><span class="comment">// 自己控制线程</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Thread</span>(r)).start();</span><br><span class="line"><span class="comment">// 用 executor</span></span><br><span class="line">e.execute(r);</span><br></pre></td></tr></table></figure><p>对于 execute 方法的实现并没有特殊要求。低级的实现只是创建一个新的线程并立即执行</p><p>但更有可能是使用一个已经存在的工作线程（worker Threads）去执行 r，或者将 r 放在一个执行队列中等待工作线程有空的时候再执行 </p><h3 id="3-2-ExecutorService"><a href="#3-2-ExecutorService" class="headerlink" title="3.2 ExecutorService"></a>3.2 ExecutorService</h3><p>ExecutorService 接口提供了另一个相似的 submit 方法，但比 execute 更加通用</p><p>和 execute 一样，submit 接受 Runnable 对象，但也接受 Callable 对象，Callable 允许任务执行后返回一个值</p><p>Submit 方法返回 Future 对象，Future 对象被用来接收 Callable 返回的值，并管理 Callable 和 Runnable 对象所代表的任务 </p><p>常用实现：ThreadPoolExecutor</p><ul><li>Executors.newFixedThreadPool() : ThreadPoolExecutor</li><li>Executors.newCachedThreadPool() : ThreadPoolExecutor 一个使用可扩展线程池的 executor，拥有这种线程池的 executor 适合执行生命周期较短的任务</li><li>Executors.newSingleThreadExecutor() : FinalizableDelegatedExecutorService 一个只有一个工作线程的executor</li></ul><h3 id="3-3-ScheduledExecutorService"><a href="#3-3-ScheduledExecutorService" class="headerlink" title="3.3 ScheduledExecutorService"></a>3.3 ScheduledExecutorService</h3><p>ScheduledExecutorService 接口为它的父类 ExecutorService 的行为提供计划，允许在执行 Runnable 和 Callable 任务之前停顿一段时间</p><p>接口定义了 scheduleAtFixedRate 和 scheduleWithFixedDelay，这两个方法以特定的时间间隔重复地执行特定任务 </p><p>常用实现：ScheduledThreadPoolExecutor</p><ul><li>Executors.newScheduledThreadPool() : ScheduledThreadPoolExecutor</li></ul><h3 id="3-4-thread-pool"><a href="#3-4-thread-pool" class="headerlink" title="3.4 thread pool"></a>3.4 thread pool</h3><p>Thread 对象占用了大量的内存，在一个大型应用中，分配和释放线程对象会造成大量的线程管理开支 </p><p>使用工作线程可以减少创建线程的资源浪费，工作线程是不属于特定某个 Runnable 和 Callable 任务，经常用来执行多个任务 </p><p>大部分 java.util.concurrent 中的 executor 实现类使用了工作线程(worker threads)的线程池</p><h3 id="3-5-the-fixed-thread-pool"><a href="#3-5-the-fixed-thread-pool" class="headerlink" title="3.5 the fixed thread pool"></a>3.5 the fixed thread pool</h3><p>Executors.newFixedThreadPool()</p><h5 id="what"><a href="#what" class="headerlink" title="what"></a>what</h5><p>一种常用的线程池是固定线程池，这种线程池有特定数量的线程在运行，如果一个线程在使用过程中意外停止(如抛出未捕获的异常)，它会自动被另一个新线程替代</p><h5 id="how"><a href="#how" class="headerlink" title="how"></a>how</h5><p>任务通过一个内部的任务队列提交给线程池执行，此任务队列可以在活动任务数量大于线程池中工作线程个数时，存储多余的活动任务 </p><h5 id="why"><a href="#why" class="headerlink" title="why"></a>why</h5><p>“固定大小线程池”的一个好处是”优雅的缓冲”</p><p>考虑一个web应用服务，它的每一个线程只处理一个HTTP请求。如果这个应用简单地为每一个新来的请求创建一个新的处理线程，那么，当请求数量足够多时，线程占用的资源总和将超过系统的承受能力，服务器会因此忽然停止对所有请求的应答(常见的内存溢出)</p><p>而在使用固定大小线程池后，即使请求数量超出工作线程能够处理的请求上限，但是新来的HTTP请求会被暂时存放在消息队列中，当出现空闲的工作线程后，这些HTTP请求就会得到及时的处理 </p><h2 id="4-Fork-x2F-Join"><a href="#4-Fork-x2F-Join" class="headerlink" title="4. Fork&#x2F;Join"></a>4. Fork&#x2F;Join</h2><p>Java SE 7 中的特性，fork&#x2F;join 框架帮助你创建多进程应用。它被设计用来完成可以分成很多小进程的工作，目的是使用所有可用的进程来提升你的应用的性能 </p><p>像任何 ExecutorService 一样，fork&#x2F;join 框架把任务分发给线程池中工作线程。不同的是，因为 fork&#x2F;join 框架使用 work-stealing 算法——完成工作的工作线程可以从其他还在忙碌的线程那里偷任务来执行 </p><p>fork&#x2F;join 框架的核心是 ForkJoinPool 类，一个 AbstractExecutorService 的扩展类；ForkJoinPool 实现了核心的work-stealing算法，能够执行 ForkJoinTask 任务 </p><h3 id="4-1-思路"><a href="#4-1-思路" class="headerlink" title="4.1 思路"></a>4.1 思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (此部分工作足够小) &#123;</span><br><span class="line">  直接干活</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  把工作分成两部分，  </span><br><span class="line">  调用完成这两部分的代码，并等待结果返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把以上代码封装成ForkJoinTask子类</p><p>特别地作为更具体的类型 RecursiveAction 或 RecursiveTask (可以返回结果)</p><h3 id="4-2-例子"><a href="#4-2-例子" class="headerlink" title="4.2 例子"></a>4.2 例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RecursiveAction, execute without return value</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRecursiveAction</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">workLoad</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRecursiveAction</span><span class="params">(<span class="type">long</span> workLoad)</span> &#123; <span class="built_in">this</span>.workLoad = workLoad; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.workLoad &gt; <span class="number">16</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Splitting workLoad : &quot;</span> + <span class="built_in">this</span>.workLoad);</span><br><span class="line"></span><br><span class="line">            List&lt;MyRecursiveAction&gt; subtasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(createSubtasks());</span><br><span class="line">            <span class="keyword">for</span>(RecursiveAction subtask : subtasks)&#123;</span><br><span class="line">                subtask.fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Doing workLoad myself: &quot;</span> + <span class="built_in">this</span>.workLoad);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MyRecursiveAction&gt; <span class="title function_">createSubtasks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;MyRecursiveAction&gt; subtasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyRecursiveAction</span> <span class="variable">subtask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRecursiveAction</span>(<span class="built_in">this</span>.workLoad / <span class="number">2</span>);</span><br><span class="line">        <span class="type">MyRecursiveAction</span> <span class="variable">subtask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRecursiveAction</span>(<span class="built_in">this</span>.workLoad / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        subtasks.add(subtask1);</span><br><span class="line">        subtasks.add(subtask2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subtasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">MyRecursiveAction</span> <span class="variable">myRecursiveAction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRecursiveAction</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        forkJoinPool.invoke(myRecursiveAction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RecursiveTask, execute with return value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRecursiveTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">workLoad</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRecursiveTask</span><span class="params">(<span class="type">long</span> workLoad)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.workLoad = workLoad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.workLoad &gt; <span class="number">16</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Splitting workLoad : &quot;</span> + <span class="built_in">this</span>.workLoad);</span><br><span class="line"></span><br><span class="line">            List&lt;MyRecursiveTask&gt; subtasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(createSubtasks());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(MyRecursiveTask subtask : subtasks)&#123;</span><br><span class="line">                subtask.fork();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(MyRecursiveTask subtask : subtasks) &#123;</span><br><span class="line">                result += subtask.join();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Doing workLoad myself: &quot;</span> + <span class="built_in">this</span>.workLoad);</span><br><span class="line">            <span class="keyword">return</span> workLoad * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MyRecursiveTask&gt; <span class="title function_">createSubtasks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;MyRecursiveTask&gt; subtasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyRecursiveTask</span> <span class="variable">subtask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRecursiveTask</span>(<span class="built_in">this</span>.workLoad / <span class="number">2</span>);</span><br><span class="line">        <span class="type">MyRecursiveTask</span> <span class="variable">subtask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRecursiveTask</span>(<span class="built_in">this</span>.workLoad / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        subtasks.add(subtask1);</span><br><span class="line">        subtasks.add(subtask2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subtasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">MyRecursiveTask</span> <span class="variable">myRecursiveTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRecursiveTask</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">mergedResult</span> <span class="operator">=</span> forkJoinPool.invoke(myRecursiveTask);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;mergedResult = &quot;</span> + mergedResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-work-stealing"><a href="#4-3-work-stealing" class="headerlink" title="4.3 work-stealing"></a>4.3 work-stealing</h3><p>调度策略：</p><ul><li>每一个工作线程维护自己的调度队列中的可运行任务 </li><li>队列以 deque 的形式被维护，不仅支持后进先出 —— <code>LIFO</code> 的 <code>push</code> 和 <code>pop</code> 操作，还支持先进先出 —— <code>FIFO</code> 的 <code>take</code> 操作 </li><li>对于一个给定的工作线程来说，任务所产生的子任务将会被放入到工作者自己的双端队列中 </li><li>工作线程使用后进先出 —— <code>LIFO</code>（最新的元素优先）的顺序，通过弹出任务来处理队列中的任务 </li><li>当一个工作线程的本地没有任务去运行的时候，它将使用先进先出 —— <code>FIFO</code>的规则尝试随机的从别的工作线程中拿（『窃取』）一个任务去运行 </li><li>当一个工作线程触及了<code>join</code>操作，如果可能的话它将处理其他任务，直到目标任务被告知已经结束（通过 <code>isDone</code> 方法）。所有的任务都会无阻塞的完成 </li><li>当一个工作线程无法再从其他线程中获取任务和失败处理的时候，它就会退出（通过<code>yield</code>、<code>sleep</code>和&#x2F;或者优先级调整）并经过一段时间之后再度尝试直到所有的工作线程都被告知他们都处于空闲的状态；在这种情况下，他们都会阻塞直到其他的任务再度被上层调用</li></ul><p>使用后进先出 —— <code>LIFO</code>用来处理每个工作线程的自己任务，但是使用先进先出 —— <code>FIFO</code>规则用于获取别的任务，这是一种被广泛使用的进行递归<code>Fork/Join</code>设计的一种调优手段 </p><p>让窃取任务的线程从队列拥有者相反的方向进行操作会减少线程竞争。同样体现了递归分治算法的大任务优先策略。因此，更早期被窃取的任务有可能会提供一个更大的单元任务，从而使得窃取线程能够在将来进行递归分解 </p><p>作为上述规则的一个后果，对于一些基础的操作而言，使用相对较小粒度的任务比那些仅仅使用粗粒度划分的任务以及那些没有使用递归分解的任务的运行速度要快。尽管相关的少数任务在大多数的<code>Fork/Join</code>框架中会被其他工作线程窃取，但是创建许多组织良好的任务意味着只要有一个工作线程处于可运行的状态，那么这个任务就有可能被执行 </p><h2 id="5-Concurrent-Collection"><a href="#5-Concurrent-Collection" class="headerlink" title="5. Concurrent Collection"></a>5. Concurrent Collection</h2><h3 id="5-1-BlockingQueue"><a href="#5-1-BlockingQueue" class="headerlink" title="5.1 BlockingQueue"></a>5.1 BlockingQueue</h3><p>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点</p><p>也就是说，它是有限的，如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞，直到负责消费的线程从队列中拿走一个对象。</p><p>负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列</p><p>常用实现：</p><ol><li>ArrayBlockingQueue 上限不能改变</li><li>LinkedBlockingQueue 上限能改变</li><li>DelayQueue 对元素进行持有，直到到期 </li><li>PriorityBlockingQueue 排序规则和 java.util.PriorityQueue 相同</li><li>SynchronousQueue 只能放一个元素</li></ol><h3 id="5-2-BlockingDeque"><a href="#5-2-BlockingDeque" class="headerlink" title="5.2 BlockingDeque"></a>5.2 BlockingDeque</h3><p>如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，可以使用 BlockingDeque </p><p>如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素</p><p>如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素 </p><h3 id="5-3-ConcurrentMap"><a href="#5-3-ConcurrentMap" class="headerlink" title="5.3 ConcurrentMap"></a>5.3 ConcurrentMap</h3><p>见 <a href="http://www.jasongj.com/java/concurrenthashmap">ConcurrentHashMap演进从Java7到Java8</a> </p><h2 id="6-CyclicBarrier"><a href="#6-CyclicBarrier" class="headerlink" title="6. CyclicBarrier"></a>6. CyclicBarrier</h2><p>它就是一个所有线程必须等待的一个栅栏，直到所有线程都到达这里，然后所有线程才可以继续做其他事情 </p><h2 id="7-Exchanger"><a href="#7-Exchanger" class="headerlink" title="7. Exchanger"></a>7. Exchanger</h2><p>表示一种两个线程可以进行互相交换对象的会和点 </p><h2 id="8-Semaphore"><a href="#8-Semaphore" class="headerlink" title="8. Semaphore"></a>8. Semaphore</h2><p>计数信号量由一个指定数量的 “许可” 初始化</p><p>每调用一次 acquire()，一个许可会被调用线程取走。每调用一次 release()，一个许可会被返还给信号量</p><p>因此，在没有任何 release() 调用时，最多有 N 个线程能够通过 acquire() 方法，N 是该信号量初始化时的许可的指定数量。 </p><h2 id="9-Atomic-Variable"><a href="#9-Atomic-Variable" class="headerlink" title="9. Atomic Variable"></a>9. Atomic Variable</h2><p>java.util.concurrent.atomic 包中定义了对单个变量的原子操作支持</p><p>包中的所有的类的 getter 和 setter，都像对 volatile 变量操作一样，具有原子性，即一个set操作与后续的get操作存在绝对的先后关系 </p><h3 id="9-1-AtomicReference"><a href="#9-1-AtomicReference" class="headerlink" title="9.1 AtomicReference"></a>9.1 AtomicReference</h3><p>AtomicReference 类具备了一个很有用的方法：compareAndSet()</p><p>compareAndSet() 可以将保存在 AtomicReference 里的引用于一个期望引用进行比较，如果两个引用是一样的，将会给 AtomicReference 实例设置一个新的引用 —— <strong>并非 equals() 的相等，而是 &#x3D;&#x3D; 的相等</strong> </p><h2 id="10-ThreadLocalRandom"><a href="#10-ThreadLocalRandom" class="headerlink" title="10. ThreadLocalRandom"></a>10. ThreadLocalRandom</h2><p>在并发环境中，使用 ThreadLocalRandom 替换 Math.random() 可以减少冲突，提高性能</p><p>可以将它用来在多线程或ForJoinTask中获得随机数</p><hr><p>参考文章</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html">java.util.concurrent (Java Platform SE 8 )</a> </p><p><a href="http://623deyingxiong.iteye.com/blog/1754030">高级并发对象(Councurrency Tutorial 7) - 春晓春晓 - ITeye博客</a> </p><p><a href="https://www.cnblogs.com/cz123/p/7693064.html">彻底理解Java的Future模式 - 大诚挚 - 博客园</a> </p><p><a href="https://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html">JVM 并发性: Java 和 Scala 并发性基础</a> </p><p><a href="https://www.ibm.com/developerworks/cn/java/j-jvmc2/index.html">JVM 并发性: Java 8 并发性基础</a> </p><p><a href="http://ifeve.com/java-fork-join-framework">Java Fork&#x2F;Join框架 | 并发编程网 – ifeve.com</a> </p><p><a href="http://www.importnew.com/26461.html">Java 并发工具包 java.util.concurrent 用户指南 - CSDN博客</a> </p><p><a href="http://www.jasongj.com/java/concurrenthashmap">ConcurrentHashMap演进从Java7到Java8 | 技术世界</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的IO</title>
      <link href="/2018-08-10-Java%E7%9A%84IO.html"/>
      <url>/2018-08-10-Java%E7%9A%84IO.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-I-x2F-O-类库概况"><a href="#Java-I-x2F-O-类库概况" class="headerlink" title="Java I&#x2F;O 类库概况"></a>Java I&#x2F;O 类库概况</h1><p>Java 的 I&#x2F;O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是： </p><ol><li>基于字节操作的 I&#x2F;O 接口：InputStream 和 OutputStream</li><li>基于字符操作的 I&#x2F;O 接口：Writer 和 Reader</li><li>基于磁盘操作的 I&#x2F;O 接口：File</li><li>基于网络操作的 I&#x2F;O 接口：Socket</li></ol><h1 id="字节与字符的转化接口"><a href="#字节与字符的转化接口" class="headerlink" title="字节与字符的转化接口"></a>字节与字符的转化接口</h1><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>InputStreamReader 类是字节到字符的转化桥梁，InputStream 到 Reader 的过程要指定编码字符集，否则将采用操作系统默认字符集</p><p>StreamDecoder 正是完成字节到字符的解码的实现类</p><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>OutputStreamWriter 类完成，字符到字节的编码过程，由 StreamEncoder 完成编码过程 </p><h1 id="磁盘-I-x2F-O-工作机制"><a href="#磁盘-I-x2F-O-工作机制" class="headerlink" title="磁盘 I&#x2F;O 工作机制"></a>磁盘 I&#x2F;O 工作机制</h1><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image015.jpg" alt="磁盘 I/O"> </p><h1 id="Java-Socket-的工作机制"><a href="#Java-Socket-的工作机制" class="headerlink" title="Java Socket 的工作机制"></a>Java Socket 的工作机制</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能</p><p>打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭；交通工具有多种，每种交通工具也有相应的交通规则</p><p>Socket 也一样，也有多种：大部分情况下我们使用的都是基于 TCP&#x2F;IP 的流套接字，它是一种稳定的通信协议</p><h3 id="建立通信链路-client"><a href="#建立通信链路-client" class="headerlink" title="建立通信链路 - client"></a>建立通信链路 - client</h3><p>当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭</p><p>在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误 </p><h3 id="建立通信链路-server"><a href="#建立通信链路-server" class="headerlink" title="建立通信链路 - server"></a>建立通信链路 - server</h3><p>与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址</p><p>之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口</p><p>这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中</p><p>所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接 </p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据</p><p>当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的</p><p>写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中 </p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image019.jpg" alt="NIO"> </p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>通道是对原 I&#x2F;O 包中的流的模拟，到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象 </p><p>拿 NIO 与原来的 I&#x2F;O 做个比较，通道就像是流。通道与流的不同之处在于通道是双向的，而流只是在一个方向上移动（一个流必须是 <code>InputStream</code> 或者 <code>OutputStream</code> 的子类）， 而  <code>通道 </code> 可以用于读、写或者同时用于读写 </p><p>正如前面提到的，所有数据都通过 <code>Buffer</code> 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节</p><h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出战还是在路上等等，也就是它可以轮询每个 Channel 的状态 </p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p><code>Buffer</code> 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 <code>Buffer</code> 对象，体现了新库与原 I&#x2F;O 的一个重要区别。在面向流的 I&#x2F;O 中，您将数据直接写入或者将数据直接读到 <code>Stream</code> 对象中。</p><p>在 NIO 库中，所有数据都是用缓冲区处理的：在读取数据时，它是直接读到缓冲区中的；在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中</p><p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 <em>仅仅</em>  是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读&#x2F;写进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io 与 nio 比较</span></span><br><span class="line">FileInputStream fis;</span><br><span class="line"><span class="comment">// io</span></span><br><span class="line">fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span> (temp != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%c&quot;</span>, temp);</span><br><span class="line">    temp = fis.read();</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line"><span class="comment">// nio</span></span><br><span class="line">fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">fc.read(bb);</span><br><span class="line"><span class="type">byte</span>[] array = bb.array();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">byte</span> b : array) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%c&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy file</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">inStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">outStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> inStream.getChannel();</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> outStream.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> inChannel.read(buffer);</span><br><span class="line">    <span class="keyword">if</span> (flag == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    outChannel.write(buffer);</span><br><span class="line">    buffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIO 引入了 Channel、Buffer 和 Selector 就是想把这些信息具体化，让程序员有机会控制它们，如：当我们调用 write() 往 SendQ 写数据时，当一次写的数据超过 SendQ 长度时需要按照 SendQ 的长度进行分割，这个过程中需要有将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的；而在 Buffer 中我们可以控制 Buffer 的 capacity，并且是否扩容以及如何扩容都可以控制 </p><h3 id="buffer-的状态变量"><a href="#buffer-的状态变量" class="headerlink" title="buffer 的状态变量"></a>buffer 的状态变量</h3><p>可以用三个值指定缓冲区在任意时刻的状态，这三个变量一起可以跟踪缓冲区的状态和它所包含的数据：</p><ul><li><code>position</code></li><li><code>limit</code></li><li><code>capacity</code></li></ul><p>相关详细：<a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">NIO 入门</a></p><h3 id="buffer-的访问方法"><a href="#buffer-的访问方法" class="headerlink" title="buffer 的访问方法"></a>buffer 的访问方法</h3><h5 id="缓存区分配和包装"><a href="#缓存区分配和包装" class="headerlink" title="缓存区分配和包装"></a>缓存区分配和包装</h5><ul><li>ByteBuffer.allocate( 1024 ) : ByteBuffer</li><li>ByteBuffer.wrap( new byte[1024] ) : ByteBuffer</li></ul><h5 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h5><p>您可能需要将用户数据保存到磁盘。在这种情况下，您必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘</p><p>或者，您可能想要从磁盘读取用户数据。在这种情况下，您要将数据从通道读到缓冲区中，然后检查缓冲区中的数据</p><ul><li>get()</li><li>put()</li></ul><h5 id="缓存区分片"><a href="#缓存区分片" class="headerlink" title="缓存区分片"></a>缓存区分片</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">3</span> );</span><br><span class="line">buffer.limit( <span class="number">7</span> );</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">slice</span> <span class="operator">=</span> buffer.slice();</span><br></pre></td></tr></table></figure><h5 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h5><ul><li>byteByffer.asReadOnlyBuffer()</li></ul><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>Java NIO 中提供的 FileChannel 拥有 transferTo() 和 transferFrom() 两个方法，可直接把 FileChannel() 中的数据拷贝到另外一个 Channel，或者直接把另外一个 Channel 中的数据拷贝到 FileChannel </p><p>该接口常被用于高效的网络&#x2F;文件的数据传输和大文件拷贝：在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于Java IO中提供的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">1234</span>);</span><br><span class="line">        socketChannel.connect(address);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(</span><br><span class="line">                NIOClient.class.getClassLoader().getResource(<span class="string">&quot;test.txt&quot;</span>).getFile(), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">        channel.transferTo(<span class="number">0</span>, channel.size(), socketChannel);</span><br><span class="line">        channel.close();</span><br><span class="line">        file.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h1><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列：要么成功都成功，失败都失败，两个任务的状态可以保持一致</p><p>而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列</p><p>我们可以用打电话和发短信来很好的比喻同步与异步操作</p><p>在设计到 IO 处理时通常都会遇到一个是同步还是异步的处理方式的选择问题。因为同步与异步的 I&#x2F;O 处理方式对调用者的影响很大，在数据库产品中都会遇到这个问题。因为 I&#x2F;O 操作通常是一个非常耗时的操作，在一个任务序列中 I&#x2F;O 通常都是性能瓶颈。但是同步与异步的处理方式对程序的可靠性影响非常大，同步能够保证程序的可靠性，而异步可以提升程序的性能，必须在可靠性和性能之间做个平衡，没有完美的解决办法。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事</p><p>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作</p><p>虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加：增加的 CPU 使用时间能不能补偿系统的切换成本需要好好评估</p><h3 id="两种的方式的组合"><a href="#两种的方式的组合" class="headerlink" title="两种的方式的组合"></a>两种的方式的组合</h3><table><thead><tr><th><strong>组合方式</strong></th><th><strong>性能分析</strong></th></tr></thead><tbody><tr><td>同步阻塞</td><td>最常用的一种用法，使用也是最简单的，但是 I&#x2F;O 性能一般很差，CPU 大部分在空闲状态。</td></tr><tr><td>同步非阻塞</td><td>提升 I&#x2F;O 性能的常用手段，就是将 I&#x2F;O 的阻塞改成非阻塞方式，尤其在网络 I&#x2F;O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。这种方式通常能提升 I&#x2F;O 性能，但是会增加 CPU 消耗，要考虑增加的 I&#x2F;O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I&#x2F;O 还是在 CPU 上。</td></tr><tr><td>异步阻塞</td><td>这种方式在分布式数据库中经常用到，例如在往一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I&#x2F;O。 异步阻塞对网络 I&#x2F;O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。</td></tr><tr><td>异步非阻塞</td><td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I&#x2F;O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。 它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I&#x2F;O 用这个方式性能能达到最高。</td></tr></tbody></table><h1 id="server和异步IO"><a href="#server和异步IO" class="headerlink" title="server和异步IO"></a>server和异步IO</h1><h3 id="server-实现"><a href="#server-实现" class="headerlink" title="server 实现"></a>server 实现</h3><ul><li>Java I&#x2F;O，单线程：循环处理请求——同一时间只能处理一个请求，等待I&#x2F;O的过程浪费大量CPU资源，同时无法充分使用多CPU的优势 </li><li>Java I&#x2F;O，多线程：为每个请求创建一个线程；为了防止连接请求过多，导致服务器创建的线程数过多，造成过多线程上下文切换的开销，可以通过线程池来限制创建的线程数 </li><li>Java NIO，单线程：经典 Reactor 模式——所有读&#x2F;写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势，同时读&#x2F;写操作也会阻塞对新连接请求的处理 </li><li>Java NIO，多线程：多工作线程 Reactor 模式</li><li>Java NIO，多线程：多 Reactor 模式</li></ul><h3 id="经典-Reactor-模式"><a href="#经典-Reactor-模式" class="headerlink" title="经典 Reactor 模式"></a>经典 Reactor 模式</h3><p>在Reactor模式中，包含如下角色</p><ul><li><strong>Reactor</strong> 将I&#x2F;O事件发派给对应的Handler</li><li><strong>Acceptor</strong> 处理客户端连接请求</li><li><strong>Handlers</strong> 执行非阻塞读&#x2F;写</li></ul><p><img src="http://www.jasongj.com/img/java/reactor/classic_reactor.png" alt="经典 Reactor 模式"> </p><p>调用 Selector 的静态工厂创建一个选择器，创建一个服务端的 Channel 绑定到一个 Socket 对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式</p><p>然后就可以调用 Selector 的 selectedKeys 方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 SelectionKey，通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据，而这里读取的数据是 Buffer，这个 Buffer 是我们可以控制的缓冲器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          <span class="type">ServerSocketChannel</span> <span class="variable">acceptServerSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">          <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">&quot;Accept request from &#123;&#125;&quot;</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">          <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">          <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">          <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">            key.cancel();</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Received invalide data, close the connection&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          LOGGER.info(<span class="string">&quot;Received message &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">        &#125;</span><br><span class="line">        keys.remove(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上示代码中可以看到，多个Channel可以注册到同一个Selector对象上，实现了一个线程同时监控多个请求状态(channel)</p><p>同时注册时需要指定它所关注的事件，例如上示代码中 <em>socketServerChannel</em> 对象只注册了 <em>OP_ACCEPT</em> 事件，而 <em>socketChannel</em> 对象只注册了 <em>OP_READ</em> 事件</p><p><code>selector.select()</code> 是阻塞的，当有至少一个通道可用时该方法返回可用通道个数。同时该方法只捕获Channel注册时指定的所关注的事件 </p><h3 id="多工作线程Reactor模式"><a href="#多工作线程Reactor模式" class="headerlink" title="多工作线程Reactor模式"></a>多工作线程Reactor模式</h3><p>经典Reactor模式中，尽管一个线程可同时监控多个请求(channel)，但是所有读&#x2F;写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势，同时读&#x2F;写操作也会阻塞对新连接请求的处理；因此可以引入多线程，并行处理多个读&#x2F;写操作 </p><p><img src="http://www.jasongj.com/img/java/reactor/multithread_reactor.png" alt="多工作线程Reactor模式"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(selector.selectNow() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          <span class="type">ServerSocketChannel</span> <span class="variable">acceptServerSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">          <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">&quot;Accept request from &#123;&#125;&quot;</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          <span class="type">SelectionKey</span> <span class="variable">readKey</span> <span class="operator">=</span> socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          readKey.attach(<span class="keyword">new</span> <span class="title class_">Processor</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          <span class="type">Processor</span> <span class="variable">processor</span> <span class="operator">=</span> (Processor) key.attachment();</span><br><span class="line">          processor.process(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上示代码中可以看到，注册完 SocketChannel 的 <em>OP_READ</em> 事件后，可以对相应的 SelectionKey attach 一个对象（本例中 attach 了一个 Processor 对象，该对象处理读请求），并且在获取到可读事件后，可以取出该对象</p><p>注：attach对象及取出该对象是 NIO 提供的一种操作，但该操作并非 Reactor 模式的必要操作，本文使用它，只是为了方便演示NIO的接口</p><p>具体的读请求处理在如下所示的 Processor 类中。该类中设置了一个静态的线程池处理所有请求。而 <em>process</em> 方法并不直接处理 I&#x2F;O 请求，而是把该 I&#x2F;O 操作提交给上述线程池去处理，这样就充分利用了多线程的优势，同时将对新连接的处理和读&#x2F;写操作的处理放在了不同的线程中，读&#x2F;写操作不再阻塞对新连接请求的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(Processor.class);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(SelectionKey selectionKey)</span> &#123;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">      <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        selectionKey.cancel();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125;\t Read ended&quot;</span>, socketChannel);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LOGGER.info(<span class="string">&quot;&#123;&#125;\t Read message &#123;&#125;&quot;</span>, socketChannel, <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多Reactor"><a href="#多Reactor" class="headerlink" title="多Reactor"></a>多Reactor</h3><p>Netty中使用的Reactor模式，引入了多Reactor，也即一个主Reactor负责监控所有的连接请求，多个子Reactor负责监控并处理读&#x2F;写请求，减轻了主Reactor的压力，降低了主Reactor压力太大而造成的延迟</p><p>并且每个子Reactor分别属于一个独立的线程，每个成功连接后的Channel的所有操作由同一个线程处理，这样保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换，同时也方便了监控请求响应状态 </p><p><img src="http://www.jasongj.com/img/java/reactor/multi_reactor.png" alt="多Reactor"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">coreNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    Processor[] processors = <span class="keyword">new</span> <span class="title class_">Processor</span>[coreNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; processors.length; i++) &#123;</span><br><span class="line">      processors[i] = <span class="keyword">new</span> <span class="title class_">Processor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      <span class="keyword">for</span> (SelectionKey key : keys) &#123;</span><br><span class="line">        keys.remove(key);</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          <span class="type">ServerSocketChannel</span> <span class="variable">acceptServerSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">          <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">&quot;Accept request from &#123;&#125;&quot;</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          <span class="type">Processor</span> <span class="variable">processor</span> <span class="operator">=</span> processors[(<span class="type">int</span>) ((index++) % coreNum)];</span><br><span class="line">          processor.addChannel(socketChannel);</span><br><span class="line">          processor.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，本文设置的子 Reactor 个数是当前机器可用核数的两倍（与 Netty 默认的子 Reactor 个数一致）</p><p>对于每个成功连接的 SocketChannel，通过 round robin 的方式交给不同的子 Reactor </p><p>子 Reactor 对 SocketChannel 的处理如下所示 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(Processor.class);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span></span><br><span class="line">      Executors.newFixedThreadPool(<span class="number">2</span> * Runtime.getRuntime().availableProcessors());</span><br><span class="line">  <span class="keyword">private</span> Selector selector;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Processor</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.selector = SelectorProvider.provider().openSelector();</span><br><span class="line">    start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> ClosedChannelException &#123;</span><br><span class="line">    socketChannel.register(<span class="built_in">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.selector.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selector.select(<span class="number">500</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">          iterator.remove();</span><br><span class="line">          <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              socketChannel.close();</span><br><span class="line">              key.cancel();</span><br><span class="line">              LOGGER.info(<span class="string">&quot;&#123;&#125;\t Read ended&quot;</span>, socketChannel);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">              LOGGER.info(<span class="string">&quot;&#123;&#125;\t Message size is 0&quot;</span>, socketChannel);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              LOGGER.info(<span class="string">&quot;&#123;&#125;\t Read message &#123;&#125;&quot;</span>, socketChannel, <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Processor中，同样创建了一个静态的线程池，且线程池的大小为机器核数的两倍</p><p>每个Processor实例均包含一个Selector实例，同时每次获取Processor实例时均提交一个任务到该线程池，并且该任务正常情况下一直循环处理，不会停止</p><p>而提交给该Processor的SocketChannel通过在其Selector注册事件，加入到相应的任务中，由此实现了每个子Reactor包含一个Selector对象，并由一个独立的线程处理 </p><h1 id="I-x2F-O-调优"><a href="#I-x2F-O-调优" class="headerlink" title="I&#x2F;O 调优"></a>I&#x2F;O 调优</h1><h3 id="磁盘-I-x2F-O-优化"><a href="#磁盘-I-x2F-O-优化" class="headerlink" title="磁盘 I&#x2F;O 优化"></a>磁盘 I&#x2F;O 优化</h3><p>提升磁盘 I&#x2F;O 性能通常的方法有：</p><ol><li>增加缓存，减少磁盘访问次数</li><li>优化磁盘的管理系统，设计最优的磁盘访问策略，以及磁盘的寻址策略，这里是在底层操作系统层面考虑的。</li><li>设计合理的磁盘存储数据块，以及访问这些数据块的策略，这里是在应用层面考虑的。如我们可以给存放的数据设计索引，通过寻址索引来加快和减少磁盘的访问，还有可以采用异步和非阻塞的方式加快磁盘的访问效率。</li><li>应用合理的 RAID 策略提升磁盘 IO，每种 RAID 的区别我们可以用下表所示：</li></ol><table><thead><tr><th><strong>磁盘阵列</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>RAID 0</td><td>数据被平均写到多个磁盘阵列中，写数据和读数据都是并行的，所以磁盘的 IOPS 可以提高一倍。</td></tr><tr><td>RAID 1</td><td>RAID 1 的主要作用是能够提高数据的安全性，它将一份数据分别复制到多个磁盘阵列中。并不能提升 IOPS 但是相同的数据有多个备份。通常用于对数据安全性较高的场合中。</td></tr><tr><td>RAID 5</td><td>这中设计方式是前两种的折中方式，它将数据平均写到所有磁盘阵列总数减一的磁盘中，往另外一个磁盘中写入这份数据的奇偶校验信息。如果其中一个磁盘损坏，可以通过其它磁盘的数据和这个数据的奇偶校验信息来恢复这份数据。</td></tr><tr><td>RAID 0+1</td><td>如名字一样，就是根据数据的备份情况进行分组，一份数据同时写到多个备份磁盘分组中，同时多个分组也会并行读写。</td></tr></tbody></table><h3 id="网络-I-x2F-O-优化"><a href="#网络-I-x2F-O-优化" class="headerlink" title="网络 I&#x2F;O 优化"></a>网络 I&#x2F;O 优化</h3><p>网络 I&#x2F;O 优化通常有一些基本处理原则：</p><ol><li>一个是减少网络交互的次数：要减少网络交互的次数通常我们在需要网络交互的两端会设置缓存，比如 Oracle 的 JDBC 驱动程序，就提供了对查询的 SQL 结果的缓存，在客户端和数据库端都有，可以有效的减少对数据库的访问</li><li>除了设置缓存还有一个办法是，合并访问请求：如在查询数据库时，我们要查 10 个 id，我可以每次查一个 id，也可以一次查 10 个 id。再比如在访问一个页面时通过会有多个 js 或 css 的文件，我们可以将多个 js 文件合并在一个 HTTP 链接中，每个文件用逗号隔开，然后发送到后端 Web 服务器根据这个 URL 链接，再拆分出各个文件，然后打包再一并发回给前端浏览器。这些都是常用的减少网络 I&#x2F;O 的办法</li><li>减少网络传输数据量的大小：减少网络数据量的办法通常是将数据压缩后再传输，如 HTTP 请求中，通常 Web 服务器将请求的 Web 页面 gzip 压缩后在传输给浏览器。还有就是通过设计简单的协议，尽量通过读取协议头来获取有用的价值信息。比如在代理程序设计时，有 4 层代理和 7 层代理都是来尽量避免要读取整个通信数据来取得需要的信息。</li><li>尽量减少编码：通常在网络 I&#x2F;O 中数据传输都是以字节形式的，也就是通常要序列化。但是我们发送要传输的数据都是字符形式的，从字符到字节必须编码。但是这个编码过程是比较耗时的，所以在要经过网络 I&#x2F;O 传输时，尽量直接以字节形式发送。也就是尽量提前将字符转化为字节，或者减少字符到字节的转化过程</li><li>根据应用场景设计合适的交互方式：主要包括同步与异步阻塞与非阻塞方式</li></ol><hr><p>参考资料</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html">深入分析 Java I&#x2F;O 的工作机制</a> </p><p><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">NIO 入门</a> </p><p><a href="http://www.jasongj.com/java/nio_reactor">NIO Reactor I&#x2F;O模型 | 技术世界</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种背包问题</title>
      <link href="/2018-08-08-%E4%B8%89%E7%A7%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"/>
      <url>/2018-08-08-%E4%B8%89%E7%A7%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="背包九-三-讲"><a href="#背包九-三-讲" class="headerlink" title="背包九(三)讲"></a>背包九(三)讲</h1><h2 id="1-01背包"><a href="#1-01背包" class="headerlink" title="1. 01背包"></a>1. 01背包</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有 N 件物品和一个容量为 S 的背包。第 i 件物品的费用是 c[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h3 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h3><p>$$<br>state[i][v] &#x3D; max { state[i-1][v], state[i-1][v-c[i]]+v[i] }<br>$$</p><p>state[i][v]：只使用前 i 件物品，总花费刚好为 v 时的总价值</p><p>若包括第 i 个物品，则 state[i][v] &#x3D; state[i-1][v-c[i]] + v[i]</p><p>若不包括第 i 个物品，则 state[i][v] &#x3D; state[i-1][v]</p><p>最后要遍历 state[N-1][v], 最大的值即为答案</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：O(NS)</p><p>空间复杂度：O(NS)</p><h3 id="优化后的状态方程"><a href="#优化后的状态方程" class="headerlink" title="优化后的状态方程"></a>优化后的状态方程</h3><p>观察状态方程，state[i] 只用到了state[i-1] 的数据，可以压缩行数，相当于用 state[i] 的值覆盖 state[i-1]的值<br>$$<br>state[v] &#x3D; max { state[v], state[v-c[i]]+v[i] }<br>$$<br>还是 i 从 0 到 N-1 遍历，只是 v 要从 S 到 0 遍历，在更新时前面的值对应 i-1 时的情况</p><p>最后要遍历 state[v]， 最大的值即为答案</p><h3 id="优化后的复杂度"><a href="#优化后的复杂度" class="headerlink" title="优化后的复杂度"></a>优化后的复杂度</h3><p>时间复杂度：O(NS)</p><p>空间复杂度：O(S)</p><h2 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2. 完全背包问题"></a>2. 完全背包问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>有 N 种物品和一个容量为 S 的背包，每种物品都有无限件可用。第 i 种物品的费用是 c[i]，价值是 w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h3 id="状态方程-1"><a href="#状态方程-1" class="headerlink" title="状态方程"></a>状态方程</h3><p>$$<br>state[i][v] &#x3D; max { state[i-1][v-k<em>c[i]]+k</em>v[i] | 0 &lt;&#x3D; k*c[i] &lt;&#x3D; v }<br>$$</p><p>$$<br>state[i][v] &#x3D; max { state[i-1][v], state[i][v-c[i]]+v[i] }<br>$$</p><p>tips：删掉这样的物品 a：存在物品 b，满足 c[b] &lt; c[a] 且 w[b]&#x2F;c[b] &gt; w[a]&#x2F;c[a]</p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：&gt;O(NS)</p><p>空间复杂度：O(NS)</p><h3 id="优化后的状态方程-1"><a href="#优化后的状态方程-1" class="headerlink" title="优化后的状态方程"></a>优化后的状态方程</h3><p>在遍历到 i 的时候，max() 的参数的 state[] 可能已经含有了物品 i<br>$$<br>state[v] &#x3D; max { state[v], state[v-c[i]]+v[i] }<br>$$<br>i 从 0 到 N-1 遍历，v 要从 0 到 S 遍历</p><h3 id="优化后的复杂度-1"><a href="#优化后的复杂度-1" class="headerlink" title="优化后的复杂度"></a>优化后的复杂度</h3><p>时间复杂度：O(NS)</p><p>空间复杂度：O(S)</p><h2 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3. 多重背包问题"></a>3. 多重背包问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>有 N 种物品和一个容量为 S 的背包。第 i 种物品最多有 n[i] 件可用，每件费用是 c[i]，价值是 w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p><h3 id="状态方程-2"><a href="#状态方程-2" class="headerlink" title="状态方程"></a>状态方程</h3><p>可以把相同的物品当成01背包中不同的物品</p><p>转化出新的数组后：<br>$$<br>state[v] &#x3D; max { state[v], state[v-c[i]]+v[i] }<br>$$</p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：O( Σn[i]·S)</p><p>空间复杂度：O(S)</p><h3 id="优化后的状态方程-2"><a href="#优化后的状态方程-2" class="headerlink" title="优化后的状态方程"></a>优化后的状态方程</h3><p>优化前，n[i] 件相同的物品转化成 n[i] 个对应的值</p><p>用二进制思想，把 n[i] 件相同的物品转化成 logn[i] 个对应的值</p><p>例如，13 个相同的物品转化成 1 个费用 c[i]，价值 w[i] 的物品，加 1 个费用 2*c[i]，价值 2*w[i] 的物品，加 1 个 费用 4*c[i]，价值 4*w[i] 的物品，加 1 个费用 6*c[i]，价值 6*c[i] 的物品</p><h3 id="优化后的复杂度-2"><a href="#优化后的复杂度-2" class="headerlink" title="优化后的复杂度"></a>优化后的复杂度</h3><p>时间复杂度：O( Σlogn[i]·S)</p><p>空间复杂度：O(S)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的this</title>
      <link href="/2018-07-09-js%E4%B8%AD%E7%9A%84this.html"/>
      <url>/2018-07-09-js%E4%B8%AD%E7%9A%84this.html</url>
      
        <content type="html"><![CDATA[<h1 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h1><p>this 的 scope 由函数&#x2F;类分隔</p><h1 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h1><p>普通函数即用 函数声明 或 函数表达式 定义的函数</p><p>把所有函数调用都转换成显式的 <code>call()</code> 调用</p><h3 id="Function-Invocation-Pattern"><a href="#Function-Invocation-Pattern" class="headerlink" title="Function Invocation Pattern"></a>Function Invocation Pattern</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// foo.call(undefined);</span></span><br></pre></td></tr></table></figure><p>在<strong>默认模式</strong>下当你传的 context 为 undefined 时，默认的 context为Global对象，在<strong>浏览器</strong>中就是window对象</p><p>在<strong>strict模式</strong>下此时 this 即为 undefined</p><h3 id="Method-Invocation-Pattern"><a href="#Method-Invocation-Pattern" class="headerlink" title="Method Invocation Pattern"></a>Method Invocation Pattern</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">// obj.foo.call(obj)</span></span><br></pre></td></tr></table></figure><h3 id="Constructor-Pattern"><a href="#Constructor-Pattern" class="headerlink" title="Constructor Pattern"></a>Constructor Pattern</h3><p>foo函数内部的this永远是new foo()返回的对象 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="keyword">class</span> &#123;</span><br><span class="line">    foo () &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.<span class="title function_">foo</span>(); <span class="comment">// c.foo5.call(c);</span></span><br></pre></td></tr></table></figure><h3 id="Apply-Pattern"><a href="#Apply-Pattern" class="headerlink" title="Apply Pattern"></a>Apply Pattern</h3><p>call() 方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个<strong>参数的列表</strong>，而 apply() 方法接受的是一个包含多个<strong>参数的数组</strong></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>在箭头函数出现之前，每个新定义的函数都有它自己的 <code>this</code> 值，<code>this</code> 被证明是令人厌烦的面向对象风格的编程</p><p>在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a> 中，<code>this</code> 与封闭词法上下文的 <code>this</code> 保持一致。 </p><p>箭头函数在设计中使用的是Lexical this，即这个函数被创建时的 <code>this</code> 就是函数内部的 <code>this</code></p><p>需要注意的是，函数创建时并不是读代码的人第一次肉眼能看到这个函数的时候</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">foo1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">let</span> foo2 = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); &#125;;</span><br><span class="line">    <span class="title function_">foo1</span>();</span><br><span class="line">    <span class="title function_">foo2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"><span class="comment">// undefined, undefined</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="string">&#x27;nico&#x27;</span>);</span><br><span class="line"><span class="comment">// nico, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    <span class="attr">foo3</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>),</span><br><span class="line">    <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">b.<span class="title function_">foo3</span>();</span><br><span class="line"><span class="comment">// Window &#123;...&#125;</span></span><br><span class="line">b.<span class="title function_">foo4</span>();</span><br><span class="line"><span class="comment">// &#123; foo3: f, foo4, f&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="keyword">class</span> &#123;</span><br><span class="line">    foo5 () &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.<span class="title function_">foo5</span>();</span><br><span class="line"><span class="comment">// &#123; &#125;</span></span><br></pre></td></tr></table></figure><hr><p><strong>参考资料</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">this - JavaScript | MDN</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数 - JavaScript | MDN</a></p><p><a href="https://www.zhihu.com/question/19636194">如何理解 JavaScript 中的 this 关键字？ - 知乎</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA中对使用Maven的工程打包</title>
      <link href="/2018-06-25-IDEA%E4%B8%AD%E5%AF%B9%E4%BD%BF%E7%94%A8Maven%E7%9A%84%E5%B7%A5%E7%A8%8B%E6%89%93%E5%8C%85.html"/>
      <url>/2018-06-25-IDEA%E4%B8%AD%E5%AF%B9%E4%BD%BF%E7%94%A8Maven%E7%9A%84%E5%B7%A5%E7%A8%8B%E6%89%93%E5%8C%85.html</url>
      
        <content type="html"><![CDATA[<p>如果 <strong>工程的 META-INF 信息没有在工程的根目录下生成</strong> ，则直接使用 IDEA 打包 jar 文件时，会从 Maven 中获取配置信息；</p><p>如果 <strong>此时</strong> <code>pom.xml</code> <strong>中也没有完整的打包配置</strong>，则会读取默认的信息。</p><p>此时，打包出的 jar 文件的 META-INF 不包括启动类的名称，无法直接运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -jar Nico.jar</span><br><span class="line">Nico.jar中没有主清单属性</span><br></pre></td></tr></table></figure><h1 id="Spring-Boot应用打包逻辑"><a href="#Spring-Boot应用打包逻辑" class="headerlink" title="Spring Boot应用打包逻辑"></a>Spring Boot应用打包逻辑</h1><p><a href="https://incoder.org/2019/06/23/springboot1/#Spring-%E6%89%93%E5%8C%85">SpringBoot（一） 初识 | BladeCode</a><br><a href="https://incoder.org/2019/07/05/springboot2/">SpringBoot（二） 启动分析JarLauncher | BladeCode</a><br><a href="https://incoder.org/2020/02/02/springboot5/">SpringBoot（五）多环境配置 | BladeCode</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java同名内部类的 NoClassDefFoundError</title>
      <link href="/2018-06-14-Java%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84NoClassDefFoundError.html"/>
      <url>/2018-06-14-Java%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84NoClassDefFoundError.html</url>
      
        <content type="html"><![CDATA[<p>Windows 不区分文件名的大小写，因此你无法在同一个包中创建两个除大小写外类名完全相同的 Java 文件，但是内部类可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fuck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FuckYou</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Fuckyou</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Fuck</span>.FuckYou();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且这段代码可以通过编译，只有在运行时才会抛出异常:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: Fuck$FuckYou (wrong name: Fuck$Fuckyou)</span><br></pre></td></tr></table></figure><p>当然，正常人不会去写这样的代码，但是用一些生成工具（例如antlr）生成代码时，就有可能出现内部类类名撞车的风险。这个时候，你需要仔细读异常信息：一个类是 <code>Fuck$FuckYou</code> 而另一个是 <code>Fuck$Fuckyou</code> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring入门</title>
      <link href="/2018-05-23-Spring%E5%85%A5%E9%97%A8.html"/>
      <url>/2018-05-23-Spring%E5%85%A5%E9%97%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>添加 maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Ioc容器"><a href="#Ioc容器" class="headerlink" title="Ioc容器"></a>Ioc容器</h1><p>Spring 的 <strong>ApplicationContext</strong> 容器</p><p>最常被使用的 <strong>ApplicationContext</strong> 接口实现：</p><ul><li><strong>FileSystemXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径</li><li><strong>ClassPathXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</li><li><strong>WebXmlApplicationContext</strong>：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</li></ul><h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h3 id="Bean的属性"><a href="#Bean的属性" class="headerlink" title="Bean的属性"></a>Bean的属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>class</td><td>这个属性是强制性的，并且指定用来创建 bean 的 bean 类。</td></tr><tr><td>name</td><td>这个属性指定唯一的 bean 标识符。在基于 XML 的配置元数据中，你可以使用 ID 和&#x2F;或 name 属性来指定 bean 标识符。</td></tr><tr><td>scope</td><td>singleton &#x2F; prototype</td></tr><tr><td>constructor-arg</td><td>注入依赖关系</td></tr><tr><td>properties</td><td>注入依赖关系</td></tr><tr><td>autowiring mode</td><td>byType &#x2F; byName</td></tr><tr><td>lazy-initialization mode</td><td>延迟初始化的 bean 告诉 IoC 容器在它第一次被请求时，而不是在启动时去创建一个 bean 实例。</td></tr><tr><td>initialization 方法</td><td>在 bean 的所有必需的属性被容器设置之后，调用回调方法</td></tr><tr><td>destruction 方法</td><td>当包含该 bean 的容器被销毁时，使用回调方法</td></tr></tbody></table><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>实现 BeanPostProcessor 接口</p><p>调用顺序：</p><ol><li>BeanPostProcessor.postProcessBeforeInitialization</li><li>init-method</li><li>BeanPostProcessor.postProcessAfterInitialization</li></ol><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>强制</p><h3 id="setter函数"><a href="#setter函数" class="headerlink" title="setter函数"></a>setter函数</h3><p>非强制</p><h1 id="配置方法：注解"><a href="#配置方法：注解" class="headerlink" title="配置方法：注解"></a>配置方法：注解</h1><p>xml 文件中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h3><ul><li>修饰setter方法<br>表示该属性必须设置</li></ul><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><ul><li><p>修饰setter方法</p><p>执行 byType 自动连接</p></li><li><p>修饰属性</p><p>省略该属性的setter函数，执行 byType 自动连接</p></li><li><p>修饰构造函数</p><p>执行 constructor 自动连接</p></li></ul><p>默认 @Autowired 包括 @Required ，可以使用 @Autowired (required &#x3D; false) 取消</p><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><ul><li><p>修饰属性</p><p>在有多个相同类型的 Bean 的情况下，指定装配 id 的那个</p></li></ul><h3 id="PostConstruct-PreDestroy"><a href="#PostConstruct-PreDestroy" class="headerlink" title="@PostConstruct @PreDestroy"></a>@PostConstruct @PreDestroy</h3><ul><li><p>修饰方法</p><p>声明 <strong>init-method</strong> 和 <strong>destroy-method</strong> 方法</p></li></ul><h1 id="配置方法：Java"><a href="#配置方法：Java" class="headerlink" title="配置方法：Java"></a>配置方法：Java</h1><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><ul><li><p>修饰类</p><p>声明该类是配置类</p></li></ul><h3 id="Bean-1"><a href="#Bean-1" class="headerlink" title="@Bean"></a>@Bean</h3><ul><li><p>修饰方法</p><p>表明该方法返回一个Bean</p></li></ul><p>Java 配置方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldConfig</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span> <span class="comment">// 方法名就是Bean的id</span></span><br><span class="line">   <span class="keyword">public</span> HelloWorld <span class="title function_">helloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于对应的 xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;HelloWorld&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">   ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line">   <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><ul><li><p>修饰配置类</p><p>导入所需的其他Bean的配置类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigA.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConfigB.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> B <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// App.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> </span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigB.class);</span><br><span class="line">   <span class="comment">// now both beans A and B will be available...</span></span><br><span class="line">   <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> ctx.getBean(A.class);</span><br><span class="line">   <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><ul><li><p>修饰返回Bean的方法</p><p>和 xml 中作用相同</p></li></ul><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>通过 <strong>ApplicationEvent</strong> 类和 <strong>ApplicationListener</strong> 接口来提供在 <strong>ApplicationContext</strong> 中处理事件。 </p><table><thead><tr><th>序号</th><th>Spring 内置事件 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>ContextRefreshedEvent</strong><em>ApplicationContext</em> 被初始化或刷新时，该事件被发布。这也可以在 <em>ConfigurableApplicationContext</em>接口中使用 refresh() 方法来发生。</td></tr><tr><td>2</td><td><strong>ContextStartedEvent</strong>当使用 <em>ConfigurableApplicationContext</em> 接口中的 start() 方法启动 <em>ApplicationContext</em> 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</td></tr><tr><td>3</td><td><strong>ContextStoppedEvent</strong>当使用 <em>ConfigurableApplicationContext</em> 接口中的 stop() 方法停止 <em>ApplicationContext</em> 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</td></tr><tr><td>4</td><td><strong>ContextClosedEvent</strong>当使用 <em>ConfigurableApplicationContext</em> 接口中的 close() 方法关闭 <em>ApplicationContext</em> 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</td></tr><tr><td>5</td><td><strong>RequestHandledEvent</strong>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainApp.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">      context.start();</span><br><span class="line"></span><br><span class="line">      <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) context.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">      obj.getMessage();</span><br><span class="line"></span><br><span class="line">      context.stop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CStartEventHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CStartEventHandler</span> </span><br><span class="line">   <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextStartedEvent&gt;&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextStartedEvent event)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;ContextStartedEvent Received&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料</p><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html">Core Technologies</a> 这是官网的官方文档，找了好久才找到ORZ：<a href="https://spring.io/">https://spring.io</a> -&gt; projects -&gt; spring framework -&gt; features -&gt; core technologies，看来官方已经默认没有noob会从官网开始学习spring了</p><p><a href="http://wiki.jikexueyuan.com/project/spring">Spring教程_极客学院Wiki</a></p><p><a href="https://www.tutorialspoint.com/spring/index.htm">Spring Tutorial</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》ch5-神经网络</title>
      <link href="/2018-05-14-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8Bch5-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html"/>
      <url>/2018-05-14-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8Bch5-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》ch4-决策树</title>
      <link href="/2018-05-14-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8Bch4-%E5%86%B3%E7%AD%96%E6%A0%91.html"/>
      <url>/2018-05-14-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8Bch4-%E5%86%B3%E7%AD%96%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D 训练集, A 属性集</span></span><br><span class="line"><span class="title class_">GenerateTree</span> (D, A) &#123;</span><br><span class="line">    node = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">if</span> (D剩下的样本输入的x完 全 一 致) &#123;</span><br><span class="line">        node.<span class="property">y</span> = D中占多数的y;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    选择划分属性a <span class="comment">// optional: 预剪枝</span></span><br><span class="line">    <span class="keyword">for</span> a的每个变量</span><br><span class="line">        node.<span class="property">children</span>.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">        <span class="keyword">if</span> (D中没有这个变量) &#123;</span><br><span class="line">            node.<span class="property">currentChildren</span>.<span class="property">y</span> = D中占多数的y;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.<span class="property">currentChildren</span>.<span class="property">y</span> = <span class="title class_">GenerateTree</span>(D, A-a);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h1><h3 id="信息熵-amp-信息增益"><a href="#信息熵-amp-信息增益" class="headerlink" title="信息熵&amp;信息增益"></a>信息熵&amp;信息增益</h3><p>Ent(D)越小，D纯度越高 （按y划分）</p><p>Gain(D, a) 越大，使用属性a进行划分的纯度提升越大</p><p>eg: ID3算法</p><h3 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h3><p>Gain_ratio(D, a)越大，使用属性a进行划分的纯度提升越大，并且泛化性能越好</p><p>偏好数目较少的属性，因此一般先用Gain再用Gain_radio</p><p>eg: C4.5</p><h1 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h1><p>防止过拟合，提升泛化性能</p><h3 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h3><p>选择划分属性时：用测试集比较划分前后的准确率</p><p>优点：提高效率</p><p>缺点：本质贪心，可能欠拟合</p><h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><p>生成了决策树之后，对每个节点判断比较</p><p>优点：准确率高</p><p>缺点：效率低</p><h1 id="连续与缺失值"><a href="#连续与缺失值" class="headerlink" title="连续与缺失值"></a>连续与缺失值</h1><h3 id="连续值"><a href="#连续值" class="headerlink" title="连续值"></a>连续值</h3><p>样本中的n个值，取n-1个中间值，转化成离散值，测试生成的树的效率，最后取其中一个值</p><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><ol><li>选择划分属性：按已知的信息划分</li><li>给每个样本增加权重变量w，缺失属性在划分时w按照已知属性的比例减小，并且划分到每个子节点</li></ol><h1 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h1><p>多个属性之间有关联</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程安全</title>
      <link href="/2018-04-29-Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.html"/>
      <url>/2018-04-29-Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法时进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果</p><h1 id="程度"><a href="#程度" class="headerlink" title="程度"></a>程度</h1><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>immutable 的对象一定是线程安全的，例如 String</p><h3 id="绝对的线程安全"><a href="#绝对的线程安全" class="headerlink" title="绝对的线程安全"></a>绝对的线程安全</h3><p>不存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即使是 Vector 也会无法同步，如果要保证线程安全需要在 run() 中加入 synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hoho</span> <span class="operator">=</span> <span class="number">0</span>; hoho &lt; <span class="number">50</span>; ++hoho) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">removeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); ++i) &#123;</span><br><span class="line">                    vector.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">printThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); ++i) &#123;</span><br><span class="line">                    System.out.print(vector.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) ;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相对的线程安全"><a href="#相对的线程安全" class="headerlink" title="相对的线程安全"></a>相对的线程安全</h3><p>Vector, HashTable</p><h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>需要调用方手动实现线程安全，大部分类</p><h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>Thread.suspend() 和 Thread.resume() ，已被废弃</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h3 id="互斥同步-Mutual-Exclusion-amp-Blocking-Synchronization"><a href="#互斥同步-Mutual-Exclusion-amp-Blocking-Synchronization" class="headerlink" title="互斥同步 Mutual Exclusion &amp; Blocking Synchronization"></a>互斥同步 Mutual Exclusion &amp; Blocking Synchronization</h3><p><strong>synchronized</strong></p><p>monitorexit, monitorenter</p><p>开销大；JDK1.6之后优化到和ReentrantLock性能相近</p><p><strong>ReentrantLock</strong></p><p>java.util.concurrent 包中的 ReentrantLock </p><ol><li>等待可中断</li><li>公平锁</li><li>锁可以绑定多个条件</li></ol><h3 id="非阻塞同步-Non-Blocking-Synchronization"><a href="#非阻塞同步-Non-Blocking-Synchronization" class="headerlink" title="非阻塞同步 Non-Blocking Synchronization"></a>非阻塞同步 Non-Blocking Synchronization</h3><p>基于硬件指令集的发展，先操作，再检测是否产生冲突</p><p>java.util.concurrent.AtomicInteger -&gt; sun.misc.Unsafe -&gt; CAS指令</p><h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p><strong>可重入代码</strong></p><p><strong>线程本地存储 Thread Local Storage</strong></p><p>java.lang.ThreadLocal 类中的key-value对</p><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p>适用场景：</p><ol><li>布尔状态标志</li><li>单例模式的实例</li><li>volatile bean 模式</li></ol><hr><p>参考资料</p><p>《深入理解Java虚拟机》第12章，第13章</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html">Java 理论与实践: 正确使用 Volatile 变量</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》ch2.模型评估与选择</title>
      <link href="/2018-04-26-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8Bch2-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9.html"/>
      <url>/2018-04-26-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8Bch2-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9.html</url>
      
        <content type="html"><![CDATA[<h1 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h1><h3 id="留出法"><a href="#留出法" class="headerlink" title="留出法"></a>留出法</h3><p>两个互斥集合</p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>k阶交叉验证</p><h3 id="自助法"><a href="#自助法" class="headerlink" title="自助法"></a>自助法</h3><p>随机采样</p><h1 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h1><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><ol><li>均方误差</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>错误率、精度</li><li>查准率、查全率；P-R图、BEP；</li><li>ROC，AUC</li><li>代价敏感错误率、代价曲线 （加权）</li></ol><h1 id="统计假设检验"><a href="#统计假设检验" class="headerlink" title="统计假设检验"></a>统计假设检验</h1><h3 id="二项检验、t分布检验"><a href="#二项检验、t分布检验" class="headerlink" title="二项检验、t分布检验"></a>二项检验、t分布检验</h3><p>对单个学习期泛化性能假设的检验</p><h3 id="交叉验证t检验"><a href="#交叉验证t检验" class="headerlink" title="交叉验证t检验"></a>交叉验证t检验</h3><p>比较两个学习器</p><h3 id="McNemar检验"><a href="#McNemar检验" class="headerlink" title="McNemar检验"></a>McNemar检验</h3><p>二分类问题，比较两个学习器</p><h3 id="Friedman检验、Nemenyi检验"><a href="#Friedman检验、Nemenyi检验" class="headerlink" title="Friedman检验、Nemenyi检验"></a>Friedman检验、Nemenyi检验</h3><p>Friedman比较多个学习器，Nemenyi后续检验</p><h3 id="偏差、方差"><a href="#偏差、方差" class="headerlink" title="偏差、方差"></a>偏差、方差</h3><p>偏差：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力</p><p>方差：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响</p><p>噪声：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》ch1.绪论</title>
      <link href="/2018-04-26-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8Bch1-%E7%BB%AA%E8%AE%BA.html"/>
      <url>/2018-04-26-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8Bch1-%E7%BB%AA%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><ol><li>推理期</li><li>知识期</li><li>机器学习</li></ol><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>从样例中学习</p><ol><li>符号主义学习：决策树，基于逻辑的学习</li><li>连接主义学习：神经网络 -&gt; 深度学习</li><li>统计学习：支持向量机，核方法</li></ol><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>监督学习<ol><li>离散值：分类</li><li>连续值：回归</li></ol></li><li>无监督学习<ol><li>聚类</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaFX入门</title>
      <link href="/2018-03-07-JavaFX%E4%BB%8B%E7%BB%8D.html"/>
      <url>/2018-03-07-JavaFX%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>如果使用IntelliJ IDEA创建一个JavaFX项目，会默认创建 <code>Main.java</code> <code>Controller.java</code> <code>sample.fxml</code> ，这也是JavaFX一个明显的特性：可以使用fxml文件与css文件编辑界面</p><h1 id="编辑界面"><a href="#编辑界面" class="headerlink" title="编辑界面"></a>编辑界面</h1><p>在 <code>sample.fxml</code> 中使用xml语言编辑界面，可使用 <code>javafx.scene.layout</code> 库中的所有元素，参考 <a href="https://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html">Introduction to FXML | JavaFX 2.2</a> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?import javafx.scene.control.Button?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">VBox</span> <span class="attr">fx:id</span>=<span class="string">&quot;body&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fx:controller</span>=<span class="string">&quot;miniCAD.Controller&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:fx</span>=<span class="string">&quot;http://javafx.com/fxml&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MenuBar</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Menu</span> <span class="attr">fx:id</span>=<span class="string">&quot;menuFile&quot;</span> <span class="attr">text</span>=<span class="string">&quot;File&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">fx:id</span>=<span class="string">&quot;itemOpen&quot;</span> <span class="attr">text</span>=<span class="string">&quot;Open&quot;</span> <span class="attr">onAction</span>=<span class="string">&quot;#itemOpenClicked&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">fx:id</span>=<span class="string">&quot;itemSave&quot;</span> <span class="attr">text</span>=<span class="string">&quot;Save&quot;</span> <span class="attr">onAction</span>=<span class="string">&quot;#itemSaveClicked&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">MenuBar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HBox</span> <span class="attr">fx:id</span>=<span class="string">&quot;toolBox&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FlowPane</span> <span class="attr">fx:id</span>=<span class="string">&quot;shape&quot;</span> <span class="attr">styleClass</span>=<span class="string">&quot;tool&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">fx:id</span>=<span class="string">&quot;buttonLine&quot;</span> <span class="attr">onAction</span>=<span class="string">&quot;#buttonLineClicked&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">fx:id</span>=<span class="string">&quot;buttonRectangle&quot;</span> <span class="attr">onAction</span>=<span class="string">&quot;#buttonRectangleClicked&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">FlowPane</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Separator</span> <span class="attr">orientation</span>=<span class="string">&quot;VERTICAL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FlowPane</span> <span class="attr">fx:id</span>=<span class="string">&quot;size&quot;</span> <span class="attr">styleClass</span>=<span class="string">&quot;tool&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">fx:id</span>=<span class="string">&quot;buttonBigger&quot;</span> <span class="attr">onAction</span>=<span class="string">&quot;#buttonBiggerClicked&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">fx:id</span>=<span class="string">&quot;buttonSmaller&quot;</span> <span class="attr">onAction</span>=<span class="string">&quot;#buttonSmallerClicked&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">FlowPane</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">HBox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">VBox</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">fx:id</span>=<span class="string">&quot;itemOpen&quot;</span> <span class="attr">text</span>=<span class="string">&quot;Open&quot;</span> <span class="attr">onAction</span>=<span class="string">&quot;#itemOpenClicked&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>相当于Java程序中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MenuItem</span> <span class="variable">itemOpen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">itemOpen.addActionListener(actionEvent -&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="补全代码"><a href="#补全代码" class="headerlink" title="补全代码"></a>补全代码</h1><p>然后在 <code>Controller.java</code> 中补全设计界面时命名的元素和函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FXML</span></span><br><span class="line">VBox body;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buttonTextClick</span><span class="params">(ActionEvent actionEvent)</span> &#123; &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h1 id="使用CSS"><a href="#使用CSS" class="headerlink" title="使用CSS"></a>使用CSS</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">VBox</span> <span class="attr">fx:id</span>=<span class="string">&quot;body&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">fx:controller</span>=<span class="string">&quot;miniCAD.Controller&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">stylesheets</span>=<span class="string">&quot;/miniCAD/miniCAD.css&quot;</span> &lt;!<span class="attr">--</span> <span class="attr">this</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">      xmlns:fx=&quot;http://javafx.com/fxml&quot;&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">VBox</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的css文件中属性均以-fx-开头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#body</span> &#123;</span><br><span class="line">    -fx-pref-<span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">    -fx-pref-<span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    -fx-spacing: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">Button</span> &#123;</span><br><span class="line">    -fx-<span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">FlowPane &#123;</span><br><span class="line">    -fx-hgap: <span class="number">2px</span>;</span><br><span class="line">    -fx-vgap: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>实例项目</p><p><a href="https://github.com/hahahaha123567/mini-cad">mini-cad</a></p><p>参考资料</p><p><a href="https://www.jetbrains.com/help/idea/javafx.html">JavaFX - Help | IntelliJ IDEA</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaFX中的table相关</title>
      <link href="/2018-03-07-JavaFX%E4%B8%AD%E7%9A%84table%E7%9B%B8%E5%85%B3.html"/>
      <url>/2018-03-07-JavaFX%E4%B8%AD%E7%9A%84table%E7%9B%B8%E5%85%B3.html</url>
      
        <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>JavaFX中实现一个table需要实现两个类：<code>TableView</code> , <code>TableColumn</code> </p><p>此外，还要将放入表格中的数据（每行是一个对象）用一个自定义的类表示。在JavaFX中，这个自定义类可以使用property属性绑定</p><p>为了将TableColumn的对象和数据对象进行关联，需要使用 <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/control/TableColumn.html#cellValueFactoryProperty%28%29">Cell Value Factory</a> 和 <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/control/TableColumn.html#cellFactoryProperty%28%29">Cell Factory</a> </p><blockquote><p>setCellFactory的意图是在创建这列的时候要做的事情，你可以改变TableCell的任何内容，包括UI和Value，而setCellValueFactory呢，它的重点是关联属性，从你传递给它的Model中通过对应属性的getter来获取值。在setCellFactory中的TableCell有个回调，叫<code>updateItem</code>，它可以获取到你设置到此Cell的值，这个值是跟setCellValueFactory所关联的属性有关。</p></blockquote><h1 id="固定属性"><a href="#固定属性" class="headerlink" title="固定属性"></a>固定属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SimpleStringProperty p1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SimpleStringProperty p2;</span><br><span class="line">  Data (String s1, String s2) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TableView</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableView</span>();</span><br><span class="line"><span class="type">TableColumn</span> <span class="variable">column1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableColumn</span>(<span class="string">&quot;c1&quot;</span>);</span><br><span class="line"><span class="type">TableColumn</span> <span class="variable">column2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableColumn</span>(<span class="string">&quot;c2&quot;</span>);</span><br><span class="line">table.getColumns().addAll(column1, column2);</span><br><span class="line"></span><br><span class="line">column1.setCellValueFactory(<span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;Data, String&gt;(<span class="string">&quot;p1&quot;</span>));</span><br><span class="line">column2.setCellValueFactory(<span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;Data, String&gt;(<span class="string">&quot;p2&quot;</span>));</span><br><span class="line"></span><br><span class="line">ObservableList&lt;Person&gt; dataList = FXCollections.observableArrayList(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Data</span>(<span class="string">&quot;Nico&quot;</span>, <span class="string">&quot;Maki&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Data</span>(<span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hoho&quot;</span>)</span><br><span class="line">);</span><br><span class="line">table.setItems(dataList);</span><br></pre></td></tr></table></figure><h1 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h1><p>在写 <a href="https://github.com/hahahaha123567/csv-editor">CSV editor</a> 时，显然table的行列数都是不确定的，因此不能按照上述步骤。TableColumn可以根据需要创建，但是绑定column和数据需要进行改动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column.setCellValueFactory(param -&gt; param.getValue().get(ii));</span><br></pre></td></tr></table></figure><p>这里的参数不能继续使用PropertyValueFactory的对象，而应该用index去获取ObservableList的值</p><p>应用可以参考 <a href="https://github.com/hahahaha123567/csv-editor/blob/master/src/csv/Controller.java">这段代码</a> 的showData()函数</p><hr><p>参考资料</p><p><a href="http://cmlanche.com/2017/06/08/JavaFx-TableView%E8%AF%A6%E8%A7%A3/">JavaFx TableView疑难详解 | cmlanche</a></p><p><a href="https://community.oracle.com/thread/2474328">Creating columns dynamically | Oracle Community</a></p><p><a href="https://stackoverflow.com/questions/10519534/cell-factory-in-javafx">tableview - Cell factory in javafx - Stack Overflow</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Lambda简化枚举</title>
      <link href="/2018-03-06-%E7%94%A8Lambda%E7%AE%80%E5%8C%96%E6%9E%9A%E4%B8%BE.html"/>
      <url>/2018-03-06-%E7%94%A8Lambda%E7%AE%80%E5%8C%96%E6%9E%9A%E4%B8%BE.html</url>
      
        <content type="html"><![CDATA[<h1 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h1><p>解释器需要能够解释执行一些预设的指令，为了避免字符串判断+switch&#x2F;case的丑陋写法，选择使用枚举类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">  op1 (<span class="string">&quot;op1&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exec</span> <span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  op2 (<span class="string">&quot;op2&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exec</span> <span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">  Operation(String type) &#123; <span class="built_in">this</span>.type = type; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> Data <span class="title function_">exec</span> <span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用Lambda改写"><a href="#用Lambda改写" class="headerlink" title="用Lambda改写"></a>用Lambda改写</h1><p>使用Lambda需要一个只有一个抽象函数的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">exec</span> <span class="params">(Parser parser)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MOperation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MOperation</span> <span class="keyword">implements</span> <span class="title class_">Executable</span> &#123;</span><br><span class="line">  op1(<span class="string">&quot;op1&quot;</span>, (Parser parser) -&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;),</span><br><span class="line">  op2(<span class="string">&quot;op2&quot;</span>, (Parser parser) -&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executable executor;</span><br><span class="line">  MOperation(String type, Executable executor) &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Token <span class="title function_">exec</span> <span class="params">(Parser parser)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> executor.exec(parser);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写之后，不仅枚举部分的代码更简洁直观，而且可以通过<code>executor</code>传参，比之前更灵活</p><hr><p>参考资料</p><p><a href="https://stackoverflow.com/questions/23361418/lambdas-in-the-classical-operation-enum-example">java - Lambdas in the classical Operation enum example - Stack Overflow</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java考试错题</title>
      <link href="/2018-01-25-Java%E8%80%83%E8%AF%95%E9%94%99%E9%A2%98.html"/>
      <url>/2018-01-25-Java%E8%80%83%E8%AF%95%E9%94%99%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h1><p>1-1 <code>JLable</code> can contain other components.</p><p>​false</p><p>1-2 A local class or anonymous class cannot access all local variables from the enclosing method.</p><p>​true</p><p>1-3 Using <code>JPanel p = new JPanel(); BoxLayout b1 = new BoxLayout(p, BoxLayout.X_AXIS);</code> can set the BoxLayout for Panel p.</p><p>​false</p><h1 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h1><p>2-1 Which one below is the correct signature of <code>InputStream.read() </code>?</p><ul><li><p>byte read()</p></li><li><p>char read()</p></li><li><p>int read()</p></li><li><p>long read()</p><p>C</p></li></ul><p>2-2  Which of these methods will make a thread leave the running state, and the method is not static?</p><ul><li><p>notify()</p></li><li><p>Thread.KillThread()</p></li><li><p>yield()</p></li><li><p>wait()</p><p>D</p></li></ul><p>2-3 Which one below is NOT a valid Java identifier?</p><ul><li><p>const</p></li><li><p>$2</p></li><li><p>Double</p></li><li><p>名字</p><p>A</p></li></ul><p>2-4 Choose the best fill in the blanks.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello2017</span></span><br><span class="line">&#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">&#123;</span><br><span class="line">(__<span class="comment">//put the best here__);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Century</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;String m=”Hello”;</span><br><span class="line">Century(String m)&#123;</span><br><span class="line"><span class="built_in">this</span>.m=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>new Century(“Hello”).start();</p></li><li><p>new Thread(“Hello”).start();</p></li><li><p>new Century(new Thread()).start();</p></li><li><p>new Thread(new Century()).start();</p><p>A</p></li></ul><p>2-5 For object <code>o</code> and class <code>C </code>, which expression below is the right way to test if <code>o</code> is an object of <code>C</code>?</p><ul><li><p><code>C.isInstance(o)</code></p></li><li><p><code>o.class == C</code></p></li><li><p><code>o instanceof C</code></p></li><li><p><code>o.getClass() == C</code></p><p>not D</p></li></ul><p>2-6 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">if</span> (x==-x) </span><br><span class="line">System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">System.out.println(<span class="string">&quot;NOT&quot;</span>);</span><br></pre></td></tr></table></figure><p>output:</p><ul><li><p>OK</p></li><li><p>NOT</p></li><li><p>overflow</p></li><li><p>error ( compilation or run-time)</p><p>A</p></li></ul><p>2-7 Which of the following is NOT correct?</p><ul><li><p>A Generic Type Parameter of a Class Is Not Allowed in a Static Context</p></li><li><p>Cannot Create an Instance of a Generic Type. (i.e., new E()).</p></li><li><p>Generic Array Creation is Not Allowed. (i.e., new E[100]).</p></li><li><p>Exception Classes Can be Generic.</p><p>not C</p></li></ul><p>2-8 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;(); </span><br><span class="line">List&lt;?&gt; lo = ls; </span><br><span class="line">lo.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); </span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> ls.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>It compiles but exception raises at line 3</p></li><li><p>It does not compile</p></li><li><p>It compiles but exception raises at line 2</p></li><li><p>It compiles but exception raises at line 4</p><p>B</p></li></ul><h1 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h1><p>3-1 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">CloneT</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneT</span>();</span><br><span class="line"><span class="type">CloneT</span> <span class="variable">t</span> <span class="operator">=</span> (CloneT)c.clone();</span><br><span class="line">t.str = <span class="string">&quot;t&quot;</span>;</span><br><span class="line">t.b.setA(<span class="number">3</span>);</span><br><span class="line">System.out.println(t==c);</span><br><span class="line">System.out.println(t.b==c.b);</span><br><span class="line">System.out.println(c.toString()+t.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CloneT</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneT</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;clone not supported!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(i) + String.valueOf(pi) + String.valueOf(num) + str + String.valueOf(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​false</p><p>​true</p><p>​111c3111t3</p><p>3-2 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">2</span>, <span class="number">10</span>).</span><br><span class="line">filter(x-&gt;IntStream.range(<span class="number">2</span>, x).filter(k-&gt;x%k==<span class="number">0</span>).sum()&gt;<span class="number">0</span>).</span><br><span class="line">sum()</span><br></pre></td></tr></table></figure><p>​27</p><p>3-3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> data=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">pd</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; </span><br><span class="line">System.out.println(data+pd);</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> data=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">pd</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.print();</span><br><span class="line">System.out.println(data+pd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAB</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">a.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​3</p><p>​2</p><p>​7</p><p>3-4 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;127&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a==b);  <span class="comment">//1</span></span><br><span class="line">System.out.println(a==c);  <span class="comment">//2 </span></span><br><span class="line">System.out.println(b==c); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​false</p><p>​false</p><p>​true</p><hr><p>to be done:</p><p>解释</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的数组和for-each</title>
      <link href="/2017-12-19-Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8Cfor-each.html"/>
      <url>/2017-12-19-Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8Cfor-each.html</url>
      
        <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>室友的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;</span><br><span class="line">Data[] dataArray = <span class="keyword">new</span> <span class="title class_">Data</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (Data data : dataArray) &#123;</span><br><span class="line">    data.weight = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的错误涉及了数组和for-each遍历</p><h1 id="Create-an-Array"><a href="#Create-an-Array" class="headerlink" title="Create an Array"></a>Create an Array</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>所做的事情仅仅是创建3个int所需的空间，这部分空间内数据清零，然后将首个空间的地址赋给array</p><p>对原生类型(primitive type)数组来说，可以理解为数组内的默认值为0&#x2F;false</p><p>但是对引用类型(reference type)数组来说，就要注意，数组内每个元素（数组内的元素均为引用）的值都是null，编译器并不会帮你调用默认构造函数</p><h1 id="For-each"><a href="#For-each" class="headerlink" title="For-each"></a>For-each</h1><h3 id="Primitive-Type"><a href="#Primitive-Type" class="headerlink" title="Primitive Type"></a>Primitive Type</h3><p>对原生类型的数组(array)或容器(collection)使用for-each进行遍历，编译器会复制出一个temp值，无法改变原数组或容器内元素的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive type in for-each</span></span><br><span class="line"><span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : array1) &#123;</span><br><span class="line">value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : array1) &#123;</span><br><span class="line">System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 0 0 0</span></span><br></pre></td></tr></table></figure><h3 id="Change-of-Reference-Type"><a href="#Change-of-Reference-Type" class="headerlink" title="Change of Reference Type"></a>Change of Reference Type</h3><p>与原生类型相反，对引用类型的数组或容器使用for-each进行遍历，可以改变原数组或容器内元素的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Nico</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Nico (<span class="type">int</span> i) &#123; </span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change of reference type in for-each</span></span><br><span class="line">Nico[] array2 = <span class="keyword">new</span> <span class="title class_">Nico</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array2.length; ++i) &#123;</span><br><span class="line">array2[i] = <span class="keyword">new</span> <span class="title class_">Nico</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Nico value : array2) &#123;</span><br><span class="line">value.i = <span class="number">25252</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Nico value : array2) &#123;</span><br><span class="line">System.out.print(value.i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 25252 25252 25252</span></span><br></pre></td></tr></table></figure><h3 id="Assignment-or-Initialization-of-Reference-Type"><a href="#Assignment-or-Initialization-of-Reference-Type" class="headerlink" title="Assignment or Initialization of Reference Type"></a>Assignment or Initialization of Reference Type</h3><p>当然，也不能只记着“引用类型会改变数组或容器原来的值”</p><p>你应该注意到了，我在前一个例子中对数组赋值时使用的是含index的普通for循环，因为在for-each循环中对元素进行赋值&#x2F;初始化操作同样无法完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assignment of reference type in for-each</span></span><br><span class="line">Nico[] array3 = <span class="keyword">new</span> <span class="title class_">Nico</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (Nico value : array3) &#123;</span><br><span class="line">value = <span class="keyword">new</span> <span class="title class_">Nico</span>(<span class="number">25252</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Nico value : array3) &#123;</span><br><span class="line">System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: null null null</span></span><br></pre></td></tr></table></figure><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>假设引用类型的for-each循环的本质和原生类型的相同，也是编译器声明了一个temp变量，进行验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Nico</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Nico (<span class="type">int</span> i) &#123; </span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nico()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;New Array:&quot;</span>);</span><br><span class="line">Nico[] array4 = <span class="keyword">new</span> <span class="title class_">Nico</span>[<span class="number">3</span>];</span><br><span class="line">System.out.println(<span class="string">&quot;For Loop with Index:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array4.length; ++i) &#123;</span><br><span class="line">array4[i] = <span class="keyword">new</span> <span class="title class_">Nico</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;For-Each Loop:&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Nico value : array4) &#123;</span><br><span class="line">System.out.println(array4[i] + <span class="string">&quot; &quot;</span> + value);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// New Array:</span></span><br><span class="line"><span class="comment">// For Loop with Index:</span></span><br><span class="line"><span class="comment">// Nico()</span></span><br><span class="line"><span class="comment">// Nico()</span></span><br><span class="line"><span class="comment">// Nico()</span></span><br><span class="line"><span class="comment">// For-Each Loop:</span></span><br><span class="line"><span class="comment">// Nico@15db9742 Nico@15db9742</span></span><br><span class="line"><span class="comment">// Nico@6d06d69c Nico@6d06d69c</span></span><br><span class="line"><span class="comment">// Nico@7852e922 Nico@7852e922</span></span><br></pre></td></tr></table></figure><p>可以看到</p><ol><li>新建数组时构造函数并没有被调用</li><li><code>value</code> 和 <code>array4[i]</code> 是对同一个对象的不同引用</li></ol><p>所以，如果你想用for-each循环进行赋值或初始化的话，结果是 <code>value</code> 指向了新的值，但是 <code>array4[i]</code> 还指向旧的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Nico[] array5 = <span class="keyword">new</span> <span class="title class_">Nico</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (Nico value : array5) &#123;</span><br><span class="line">    System.out.println(array5[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + value);</span><br><span class="line">    <span class="comment">// array[0] -&gt; null</span></span><br><span class="line">    <span class="comment">// value -&gt; null</span></span><br><span class="line"></span><br><span class="line">    value = <span class="keyword">new</span> <span class="title class_">Nico</span>(<span class="number">25252</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(array5[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + value);</span><br><span class="line">    <span class="comment">// array[0] -&gt; null</span></span><br><span class="line">    <span class="comment">// value -&gt; Nico@xxxxxxxx</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// null null</span></span><br><span class="line"><span class="comment">// Nico()</span></span><br><span class="line"><span class="comment">// null Nico@15db9742</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL中的光照相关</title>
      <link href="/2017-11-04-OpenGL%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7%E7%9B%B8%E5%85%B3.html"/>
      <url>/2017-11-04-OpenGL%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7%E7%9B%B8%E5%85%B3.html</url>
      
        <content type="html"><![CDATA[<h1 id="光照概念"><a href="#光照概念" class="headerlink" title="光照概念"></a>光照概念</h1><p>OpenGL中的光分为四类：</p><ol><li>Anbient  环境光，可以当成没有固定光源，即从各个方向射向物体的光</li><li>Diffuse  漫反射，来自固定光源的光，但是向各个方向均匀反射，各个方向观察到的亮度相同</li><li>Specular 镜面反射，来自固定光源的光，向各个方向不均匀反射，在正对的方向可以看到高光</li><li>Emission 发射光，模拟物体自身发光</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h2><p>光源使用函数<code>glLightfv(light, property, value)</code>设置参数，可设置的属性有</p><ul><li>anbient</li><li>diffuse</li><li>specular</li><li>position</li></ul><h2 id="物体"><a href="#物体" class="headerlink" title="物体"></a>物体</h2><p>物体使用函数<code>glMaterialfv(face, property, value)</code>设置参数，可设置的属性有</p><ul><li>anbient</li><li>diffuse</li><li>specular &amp; shininess</li><li>emission</li></ul><p>为了模拟现实中的情况，一般将anbient与diffuse设置为相同颜色，specular设置为white，shininess取值(0-128)</p><p>如果使用自定义的物体，还需要计算并指定各个顶点的法向量</p><p>&#x2F;&#x2F; to be continued</p><h1 id="函数手册"><a href="#函数手册" class="headerlink" title="函数手册"></a>函数手册</h1><p>参考代码 <a href="https://github.com/hahahaha123567/hello-world/blob/master/Computer%20Graphics/solar.c">solar.c</a></p><h4 id="glLightfv-GL-LIGHTi-GL-POSITION-position"><a href="#glLightfv-GL-LIGHTi-GL-POSITION-position" class="headerlink" title="glLightfv (GL_LIGHTi, GL_POSITION, position)"></a>glLightfv (GL_LIGHTi, GL_POSITION, position)</h4><p>设置光源的位置，其中position[4] &#x3D; {x, y, z, w}</p><p>if (w &#x3D;&#x3D; 0) { 方向光源，可视为平行光; }<br>else (w &gt; 0) { 点光源 }</p><hr><p>参考资料</p><p><a href="http://www.cnblogs.com/SZLLQ2000/p/5194656.html">RGBA HSB opengl光照模型 - szllq2000 - 博客园</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解openGL中的矩阵操作</title>
      <link href="/2017-10-27-%E7%90%86%E8%A7%A3openGL%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C.html"/>
      <url>/2017-10-27-%E7%90%86%E8%A7%A3openGL%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C.html</url>
      
        <content type="html"><![CDATA[<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>openGL中的矩阵是一组提供了接口的二维数组，用来表示图形的变换</p><p>空间中点的坐标由一维数组(vector)表示，用矩阵表示点将要进行的变换，相乘后即得到变换后的坐标</p><h3 id="从笛卡尔坐标-Cartesian-Coordinates-到齐次坐标-Homogeneous-Coordinates"><a href="#从笛卡尔坐标-Cartesian-Coordinates-到齐次坐标-Homogeneous-Coordinates" class="headerlink" title="从笛卡尔坐标(Cartesian Coordinates)到齐次坐标(Homogeneous Coordinates)"></a>从笛卡尔坐标(Cartesian Coordinates)到齐次坐标(Homogeneous Coordinates)</h3><p>点的坐标可以用一个三维vector表示，进行rotate和scale变换时乘对应的矩阵(3 * 3)即可完成变换。但对translate变换，乘一个3 * 3的矩阵并不能直接完成，因此为了将所有变换的实现都统一到矩阵的乘法，在进行变换时将点的坐标扩展到四维，对应的矩阵也用4 * 4实现，因此openGL中用到的矩阵是4 * 4的</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>openGL中将3D坐标投影到2D屏幕坐标的步骤：</p><ol><li>model-view transform</li><li>projection transform</li><li>apply</li><li>viewport transform</li></ol><p>以下分别进行说明</p><h2 id="Model-View-Transform"><a href="#Model-View-Transform" class="headerlink" title="Model-View Transform"></a>Model-View Transform</h2><p>model指要绘制的物体，view指观察者的位置</p><p>这一阶段包括</p><ol><li>物体在场景中的平移、旋转、缩放</li><li>将场景放在观察者面前</li></ol><p>因为观察者和物体是相对的，观察者的移动相当于物体往相反方向移动，因此两者可以统一为model-view transform</p><p>相关函数</p><ul><li>glTranslate(x, y, z)</li><li>glRotate(rad, vx, vy, vz)</li><li>glScale(x, y, z)</li><li>gluLookAt(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz)</li></ul><h2 id="Projection-Transform"><a href="#Projection-Transform" class="headerlink" title="Projection Transform"></a>Projection Transform</h2><p>在model-view transform中完成了建模后，就需要开始将模型投影到观察者眼中</p><p>投影变换(projection transform)分为两种，透视投影(perspective projection)和正交投影(orthographic projection)</p><h3 id="Perspective-projection"><a href="#Perspective-projection" class="headerlink" title="Perspective projection"></a>Perspective projection</h3><p>透视投影即近小远大的观察方式</p><p>这一步首先要继续对场景进行裁剪(clip)，通过上、下、左、右、近平面、远平面将能显示的部分裁剪成平截椎体(frustum)</p><p>相关函数</p><ul><li>gluPerspective(fovy, aspect, zNear, zFar)</li></ul><h3 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection"></a>Orthographic Projection</h3><p>正交投影即远近一样大的观察方式</p><p>同样进行裁剪</p><p>相关函数</p><ul><li>glOrtho(left, right, bottom, top, near, far)</li></ul><h2 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h2><p>openGL根据前面的变换得到的矩阵进行计算</p><h2 id="Viewport-Transform"><a href="#Viewport-Transform" class="headerlink" title="Viewport Transform"></a>Viewport Transform</h2><p>Apply结束后就得到了2D的投影视图，我们可以根据需要把它放置到当前窗口(window)的指定位置</p><p>相关函数</p><ul><li>glViewport(x, y, width, height)</li></ul><hr><h1 id="Programing"><a href="#Programing" class="headerlink" title="Programing"></a>Programing</h1><p>代码参考 <a href="https://github.com/hahahaha123567/hello-world/blob/master/Computer%20Graphics/projection.c">projection.c</a></p><p>Perspective projection:</p><p>glLookAt()先指定观察者的位置、视线的方向、视线的上方，然后glPerspective()&#x2F;glOrtho()进行剪切，留下可见的部分</p><p>需要注意，__glTranslate()&#x2F;glRotate()等函数在对物体变换的同时也会对坐标系进行变换__。例如，先glTranslate(1, 0, 0)再glRotate(angle, 0, 1, 0)，最终物体不是绕着(0, 0, 0)-&gt;(0, 1, 0)的轴旋转，而是绕着平移后的坐标轴的原点(1, 0, 0)-&gt;(1, 1, 0)的轴旋转，坐标轴改变后同样会影响之后的gluLookAt()等函数的设置，因此一般最后再进行平移旋转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">glLoadIdentity();</span><br><span class="line">glPerspective(forv, aspect, near, far); / glOrtho(left, right, bottom, top, near, far);</span><br><span class="line"></span><br><span class="line">glMatrixMode(GL_MODELVIEW);</span><br><span class="line">glLoadIdentity();</span><br><span class="line">gluLookAt(eye_x, eye_y, eye_z, look_x, look_y, look_z, up_x, up_y, up_z);</span><br><span class="line">glTranslate(x, y, z);</span><br><span class="line">glRotate(angle, x, y, z);</span><br><span class="line">glScale(x, y, z);</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><hr><p>参考资料</p><p>《OpenGL编程指南》第5章</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言的链接环节</title>
      <link href="/2017-10-27-c%E8%AF%AD%E8%A8%80%E7%9A%84%E9%93%BE%E6%8E%A5%E7%8E%AF%E8%8A%82.html"/>
      <url>/2017-10-27-c%E8%AF%AD%E8%A8%80%E7%9A%84%E9%93%BE%E6%8E%A5%E7%8E%AF%E8%8A%82.html</url>
      
        <content type="html"><![CDATA[<h1 id="c程序编译流程"><a href="#c程序编译流程" class="headerlink" title="c程序编译流程"></a>c程序编译流程</h1><p>c语言程序从源代码到可执行文件经过四个步骤</p><ol><li><p>编译预处理</p></li><li><p>编译</p></li><li><p>汇编</p></li><li><p>链接</p></li></ol><p>见 <a href="http://www.cnblogs.com/ggjucheng/archive/2011/12/14/2287738.html#_Toc311642841">Linux GCC常用命令 - ggjucheng - 博客园</a> 的解释</p><h1 id="include-lt-stdio-h-gt"><a href="#include-lt-stdio-h-gt" class="headerlink" title="# include &lt;stdio.h&gt;"></a># include &lt;stdio.h&gt;</h1><p>我们的代码中的<code>#include &lt;stdio.h&gt;</code>的作用是将该头文件中函数的**声明(declaration)**拷贝过来，使程序通过编译</p><p>此时，编译生成的.s文件中并没有实现函数功能的代码，程序只知道去调用一个叫做<code>printf()</code>的函数，而不知道这个函数在哪</p><p>要到第四步链接(link)时，程序才能找到<code>printf()</code>的实现</p><p>但是我们链接时只需要执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o test    # no other lib</span><br></pre></td></tr></table></figure><p>就能生成包含输入输出功能的可执行文件，这是因为编译器悄悄地帮你链接了<code>libc</code>库</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>以Linux环境下的gcc为例</p><p>Linux环境下，静态链接库文件后缀<code>.a</code>，动态链接库文件后缀<code>.so</code></p><h2 id="链接指令"><a href="#链接指令" class="headerlink" title="链接指令"></a>链接指令</h2><p>经过汇编后产生的<code>.o</code>二进制文件需要与代码中include的对应的库文件链接后才能生成最后的可执行文件。例如，多线程编程用到了<code>libpthread.a</code>和<code>libphread.so</code>库文件，在链接时就要指明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o /usr/lib/i386-linux-gun/libpthread.so -o test</span><br></pre></td></tr></table></figure><p>为了防止每次都要输入库文件的绝对路径，Linux的环境变量</p><p><code>LIBRARY_PATH</code>用来指示默认的静态库路径</p><p><code>LD_LIBRARY_PATH</code>用来指示默认的动态库路径</p><h2 id="静态库链接时搜索路径顺序："><a href="#静态库链接时搜索路径顺序：" class="headerlink" title="静态库链接时搜索路径顺序："></a>静态库链接时搜索路径顺序：</h2><ol><li>ld会去找gcc命令中的参数-L后的绝对路径</li></ol><p>根据-l后的文件相对名称（无前缀lib与后缀文件格式）去</p><ol start="2"><li><p><code>LIBRARY_PATH</code></p></li><li><p><code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code> (这是当初compile gcc时写在程序内的)</p></li></ol><p>中找</p><h2 id="动态链接时、执行时搜索路径顺序"><a href="#动态链接时、执行时搜索路径顺序" class="headerlink" title="动态链接时、执行时搜索路径顺序:"></a>动态链接时、执行时搜索路径顺序:</h2><ol><li>ld会去找gcc命令中的参数-L后的绝对路径</li></ol><p>根据-l后的文件相对名称（无前缀lib与后缀文件格式）去</p><ol start="2"><li><p><code>LD_LIBRARY_PATH</code></p></li><li><p>配置文件<code>/etc/ld.so.conf</code>中指定的动态库搜索路径</p></li><li><p><code>/lib</code> <code>/usr/lib</code></p></li></ol><p>中找</p><h2 id="链接实现"><a href="#链接实现" class="headerlink" title="链接实现"></a>链接实现</h2><p>静态链接：将静态库的二进制代码链接到源.o文件中，以后可以独立运行</p><p>动态链接：将动态库的信息链接到源.o文件中，运行时到相关位置去寻找二进制代码</p><h2 id="libc"><a href="#libc" class="headerlink" title="libc"></a>libc</h2><p>libc(libc.a, libc.so) 是 <a href="https://en.wikipedia.org/wiki/C_standard_library">C stand library </a> 的实现，包括<code>stdio.h</code> <code>string.h</code> <code>stdlib.h</code>的头文件的实现，编译器默认自动链接，这就是为什么链接时我们不需要手动指定<code>stdio.h</code>的库</p><p>libc实现了<code>math.h</code>，但在一些平台下依然需要手动指定<code>libm</code></p><hr><p>大一开始学C，现在才赶在学编译原理之前弄懂完整的编译流程，丢人的，褪裙吧</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glut的回调函数</title>
      <link href="/2017-10-18-glut%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html"/>
      <url>/2017-10-18-glut%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h1><p>从行为上概括，回调函数就是用函数指针去调用函数。这样起到的作用与直接调用函数相似，但是灵活性大大增加。</p><p>平时函数的参数是变量的值或变量的指针，调用者就只能传递这个有限的信息；而如果函数的参数可以是其他函数的指针，调用者就向被调用者传递了一个动作。</p><p>举个我们最熟悉的例子，C语言的stdlib.h中的qsort函数的原型是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void qsort (void* base, size_t num, size_t width, int(__cdecl* compare)(const void*, const void*));</span><br></pre></td></tr></table></figure><p>在我们调用qsort的时候，不仅可以传递数组的基地址、数组的元素个数、每个元素占用的字节数这些基本信息，还可以传递“比较”这个动作。</p><p>从<strong>库函数编写者</strong>的角度看更为明显，我需要编写一个函数foo实现功能A，但是功能A的实现过程中有部分动作是不确定的，由foo的调用者决定，就用函数指针做参数来实现。</p><p>总结：实体A提供函数a的指针，调用函数B，B实现的时候就**回调(Callback)**了函数a</p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>从面向对象的角度看，如果是为了实现上述的灵活性，应该尽量避免使用回调函数，去利用面向对象的特性。</p><p>现在我们利用回调是因为可以异步实现，有利有弊。由于本人水平有限，更多的例子可以参考知乎问题 <a href="https://www.zhihu.com/question/19801131">回调函数（callback）是什么？</a></p><h1 id="Callback-Function-in-GLUT"><a href="#Callback-Function-in-GLUT" class="headerlink" title="Callback Function in GLUT"></a>Callback Function in GLUT</h1><h2 id="Program-Format"><a href="#Program-Format" class="headerlink" title="Program Format"></a>Program Format</h2><p>初学openGL，照着例程的格式写出了这样的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void graph (void) &#123;</span><br><span class="line">    glBegin(...);</span><br><span class="line">        ... // points</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line">int main () &#123;</span><br><span class="line">    ... // initial</span><br><span class="line">    ... // create window</span><br><span class="line">    glutDisplayFunc(graph);</span><br><span class="line">    glutMainLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，最后的 <code>glutDisplayFunc()</code>与<code>glutMainLoop()</code>是将画好的图形显示出来的关键。</p><h2 id="Process-of-Execution"><a href="#Process-of-Execution" class="headerlink" title="Process of Execution"></a>Process of Execution</h2><p>这里的<code>glutDisplayFunc()</code>属于回调函数，而<code>glutMainLoop()</code>的作用是进入一个死循环，不断检测程序之前注册的那些回调函数是否应该被调用，类似**轮询(polling)**机制。</p><p>对于<code>glutDisplayFunc()</code>来说，为了防止画面不停绘制占用CPU资源，只有在以下情况发生时才会再次执行</p><ul><li>窗口大小改变</li><li>某个回调函数调用了<code>glutPostRedisplay()</code></li></ul><p>而其他回调函数则会在其对应的时候被触发并执行</p><h1 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h1><p>先给出glut中那些 <a href="https://www.opengl.org/resources/libraries/glut/spec3/node45.html#SECTION00080000000000000000">回调函数的原型</a></p><h2 id="glutKeyboardFunc"><a href="#glutKeyboardFunc" class="headerlink" title="glutKeyboardFunc()"></a>glutKeyboardFunc()</h2><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glutKeyboardFunc (void (*func)(unsigned char key, int x, int y));</span><br></pre></td></tr></table></figure><h3 id="Called"><a href="#Called" class="headerlink" title="Called"></a>Called</h3><p>当按下的是字母键等有对应的ASCII码的键时被调用</p><h3 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h3><p>key:</p><p>按下的键</p><p>x, y:</p><p>鼠标的位置，注意原点(0, 0)为window的左上角</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// control the square with &#x27;w&#x27;, &#x27;a&#x27;, &#x27;s&#x27;, &#x27;d&#x27;</span><br><span class="line">void keyboard (char key, int curr_x, int curr_y)</span><br><span class="line">&#123;</span><br><span class="line">if (key == &#x27;w&#x27;) &#123;</span><br><span class="line">y -= 10;</span><br><span class="line">&#125;</span><br><span class="line">else if (key == &#x27;a&#x27;) &#123;</span><br><span class="line">x -= 10;</span><br><span class="line">&#125;</span><br><span class="line">else if (key == &#x27;s&#x27;) &#123;</span><br><span class="line">y += 10;</span><br><span class="line">&#125;</span><br><span class="line">else if (key == &#x27;d&#x27;) &#123;</span><br><span class="line">x += 10;</span><br><span class="line">&#125;</span><br><span class="line">glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="glutSpecialFunc"><a href="#glutSpecialFunc" class="headerlink" title="glutSpecialFunc()"></a>glutSpecialFunc()</h2><h3 id="Prototype-1"><a href="#Prototype-1" class="headerlink" title="Prototype"></a>Prototype</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glutSpecialFunc (void (*func)(int key, int x, int y));</span><br></pre></td></tr></table></figure><h3 id="Called-1"><a href="#Called-1" class="headerlink" title="Called"></a>Called</h3><p>当按下方向键等没有对应的ASCII码的键时被调用</p><h3 id="Parameter-1"><a href="#Parameter-1" class="headerlink" title="Parameter"></a>Parameter</h3><p>类似<code>glutSpecialFunc()</code></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// control the square with &#x27;up&#x27;, &#x27;down&#x27;, &#x27;left&#x27;, &#x27;right&#x27;</span><br><span class="line">void keyboard_special (int key, int curr_x, int curr_y)</span><br><span class="line">&#123;</span><br><span class="line">if (key == GLUT_KEY_UP) &#123;</span><br><span class="line">y -= 10;</span><br><span class="line">&#125;</span><br><span class="line">else if (key == GLUT_KEY_LEFT) &#123;</span><br><span class="line">x -= 10;</span><br><span class="line">&#125;</span><br><span class="line">else if (key == GLUT_KEY_DOWN) &#123;</span><br><span class="line">y += 10;</span><br><span class="line">&#125;</span><br><span class="line">else if (key == GLUT_KEY_RIGHT) &#123;</span><br><span class="line">x += 10;</span><br><span class="line">&#125;</span><br><span class="line">glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="glutMouseFunc"><a href="#glutMouseFunc" class="headerlink" title="glutMouseFunc()"></a>glutMouseFunc()</h2><h3 id="Prototype-2"><a href="#Prototype-2" class="headerlink" title="Prototype"></a>Prototype</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glutMouseFunc (void (*func)(int button, int state, int x, int y));</span><br></pre></td></tr></table></figure><h3 id="Called-2"><a href="#Called-2" class="headerlink" title="Called"></a>Called</h3><p>当鼠标左键&#x2F;中键&#x2F;右键被按下&#x2F;释放时被调用</p><h3 id="Parameter-2"><a href="#Parameter-2" class="headerlink" title="Parameter"></a>Parameter</h3><p>button:</p><p>被按下&#x2F;释放的是哪个键</p><p>state:</p><p>该键是被按下还是释放</p><p>x, y:</p><p>鼠标的位置，注意原点(0, 0)为window的左上角</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// make the square big by click left mouse</span><br><span class="line">void mouse (int button, int state, int curr_x, int curr_y)</span><br><span class="line">&#123;</span><br><span class="line">if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) &#123;</span><br><span class="line">size += 4;</span><br><span class="line">&#125;</span><br><span class="line">if (size &gt;= 30) &#123;</span><br><span class="line">size = 5;</span><br><span class="line">&#125;</span><br><span class="line">glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="glutMotionFunc-glutPassiveMotionFunc"><a href="#glutMotionFunc-glutPassiveMotionFunc" class="headerlink" title="glutMotionFunc(), glutPassiveMotionFunc()"></a>glutMotionFunc(), glutPassiveMotionFunc()</h2><h3 id="Prototype-3"><a href="#Prototype-3" class="headerlink" title="Prototype"></a>Prototype</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void glutMotionFunc (void (*func)(int x, int y));</span><br><span class="line">void glutPassiveMotionFunc (void (*func)(int x, int y));</span><br></pre></td></tr></table></figure><h3 id="Called-3"><a href="#Called-3" class="headerlink" title="Called"></a>Called</h3><p>当鼠标在被按下的时候移动时，<code>glutMotionFunc()</code>被调用；</p><p>当鼠标在松开的时候移动时，<code>glutPassiveMotionFunc()</code>被调用；</p><h3 id="Parameter-3"><a href="#Parameter-3" class="headerlink" title="Parameter"></a>Parameter</h3><p>x, y:</p><p>鼠标的位置，注意原点(0, 0)为window的左上角</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// drag the square by keep pressing the left mouse</span><br><span class="line">void motion (int curr_x, int curr_y)</span><br><span class="line">&#123;</span><br><span class="line">x = curr_x;</span><br><span class="line">y = curr_y;</span><br><span class="line">glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="glutTimerFunc"><a href="#glutTimerFunc" class="headerlink" title="glutTimerFunc()"></a>glutTimerFunc()</h2><h3 id="Prototype-4"><a href="#Prototype-4" class="headerlink" title="Prototype"></a>Prototype</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glutTimerFunc (unsigned int msecs, void (*func)(int value), int value);</span><br></pre></td></tr></table></figure><h3 id="Called-4"><a href="#Called-4" class="headerlink" title="Called"></a>Called</h3><p>直接被调用，在使用时一般在被调用的函数最后进行递归调用，继续累计时间</p><p>这个函数不是在运行到它时立即执行，所以不算死循环</p><p>常用于render</p><p>在<code>glutTimerFunc()</code>中设置了<code>glutPostRedisplay()</code>后其他回调函数中可以不用再调用</p><h3 id="Parameter-4"><a href="#Parameter-4" class="headerlink" title="Parameter"></a>Parameter</h3><p>msecs:</p><p>时间间隔</p><p>value:</p><p>函数标记</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// act with interval</span><br><span class="line">void timer (int value)</span><br><span class="line">&#123;</span><br><span class="line">y += 1;</span><br><span class="line">glutPostRedisplay();</span><br><span class="line">glutTimerFunc(30, timer, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="glutIdleFunc"><a href="#glutIdleFunc" class="headerlink" title="glutIdleFunc()"></a>glutIdleFunc()</h2><h3 id="Prototype-5"><a href="#Prototype-5" class="headerlink" title="Prototype"></a>Prototype</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glutIdleFunc (void (*func)(void));</span><br></pre></td></tr></table></figure><h3 id="Called-5"><a href="#Called-5" class="headerlink" title="Called"></a>Called</h3><p>空闲时调用</p><p>应尽量减少空闲回调函数中的计算和渲染量，不然会影响其他部分的性能</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;windows.h&gt; // Sleep() in windows</span><br><span class="line"></span><br><span class="line">// act with interval</span><br><span class="line">void idle ()</span><br><span class="line">&#123;</span><br><span class="line">x += 2;</span><br><span class="line">Sleep(20);</span><br><span class="line">glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Public-Part"><a href="#Public-Part" class="headerlink" title="Public Part"></a>Public Part</h2><p>这段代码是上文各回调函数定义的调用部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;gl\glut.h&gt;</span><br><span class="line"></span><br><span class="line">GLint windowSize = 500;</span><br><span class="line">GLint x = 250, y = 250, size = 5;</span><br><span class="line"></span><br><span class="line">int main (int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">glutInit(&amp;argc, argv);</span><br><span class="line">glutInitDisplayMode(GLUT_RGB);</span><br><span class="line">glutInitWindowPosition(300, 100);</span><br><span class="line">glutInitWindowSize(windowSize, windowSize);</span><br><span class="line">glutCreateWindow(&quot;I&#x27;m a window&quot;);</span><br><span class="line">glClearColor(1.0, 1.0, 1.0, 0.0);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">gluOrtho2D(0, 500, 0, 500);</span><br><span class="line"></span><br><span class="line">glutKeyboardFunc(keyboard);</span><br><span class="line">glutSpecialFunc(keyboard_special);</span><br><span class="line">glutMouseFunc(mouse);</span><br><span class="line">glutMotionFunc(motion);</span><br><span class="line">glutIdleFunc(idle);</span><br><span class="line">glutDisplayFunc(graph);</span><br><span class="line">glutTimerFunc(20, timer, 0);</span><br><span class="line">glutMainLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Complete-Program"><a href="#Complete-Program" class="headerlink" title="Complete Program"></a>Complete Program</h2><p><a href="https://github.com/hahahaha123567/hello-world/blob/master/Computer%20Graphics/callback.c">完整代码</a></p><hr><p>几个有用的链接</p><p><a href="https://www.opengl.org/resources/libraries/glut/spec3/spec3.html">按函数介绍GLUT(官方文档)</a></p><p><a href="http://www.lighthouse3d.com/tutorials/glut-tutorial/">按功能介绍GLUT</a></p><p><a href="http://www.cnblogs.com/live41/tag/%E6%B8%B8%E6%88%8F/default.html?page=2">按功能介绍GLUT_个人翻译版</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习使用packet tracer</title>
      <link href="/2017-10-17-%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8packet%20tracer.html"/>
      <url>/2017-10-17-%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8packet%20tracer.html</url>
      
        <content type="html"><![CDATA[<h1 id="配置设备"><a href="#配置设备" class="headerlink" title="配置设备"></a>配置设备</h1><h2 id="界面说明"><a href="#界面说明" class="headerlink" title="界面说明"></a>界面说明</h2><p>每个设备都包括Physical, Config, Cli(PC可以在Desktop的Command Prompt)</p><p>在进行实验时，要先在Physical设置好要用的网卡，然后在Config(GUI界面)或者Cli(命令行界面)进行配置</p><p>以PC为例</p><p><img src="/../../../../image/pc_physical.png" alt="pc_physical"></p><p>红色框为当前可选的网卡列表</p><p>蓝色框为当前设备，需要用到其中的网卡插槽与电源开关<strong>（更换网卡时需要关闭电源，更换结束后打开电源）</strong></p><p>黄色框内为当前选中的网卡信息，更换网卡时需要将当前设备上的网卡拖回网卡列表，然后将黄色框内的网卡拖到当前设备的网卡槽内</p><h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><p><img src="/../../../../image/pc_config_settings.png" alt="pc_config_settings"></p><p>在config-settings界面设置PC的IPV4&#x2F;IPV6的Gateway和DNS Server，可以设置DHCP获取或自己静态设定</p><p><img src="/../../../../image/pc_config_interface.png" alt="pc_config_interface"></p><p>在config-interface界面对当前所接的网卡（图中为FastEthernet0）进行配置</p><p>可以设置MAC Address, IPV4&#x2F;IPV6的IP Address和Subnet Mask, 获取方式为DHCP或手动静态设置</p><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>同PC，注意Switch可以插多个网卡</p><p>Switch连接后需要等待几秒才能联通</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p><img src="/../../../../image/router_config_interface.png" alt="router_config_interface"></p><p><strong>Router的端口默认为OFF，需要手动打开</strong></p><p>在config-interface下对每个网卡端口进行配置</p><h1 id="组建网络"><a href="#组建网络" class="headerlink" title="组建网络"></a>组建网络</h1><p>若提示<code>The cable cannot connect to the port</code>可能为设备网卡端口已经用完，可以给设备增加网卡</p><p>鼠标停留在设备上可以显示该设备的IP等信息</p><p>鼠标停留在端口上可以显示两个端口的信息</p><h2 id="Wirelsee-Network"><a href="#Wirelsee-Network" class="headerlink" title="Wirelsee Network"></a>Wirelsee Network</h2><p>PC要先更换为无线网卡（默认为有线）</p><p>PC上的SSID与密码要与提供网络的无线AP&#x2F;无线Router一致，然后就可以自动连接</p><h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>Switch的端口可以对VLAN进行划分，在逻辑上分成多个子网</p><p>Router可以将端口划分成多个逻辑子端口，与包括多个VLAN的Switch通过将端口设置成Trunk进行连接，基本，命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R1#conf t                                           # 开始配置终端</span><br><span class="line">R1(config)#interface FastEthernet0/0.1              # 创建新的逻辑子端口</span><br><span class="line">R1(config-subif)#encapsulation dot1Q 1              # 用802.1q协议对刚创建的逻辑子端口进行封装，并且VLAN number设置为1</span><br><span class="line">R1(config-subif)#ip address 10.1.0.25 255.255.0.0   # 设置这个逻辑子端口的IP Address与Subnet Mask</span><br><span class="line">R1(config-subif)#exit                               # 退出第一个逻辑子端口的配置</span><br><span class="line">R1(config)#interface FastEthernet0/0.2</span><br><span class="line">R1(config-subif)#encapsulation dot1Q 2</span><br><span class="line">R1(config-subif)#ip address 10.2.0.25 255.255.0.0</span><br><span class="line">R1(config-subif)#exit</span><br></pre></td></tr></table></figure><h2 id="Static-Route"><a href="#Static-Route" class="headerlink" title="Static Route"></a>Static Route</h2><p>这部分主要介绍一下静态路由的概念</p><p>路由器，根据中文译名可以知道是网络中用来指路的设备。一个数据包带着Source Address和Destination Address来到路由器，让路由器给它指路，然后才能传向下一个路由器。因此，在配置静态路由时，需要提供Subnet Address, Mask, Next Hop。</p><p>如果一个路由器收到的包的Destination Address与路由表中的Mask取交集后的地址就是这个Mask对应的子网，就说明路由器认识去那个子网的路，让数据包前往Next Hop，继续让下一个路由器给它指路。</p><p>在配置Static Route时要注意路径是对称的，只配置了子网A到子网B的路径而没有配置B回A的路径同样会使A内PC ping不通B内PC。</p><hr><p>参考资料</p><p><a href="https://wenku.baidu.com/view/b9ff6431b90d6c85ec3ac6eb.html">Packet Tracer 5——11路由器实现Vlan间通信</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
